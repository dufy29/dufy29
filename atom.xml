<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-02-13T08:21:26.741Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>⭐️影单</title>
    <link href="http://example.com/2022/02/13/%E3%80%90%E9%9A%8F%E7%AC%94%E3%80%91%E5%BD%B1%E5%8D%95/"/>
    <id>http://example.com/2022/02/13/%E3%80%90%E9%9A%8F%E7%AC%94%E3%80%91%E5%BD%B1%E5%8D%95/</id>
    <published>2022-02-12T16:00:00.000Z</published>
    <updated>2022-02-13T08:21:26.741Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="我们的父辈"><a href="#我们的父辈" class="headerlink" title="我们的父辈"></a>我们的父辈</h3><p>观看地址：<a href="https://www.nunuyy1.top/dianshiju/15695.html">https://www.nunuyy1.top/dianshiju/15695.html</a></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gzbygckir9j31t40msqcc.jpg" alt="image-20220213161734643"></p><h3 id="画面引起舒适！那些极其治愈的绝美电影镜头"><a href="#画面引起舒适！那些极其治愈的绝美电影镜头" class="headerlink" title="画面引起舒适！那些极其治愈的绝美电影镜头"></a><a href="https://www.bilibili.com/video/BV1T3411h7kN?spm_id_from=333.851.b_7265636f6d6d656e64.6">画面引起舒适！那些极其治愈的绝美电影镜头</a></h3><blockquote><p>电影素材如下∶<br>大鱼、赎罪、野花、闰年、一天、<br>秘密花园、明亮的星、生命之树、<br>纯真年代、狐狸与我、夏日之王、<br>爱你罗茜、通往仙境、绝代艳后、<br>傲慢与偏见、恋恋笔记本、海蒂和爷爷、<br>白日梦想家、可爱的骨头、<br>水晶鞋与玫瑰花、悬崖上的野餐</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gzbxpin6juj31o30u0tk2.jpg" alt="image-20220213155146863"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gzbxpynpkjj31q60r4akj.jpg" alt="image-20220213155212914"></p><h3 id="中英文字幕-纪录片《细胞战场-Battlefield-Cell》"><a href="#中英文字幕-纪录片《细胞战场-Battlefield-Cell》" class="headerlink" title="中英文字幕 纪录片《细胞战场 Battlefield Cell》"></a><a href="https://www.bilibili.com/video/BV13b411c7hc?from=search&seid=7171577791508691940&spm_id_from=333.337.0.0">中英文字幕 纪录片《细胞战场 Battlefield Cell》</a></h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gzbxwknmepj30le09laav.jpg" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;



&lt;h3 id=&quot;我们的父辈&quot;&gt;&lt;a href=&quot;#我们的父辈&quot; class=&quot;headerlink&quot; title=&quot;我们的父辈&quot;&gt;&lt;/a&gt;我们的父辈&lt;/h3&gt;&lt;p&gt;观看地址：&lt;a href=&quot;https://www.nunuy</summary>
      
    
    
    
    <category term="随笔" scheme="http://example.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="电影" scheme="http://example.com/tags/%E7%94%B5%E5%BD%B1/"/>
    
  </entry>
  
  <entry>
    <title>⭐️python源码解读</title>
    <link href="http://example.com/2022/01/03/%E3%80%90%E7%BC%96%E7%A8%8B%E3%80%91python%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    <id>http://example.com/2022/01/03/%E3%80%90%E7%BC%96%E7%A8%8B%E3%80%91python%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</id>
    <published>2022-01-02T16:00:00.000Z</published>
    <updated>2022-01-03T15:38:01.828Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li>陈儒《Python源码剖析》</li><li><a href="https://flaggo.github.io/python3-source-code-analysis/">https://flaggo.github.io/python3-source-code-analysis/</a></li></ol><p>本项目致力于对 Python 3.7 的源码分析，深度参考陈儒大大的《Python 源码剖析》，编写 Python 3 的版本。</p><ol start="3"><li></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;





&lt;h2 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;陈儒《Python源码剖析》&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;ht</summary>
      
    
    
    
    <category term="编程" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="源码" scheme="http://example.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>⭐️爬虫学习</title>
    <link href="http://example.com/2021/12/18/%E3%80%90%E7%BD%91%E7%BB%9C%E3%80%91%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2021/12/18/%E3%80%90%E7%BD%91%E7%BB%9C%E3%80%91%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-12-17T16:00:00.000Z</published>
    <updated>2021-12-20T00:15:11.809Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="数据抓包"><a href="#数据抓包" class="headerlink" title="数据抓包"></a>数据抓包</h2><h3 id="GET-请求"><a href="#GET-请求" class="headerlink" title="GET 请求"></a>GET 请求</h3><p>在搜索引擎中 输入’history‘,回车：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxjkblgtn2j324u0r8tj9.jpg" alt="image-20211219233146565"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.google.com/search?q=history&amp;sxsrf=AOaemvKJ3ajMp6N_uHAFRuQ2_QSay54LeA:1639927812421&amp;ei=BFC_YYOjGemkrgTIxoeIAQ&amp;ved=0ahUKEwiDtd2Vl_D0AhVpkosKHUjjAREQ4dUDCA4&amp;uact=5&amp;oq=history&amp;gs_lcp=Cgdnd3Mtd2l6EAMyBAgjECcyBAgAEEMyBQgAEJECMgUIABCRAjIECC4QQzIFCAAQgAQyBQgAEIAEMgUIABCABDIFCC4QgAQyBQgAEIAEOgcIIxCwAxAnOgcIABBHELADOgcIIxDqAhAnSgQIQRgASgQIRhgAUPkNWPo3YMI5aAVwAngBgAHdCogB3CeSAQc1LTEuMi4ymAEAoAEBsAEKyAEKwAEB&amp;sclient=gws-wiz</span><br></pre></td></tr></table></figure><p>可以知道这是一个GET 请求，且<code>?</code> 后面为get 请求的参数，参数以 ’键值对‘ 的形式出现</p><p> 截取前面的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.google.com/search?q=history</span><br></pre></td></tr></table></figure><p>在 <code>q=</code> 后面直接添加不同搜索内容就可以实现相应的搜索结果：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxjkhmvq55j31pq0kyjxn.jpg" alt="image-20211219233735165"></p><h3 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h3><p>用于<strong>信息提交</strong>的时候，比如注册，登录</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><strong><a href="https://github.com/wistbean/learn_python3_spider">learn_python3_spider</a></strong></li></ol><blockquote><p>python爬虫教程系列、从0到1学习python爬虫，包括浏览器抓包，手机APP抓包，如 fiddler、mitmproxy，各种爬虫涉及的模块的使用，如：requests、beautifulSoup、selenium、appium、scrapy等，以及IP代理，验证码识别，Mysql，MongoDB数据库的python使用，多线程多进程爬虫的使用，css 爬虫加密逆向破解，JS爬虫逆向，分布式爬虫，爬虫项目实战实例等</p></blockquote><ol start="2"><li></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;数据抓包&quot;&gt;&lt;a href=&quot;#数据抓包&quot; class=&quot;headerlink&quot; title=&quot;数据抓包&quot;&gt;&lt;/a&gt;数据抓包&lt;/h2&gt;&lt;h3 id=&quot;GET-请求&quot;&gt;&lt;a href=&quot;#GET-请求&quot; class=</summary>
      
    
    
    
    <category term="网络" scheme="http://example.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="爬虫" scheme="http://example.com/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>⭐️玩转树莓派</title>
    <link href="http://example.com/2021/11/21/%E3%80%90%E7%BC%96%E7%A8%8B%E3%80%91%E7%8E%A9%E8%BD%AC%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    <id>http://example.com/2021/11/21/%E3%80%90%E7%BC%96%E7%A8%8B%E3%80%91%E7%8E%A9%E8%BD%AC%E6%A0%91%E8%8E%93%E6%B4%BE/</id>
    <published>2021-11-20T16:00:00.000Z</published>
    <updated>2021-12-06T15:02:07.481Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="树莓派介绍"><a href="#树莓派介绍" class="headerlink" title="树莓派介绍"></a>树莓派介绍</h2><h3 id="各版本电路图"><a href="#各版本电路图" class="headerlink" title="各版本电路图"></a>各版本电路图</h3><p><a href="https://www.raspberrypi.com/documentation/computers/raspberry-pi.html">https://www.raspberrypi.com/documentation/computers/raspberry-pi.html</a></p><h2 id="登录准备"><a href="#登录准备" class="headerlink" title="登录准备"></a>登录准备</h2><h3 id="系统烧录"><a href="#系统烧录" class="headerlink" title="系统烧录"></a>系统烧录</h3><ul><li>OS资源下载</li></ul><p><a href="https://link.segmentfault.com/?enc=SYdBXQMUet9OaWkQvbzaJw==.U0/Giy0C8KU06MigZXGGvDlUQTKUDnN1oo3eSpuXPn8VSxzWvCCOOTG32muvRetW">树莓派（raspberrypi）常用镜像高速下载</a> ：收集了超过12种树莓派系统镜像，同时带有介绍，你可以选择一个最佳的树莓派系统，在页面即可下载系统镜像，非常方便。</p><p><a href="https://link.segmentfault.com/?enc=P8TZmKN1Try4AxNxWIgDbw==.vyWQZA5JMunGT1rbf6wqP0MCTMJmcMh55mhJdyJMOGc=">树莓派操作系统镜像下载地址（史上最全）</a>：收集了树莓派所有的52个系统，而且每一个系统都有简短的介绍。</p><ul><li>使用 Raspberry Pi Imager</li></ul><p><a href="https://www.raspberrypi.com/documentation/computers/getting-started.html">https://www.raspberrypi.com/documentation/computers/getting-started.html</a></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwn7nnpymjj30zg0mmgn7.jpg" alt="image-20211121235610322"></p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><ol><li>编辑 <code>config.txt</code> 在末尾添加  <code>dtoverlay=dwc2 </code></li><li>编辑 <code>cmdline.txt</code>，在 <code>rootwait</code> 后添加一个空格，然后添加 <code>modules-load=dwc2,g_ether</code></li><li>创建一个名为 <code>ssh</code> 的空文件，开启树莓派的 sshd 服务, <code>touch ssh</code></li><li>热点设置，新建 <code>wpa_supplicant.conf</code> 文件写入以下内容</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev</span><br><span class="line">update_config=1</span><br><span class="line">country=CN</span><br><span class="line">network=&#123;</span><br><span class="line">    ssid=&quot;WIFI 的名称&quot;</span><br><span class="line">    psk=&quot;WIFI 密码&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ssh-连接"><a href="#ssh-连接" class="headerlink" title="ssh 连接"></a>ssh 连接</h3><p><strong>手机开启热点，电脑也在同一个热点下</strong></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwobbezstxj30py0dsjsp.jpg" alt="image-20211122224808731"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwobfd0u9cj31940hg41n.jpg" alt="image-20211122225157649"></p><h3 id="mac-终端登录"><a href="#mac-终端登录" class="headerlink" title="mac 终端登录"></a>mac 终端登录</h3><p>ssh 链接  <code>ssh pi@raspberrypi.local</code></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwqns7ri8qj31ac0m6qbm.jpg" alt="image-20211124233043342"></p><p>简单说，SSH是一种网络协议，用于计算机之间的加密登录。SSH是每一台Linux电脑的标准配置。</p><p>SSH主要用于远程登录。假定你要以用户名user，登录远程主机host，只要一条简单命令就可以了。</p><blockquote><p>$ ssh user@host</p></blockquote><p>如果要在Windows系统中使用SSH，会用到另一种软件<a href="http://www.chiark.greenend.org.uk/~sgtatham/putty">PuTTY</a></p><p>参考：<a href="https://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html">SSH原理与运用（一）：远程登录</a></p><h3 id="家里wifi-设置连接"><a href="#家里wifi-设置连接" class="headerlink" title="家里wifi 设置连接"></a>家里wifi 设置连接</h3><p><a href="https://blog.csdn.net/xl15575173411/article/details/77248397">电脑通过wifi连接树莓派3</a></p><p>查看可用的wifi: </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo iwlist wlan0 scan</span><br></pre></td></tr></table></figure><p>然后输入命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/wpa_supplicant/wpa_supplicant.conf</span><br></pre></td></tr></table></figure><p>进入到编辑页面，在最底端加入这样一些语句：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">network=&#123;</span><br><span class="line">ssid=<span class="string">&quot;网络名&quot;</span></span><br><span class="line">psk=<span class="string">&quot;密码&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后输入命令查看树莓派连接wifi的IP地址，记住这个IP地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig wlan0</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwobtf4ykrj30xm0aimzd.jpg" alt="image-20211122230531180"></p><p>重启树莓派，打开ssh登录界面，输入这个IP地址(或 <code>raspberrypi.local</code>)，就不需要网线就能登录树莓派了。</p><h2 id="点亮LED"><a href="#点亮LED" class="headerlink" title="点亮LED"></a>点亮LED</h2><p><a href="https://www.ruanyifeng.com/blog/2017/06/raspberry-pi-tutorial.html">树莓派新手入门教程</a></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwoe395lxfj30jg0cyjsc.jpg" alt="img"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://segmentfault.com/a/1190000021776077">树莓派资源整理汇总(2020年2月18日更新)</a></li><li></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;树莓派介绍&quot;&gt;&lt;a href=&quot;#树莓派介绍&quot; class=&quot;headerlink&quot; title=&quot;树莓派介绍&quot;&gt;&lt;/a&gt;树莓派介绍&lt;/h2&gt;&lt;h3 id=&quot;各版本电路图&quot;&gt;&lt;a href=&quot;#各版本电路图&quot; cl</summary>
      
    
    
    
    <category term="编程" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="树莓派" scheme="http://example.com/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
    <category term="硬件" scheme="http://example.com/tags/%E7%A1%AC%E4%BB%B6/"/>
    
    <category term="开发" scheme="http://example.com/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>⭐️CSAPP笔记</title>
    <link href="http://example.com/2021/11/02/%E3%80%90%E7%BC%96%E7%A8%8B%E3%80%91CSAPP%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2021/11/02/%E3%80%90%E7%BC%96%E7%A8%8B%E3%80%91CSAPP%E7%AC%94%E8%AE%B0/</id>
    <published>2021-11-01T16:00:00.000Z</published>
    <updated>2022-02-12T13:45:41.972Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="Chap2-信息的表示和处理"><a href="#Chap2-信息的表示和处理" class="headerlink" title="Chap2: 信息的表示和处理"></a>Chap2: 信息的表示和处理</h2><p>计算机有自己的处理方式，我们若想利用好计算机，就要知道计算机是表示和处理信息的。计算机有一套自己的处理逻辑，采用二进制系统。</p><p>联想到在NLP 发展里程中，围绕自然语言的表示（one-hot–&gt;word2vec–&gt;bert等）也经历了不断的发展，好的表示有时会带来效果上巨大的跃升</p><p>历史上 <a href="https://www.infoq.cn/article/p0kecufq5f9w_irxji3x">软件缺陷而引发的灾难</a> ：</p><ul><li><em>1996年6月4 日阿丽亚娜5号首次测试发射失败：</em></li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwzy1t88u6j30go0azdfw.jpg" alt="img"></p><ul><li><p><em>再举一个真实的例子， 纽约时报曾经报道，波音 787 的电力控制系统在 248 天电力不中断的状况下会自动关机（这可能发生在飞行途中），为此 FAA (美国联邦航空管理局) 告知航空公司，他们必须每隔 120 天进行一次维护重启，这显然是治标不治本的办法，我们来探究一下其中的真正原因：</em></p><blockquote><p>美国卡内基梅隆大学 (CMU) 的 <a href="http://users.ece.cmu.edu/~koopman/">Phil Koopman</a> 教授指出，这其实是 integer overflow 问题，也就是所谓的整型溢出问题，原文链接在<a href="https://betterembsw.blogspot.com/2015/05/counter-rollover-bites-boeing-787.html">这里</a>，我们简单小结一下，报告指出的248天为：248 days * 24 hours/day  * 60 minute/hour * 60 seconds/minute = 21427200秒，等效于2142720000（以1/100秒来计算），十六进制表示就是：0x7Fb75000 ，而最大的32位正整型是0x7FFFFFFF，248天看起来非常接近该限制，实际上，0x7FFFFFFF = 2147483647 /（24 * 60 * 60）= 24855/100 = 248.55天，因此，实际上崩溃会在248.55天之后发生，也就是说，使用了32位的有符号整型来记录时间（记录的单位是10ms），然后遇到溢出。</p></blockquote></li></ul><h3 id="原码、反码与补码"><a href="#原码、反码与补码" class="headerlink" title="原码、反码与补码"></a>原码、反码与补码</h3><p><a href="https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html">原码, 反码, 补码 详解 </a></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gx1yf53pabj30jw08smxk.jpg" alt="image-20211204175944888"></p><p><strong>原码</strong></p><p>第一位是符号位，其余位表示值。比如如果是8位二进制:</p><blockquote><p>[+1]原 = 0000 0001</p><p>[-1]原 = 1000 0001</p></blockquote><p>第一位是符号位. 因为第一位是符号位, 所以8位二进制数的取值范围就是:</p><blockquote><p>[1111 1111 , 0111 1111]</p></blockquote><p>即</p><blockquote><p>[-127 , 127]</p></blockquote><p><strong>反码</strong></p><p>正数的反码是其本身</p><p>负数的反码是在其原码的基础上, 符号位不变，其余各个位取反.</p><p>e.g.</p><blockquote><p>[+1] = [00000001]原 = [00000001]反</p><p>[-1] = [10000001]原 = [11111110]反</p></blockquote><p>反码还涉及 [ 循环进位] 的问题，比如我们来看看10进制的 (−1) 加上10进制的 (+2) 使用反码怎么运算。</p><pre><code>       二进制    十进制    11111110     -1 +  00000010     +2............    ...  1 00000000      0   &lt;-- 错误结果           1     +1   &lt;-- 加上进位............    ...    00000001      1   &lt;-- 正确结果</code></pre><p>反码的优点：正数和负数的加法都一样， 不需要单独判断符号的电路。但是，0表示还是不唯一</p><p><strong>补码</strong></p><p>正数的补码就是其本身</p><p>负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (<strong>即在反码的基础上+1</strong>)</p><blockquote><p>[+1] = [00000001]原 = [00000001]反 = [00000001]补</p><p>[-1] = [10000001]原 = [11111110]反 = [11111111]补</p></blockquote><p>补码转十进制值的两种方法：</p><ul><li><p>按照定义</p></li><li><p>对于负数，从后往前，找到第一个1，然后，1左边的取反，得到原码，再取反即可</p></li></ul><blockquote><p>e.g.， [1011]补 = -([0101]原)=-7</p></blockquote><p>补码表示的一个显著优点就是补码的减法可以通过补码加法来实现，即补码运算具有如下性质：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gx37auybx8j30wk032mxa.jpg" alt="image-20211205195032550">而‐B补 可以通过将 B补“按位取反，末位加 1” 的法则进行计算。</p><p>e.g.</p><blockquote><p>计算 -3-3  </p><p>   1 0 1<br> - 0 1 1<br>-———<br>    1 0 1<br> + 1 0 1   &lt;—[-B]补<br>-———<br> 1 0 1 0  &lt;— -6</p></blockquote><p><strong>乘法</strong></p><p>乘法亦会转化为加法计算</p><p><em>参见龙芯团队书籍《计算机体系结构基础》p210:</em></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gx371c2fimj3104054wf2.jpg" alt="image-20211205194326629"></p><p>图8.27给出两个 4 位补码相乘的例子。<strong>注意在补码加法运算中，需要进 行 8 位的符号位扩展，并仅保留 8 位结果。</strong></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gx36xtbzg9j31060fswg3.jpg" alt="image-20211205194001174"></p><p>知乎相关提问：<a href="https://www.zhihu.com/question/22420697">补码乘法位级操作过程是这样的么？</a></p><p><strong>一些练习</strong></p><ul><li>整数比较判断（p75–习题2.44）</li></ul><p>考虑 int x, y;  unsigned ux =x</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x&lt;<span class="number">0</span>--&gt; ((x*<span class="number">2</span>)&lt;<span class="number">0</span>)   ❌</span><br><span class="line">ux &gt;<span class="number">-1</span>  ❌</span><br><span class="line">x&gt;y   --&gt;  -x &lt; -y    ❌</span><br><span class="line">x*x &gt;= <span class="number">0</span>      ❌</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x1 = INT_MIN;  <span class="comment">//最小值 1000....00</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;case1: x=%d, x*2=%d\n&quot;</span>, x1, x1*<span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">unsigned</span> ux=<span class="number">5</span>;   <span class="comment">//有符号数会强制转为无符号数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;case2: ux&gt;-1: %d\n&quot;</span>, ux&gt;<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> x2=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> y= INT_MIN;  <span class="comment">// y相反数为自己，仍为最小数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;case3: x &gt;y: %d\n&quot;</span>, x2&gt;y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;case3: -x&lt;-y: %d\n&quot;</span>, -x2&lt;-y);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> x3=<span class="number">50000</span>;   <span class="comment">//溢出</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;case4: x*x: %d\n&quot;</span>, x3*x3);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">case1: x=-2147483648, x*2=0</span><br><span class="line">case2: ux&gt;-1: 0</span><br><span class="line">case3: x &gt;y: 1</span><br><span class="line">case3: -x&lt;-y: 0</span><br><span class="line">case4: x*x: -1794967296</span><br></pre></td></tr></table></figure><ul><li>Brian Kernighan（K&amp;R中的K，也是AWK的作者之一）在谈论<a href="https://www.bilibili.com/video/BV1K64y1Q7Ru/">编程风格</a>的时候举了一个比特操作的例子：</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gx3eu127m6j31j40u0n0j.jpg" alt="image-20211206001313055"></p><ul><li>大小端</li></ul><p>可以通过反汇编查看：<code>objdump -d /bin/ls</code></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gx4iyvlo6dj313407qdim.jpg" alt="image-20211206232145903"></p><p>由上图可知，<code>C5</code>在低地址，所以为 小端表示</p><p>也可以通过字节序展示查看：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Demo_2:观察字节序的一个简单例子</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *pointer;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_bytes</span><span class="params">(pointer start, <span class="keyword">size_t</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\t0x%.2x\n&quot;</span>,start+i, start[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0x01234567</span>;</span><br><span class="line">    show_bytes((pointer) &amp;a, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">////////////////////////////</span></span><br><span class="line"><span class="number">0x7ffee697c8ac</span><span class="number">0x67</span></span><br><span class="line"><span class="number">0x7ffee697c8ad</span><span class="number">0x45</span></span><br><span class="line"><span class="number">0x7ffee697c8ae</span><span class="number">0x23</span></span><br><span class="line"><span class="number">0x7ffee697c8af</span><span class="number">0x01</span></span><br></pre></td></tr></table></figure><h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><p>1985年：IEEE-754 标准</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gx4k4wfr9mj31e808it9l.jpg" alt="image-20211207000208368"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Demo_3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    assert(+<span class="number">0.</span> == <span class="number">-0.</span>);      <span class="comment">// 断言成功</span></span><br><span class="line">    assert(<span class="number">1.0</span>/+<span class="number">0.</span> == <span class="number">1.0</span>/<span class="number">-0.</span>); <span class="comment">// 断言失败</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体编码方式（32位浮点数为例）：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gx4kbm3wvsj31600jg0ve.jpg" alt="image-20211207000838521"></p><p><strong>特别注意</strong>：浮点数加法和乘法不满足结合律 ，也不满足乘法对加法的分配律，以下举例说明：</p><p>(3.14+1e10)-1e10 = 0, 3.14+(1e10-1e10) = 3.14，(1e20 *1e20) * 1e-20= inf, 1e20 * (1e20 * 1e-20)= 1e20</p><p>1e20 * (1e20 - 1e20)= 0.0, 1e20 * 1e20 - 1e20 * 1e20 = NaN</p><p>这些特殊的数学性质对于科学计算程序员和编译器的优化限制都具有重要意义，举例如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x = a + b + c;</span><br><span class="line">y = b + c + d;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译器可能试图通过产生下列代码来省去一个浮点加法</span></span><br><span class="line">t = b + c;</span><br><span class="line">x = a + t;</span><br><span class="line">y = t + d;</span><br><span class="line"><span class="comment">// 但是对x来说，这个计算可能会产生于原始值不同的值,因为它使用了加法运算的不同结合方式</span></span><br></pre></td></tr></table></figure><p>问题理解：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有问题的版本 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">float</span> sum = <span class="number">0.0f</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) sum += i + <span class="number">1</span>;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Sum: %f\n&quot;</span>, sum);  <span class="comment">// Sum: 50002896.000000</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 + 2 + 3 + … + 10000 = 10000 * (10000 + 1) / 2 = 50005000 ?</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修正的版本</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">float</span> sum = <span class="number">0.0f</span>, corr = <span class="number">0.0f</span>; <span class="comment">/* corrective value for rounding error */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">float</span> y = (i + <span class="number">1</span>) - corr; <span class="comment">/* add the correction to specific item */</span></span><br><span class="line">      <span class="keyword">float</span> t = sum + y; <span class="comment">/* bits might be lost */</span></span><br><span class="line">      corr = (t - sum) - y; <span class="comment">/* recover lost bits */</span></span><br><span class="line">      sum = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sum: %f\n&quot;</span>, sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="datalab"><a href="#datalab" class="headerlink" title="datalab"></a>datalab</h3><p><a href="https://github.com/flitdu/c-learning">个人github答案参考：</a>，</p><p><a href="https://zhuanlan.zhihu.com/p/429163387">知乎记录的完成情况</a></p><p><a href="http://csapp.cs.cmu.edu/3e/datalab.pdf">说明文件PDF：</a></p><blockquote><p>This directory contains the files that you will need to run the CS:APP<br>Data Lab, which helps develops the student’s understanding of bit<br>representations, two’s complement arithmetic, and IEEE floating point.</p></blockquote><ul><li>Docker 运行</li></ul><p><a href="https://zhuanlan.zhihu.com/p/82529114">Introduction to CSAPP（八）：Datalab</a></p><blockquote><p>用法详情还是需要你自己去阅读代码中的README文件，加油。总的来说，你需要做的是：</p><ol><li>阅读<code>bits.c</code>的注释与代码</li><li>修改它</li><li>命令行运行<code>./dlc -e bits.c</code>查看自己用了多少操作符，以及是否有代码风格问题</li><li>运行<code>make clean &amp;&amp; make btest</code>编译文件</li><li>运行<code>./btest</code>检查自己是否做对了</li><li>return 1 直到全部做完</li><li>最终运行<code>./driver.pl</code>获得打分</li></ol></blockquote><ul><li>isTmax()</li></ul><p>判断是否是补码最大值，注意<code>Test isTmax(-1[0xffffffff]) failed...</code>  特例的排除</p><p><a href="https://zhuanlan.zhihu.com/p/59534845">CSAPP 之 DataLab详解，没有比这更详细的了</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * isTmax - returns 1 if x is the maximum, two&#x27;s complement number,</span></span><br><span class="line"><span class="comment"> *     and 0 otherwise </span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | +</span></span><br><span class="line"><span class="comment"> *   Max ops: 10</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isTmax</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">  x max value is 01111...1111</span></span><br><span class="line"><span class="comment">  the destnitation is get all zero from x</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">int</span> i = x+<span class="number">1</span>; <span class="comment">// 10000...000</span></span><br><span class="line">  x = x+i;  <span class="comment">// 1111..111</span></span><br><span class="line">  x = ~x;  <span class="comment">// 000...000</span></span><br><span class="line">  <span class="comment">//exclude 111..111-------</span></span><br><span class="line">  <span class="comment">// attention int i=0000..000</span></span><br><span class="line">  i = !i;</span><br><span class="line">  x = x+i;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>isAsciiDigit()</li></ul><p>题目说明：若0x30&lt;=x&lt;=0x39（48&lt;=x&lt;=57），则返回1。<a href="https://www.hegongshan.com/2021/05/06/csapp-1-data-lab/">《深入理解计算机系统》实验1.Data Lab</a></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxb4c1x52fj31840ii0wi.jpg" alt="image-20211212161418410"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters &#x27;0&#x27; to &#x27;9&#x27;)</span></span><br><span class="line"><span class="comment"> *   Example: isAsciiDigit(0x35) = 1.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x3a) = 0.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x05) = 0.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 15</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isAsciiDigit</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !((x &gt;&gt; <span class="number">3</span>) ^ <span class="number">0x6</span>) | !((x &gt;&gt; <span class="number">1</span>) ^ <span class="number">0x1c</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>isLessOrEqual() </li></ul><p>判断是否 &lt;=, <a href="https://www.hegongshan.com/2021/05/06/csapp-1-data-lab/">《深入理解计算机系统》实验1.Data Lab</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isLessOrEqual</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sign_x = x &gt;&gt; <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">int</span> sign_y = y &gt;&gt; <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">int</span> is_different_sign = sign_x ^ sign_y;</span><br><span class="line">    <span class="keyword">int</span> negate_x = ~x + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> sign_y_minus_x = (y + negate_x) &gt;&gt; <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">return</span> (!!(is_different_sign &amp; sign_x)) | ((!is_different_sign) &amp; (!sign_y_minus_x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对第一种情况，x&lt;0≤y，可以通过如下变换得到唯一为1 情况，然后取 2次 ! 变为 True</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxb6xvgjehj30pk0cyt9f.jpg" alt="image-20211212174427405"></p><ul><li>logicalNeg() </li></ul><p>题目说明：实现逻辑非!运算。<a href="https://www.hegongshan.com/2021/05/06/csapp-1-data-lab/">《深入理解计算机系统》实验1.Data Lab</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * logicalNeg - implement the ! operator, using all of </span></span><br><span class="line"><span class="comment"> *              the legal operators except !</span></span><br><span class="line"><span class="comment"> *   Examples: logicalNeg(3) = 0, logicalNeg(0) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 4 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">logicalNeg</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((x | (~x + <span class="number">1</span>)) &gt;&gt; <span class="number">31</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="补充资料"><a href="#补充资料" class="headerlink" title="补充资料"></a>补充资料</h3><p><a href="https://www.bilibili.com/video/BV1a54y1k7YE?p=4">CMU教授的视频教程 - Lecture4：Floating Point</a></p><p><a href="https://www.bilibili.com/video/BV1g5411K7Z7?p=17">计算机结构的伟大思想 - P17：浮点数运算</a> (40:00开始~)</p><p><a href="https://www.bilibili.com/video/BV1554y1s7LS?p=27">台湾元智大学计算机组成原理：浮点数-1</a>，</p><p> <a href="https://www.bilibili.com/video/BV1554y1s7LS?p=28">台湾元智大学计算机组成原理：浮点数-2</a> （中文讲解很清楚）</p><p>PS. 一个很有意思的介绍浮点数的网站：<a href="https://0.30000000000000004.com/">https://0.30000000000000004.com</a></p><p>谷歌要花费力气来设计自己的BFloat16，详情请参考：<a href="https://en.wikipedia.org/wiki/Bfloat16_floating-point_format">Google BFloat16</a></p><p>什么是有品位的程序？<a href="https://www.bilibili.com/video/BV1Cs411y7GQ?from=search&seid=13695301827862285580">Linus Torvalds 2016年TED采访</a>，14:26开始，拿出两个单向链表操作为例， 说明了什么是有品位的程序。 </p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gx6p3o3clij31fg0u0jvz.jpg" alt="image-20211207234603349"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初学者版本</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove_list_node</span><span class="params">(List *<span class="built_in">list</span>, Node *target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node *prev = <span class="literal">NULL</span>;</span><br><span class="line">    Node *cur = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    <span class="comment">// Walk the list</span></span><br><span class="line">    <span class="keyword">while</span> (cur != target) &#123;</span><br><span class="line">        prev = cur;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Remove the target by updating the head or the previous node.</span></span><br><span class="line">    <span class="keyword">if</span> (!prev)</span><br><span class="line">        <span class="built_in">list</span>-&gt;head = target-&gt;next;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        prev-&gt;next = target-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有品位的版本，消除特例，简单优雅的代码</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove_list_node</span><span class="params">(List *<span class="built_in">list</span>, Node *target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// The &quot;indirect&quot; pointer points to the *address*</span></span><br><span class="line">    <span class="comment">// of the thing we&#x27;ll update.</span></span><br><span class="line">    Node **indirect = &amp;<span class="built_in">list</span>-&gt;head;</span><br><span class="line">    <span class="comment">// Walk the list, looking for the thing that </span></span><br><span class="line">    <span class="comment">// points to the node we want to remove.</span></span><br><span class="line">    <span class="keyword">while</span> (*indirect != target)</span><br><span class="line">        indirect = &amp;(*indirect)-&gt;next;</span><br><span class="line">    *indirect = target-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>位操作计算strlen</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这可能是你的写strlen版本，看起来很精简，但是没有效率！</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">strlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *p = s;</span><br><span class="line">    <span class="keyword">while</span> (*p != ’\<span class="number">0</span>’) p++;</span><br><span class="line">    <span class="keyword">return</span> (p - s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>真是这样？让我们来看看 <a href="https://opensource.apple.com/source/Libc/Libc-583/arm/string/strlen.s">Apple的strlen函数实现</a>，或者看看 <a href="https://code.woboq.org/userspace/glibc/string/strlen.c.html">glibc的strlen函数实现</a></p><p>此外，请参看这个有意思的网页：<a href="http://graphics.stanford.edu/~seander/bithacks.html">位运算的奇技淫巧：Bit Twiddling Hacks</a></p><p><strong>代码检查工具</strong></p><ul><li><p>静态检查工具：静态代码分析是指无需运行被测代码，通过词法分析、语法分析、控制流、数据流分析等技术对程序代码进行扫描，找出代码隐藏的错误和缺陷，比如未初始化，越界，死循环，代码不可达等，在整个软件开发生命周期中，30% 至 70% 的代码逻辑设计和编码缺陷是可以通过静态代码分析来发现和修复的，比如 <a href="http://cppcheck.sourceforge.net/">Cppcheck</a>（开源免费），<a href="https://www.synopsys.com/software-integrity/security-testing/static-analysis-sast.html">Coverity</a>，<a href="https://www.perforce.com/products/klocwork">Klocwork</a>（商业收费）…</p></li><li><p>动态检查工具，比如 <a href="https://valgrind.org/">Valgrind</a>，它是用于构建动态分析工具的探测框架，它包括一个工具集，每个工具执行某种类型的调试、分析或类似的任务，以帮助完善你的程序，比如memory check，Cache miss check …</p></li></ul><p>PS. 一般会把上述的静态/动态检查工具整合到类似 <a href="https://www.jenkins.io/">Jenkins</a> 这样的持续集成（CI）工具之中，代码一有改动就会触发其运行，然后直接观察和分析结果。</p><p><strong>安全编码规范</strong></p><p><a href="http://mirror.informatimago.com/next/developer.apple.com/documentation/Security/Conceptual/SecureCodingGuide/SecureCodingGuide.pdf">Apple Secure Coding Guide</a></p><p><a href="https://google.github.io/styleguide/cppguide.html">Google C++ Style Guide</a></p><p><a href="https://ilcc.gitbooks.io/wiki/content/StyleGuide/Huawei-C/index.html">华为技术有限公司 C语言编程规范</a></p><p>![img](<a href="https://fengmuzi2003.gitbook.io/~/files/v0/b/gitbook-28427.appspot.com/o/assets%2F-MV9vJFv4kmvRLgEog6g%2F-MZLr4QZV6ey-NW43MqJ%2F-MZLu9NpSJs2LmyNovpv%2FProgramming-in-C">https://fengmuzi2003.gitbook.io/~/files/v0/b/gitbook-28427.appspot.com/o/assets%2F-MV9vJFv4kmvRLgEog6g%2F-MZLr4QZV6ey-NW43MqJ%2F-MZLu9NpSJs2LmyNovpv%2FProgramming-in-C</a> bareilly_副本.jpg?alt=media&amp;token=e4a8c6d9-60f9-4d1e-810a-1d4478fbaf73)</p><p><a href="https://www.bell-labs.com/usr/dmr/www/">https://www.bell-labs.com/usr/dmr/www/</a></p><h2 id="Chap3-程序的机器级表示"><a href="#Chap3-程序的机器级表示" class="headerlink" title="Chap3: 程序的机器级表示"></a>Chap3: 程序的机器级表示</h2><p><strong>汇编代码与机器代码</strong></p><p>对于源程序 xx.c，可以通过如下命令生成<strong>汇编代码</strong> <code>xx.s</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -Og -S xx.c</span><br></pre></td></tr></table></figure><p>通过如下命令生成二进制格式的<strong>目标代码</strong><code>xx.o</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -Og -c xx.c</span><br></pre></td></tr></table></figure><p>通过反汇编命令<code>objdump</code>可以将机器代码翻译成汇编代码,查看 .o 文件内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -d xx.o</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0000000000000000 &lt;multstore&gt;:</span><br><span class="line">   0:f3 0f 1e fa          endbr64 </span><br><span class="line">   4:53                   push   %rbx</span><br><span class="line">   5:48 89 d3             mov    %rdx,%rbx</span><br><span class="line">   8:e8 00 00 00 00       callq  d &lt;multstore+0xd&gt;</span><br><span class="line">   d:48 89 03             mov    %rax,(%rbx)</span><br><span class="line">  10:5b                   pop    %rbx</span><br><span class="line">  11:c3                   retq   </span><br></pre></td></tr></table></figure><p><strong>x86-64通用目的寄存器</strong></p><p>用于存储整数数据和指针</p><p>更多寄存器 知识参考：<a href="https://zhuanlan.zhihu.com/p/272135463">一口气看完45个寄存器，CPU核心技术大揭秘</a></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxn0w0gug6j30u00yh79p.jpg" alt="image-20211222232137445"></p><p>其中，调用者、被调用者保存寄存器分类如下：</p><table><thead><tr><th>调用者保存寄存器</th><th>其余</th></tr></thead><tbody><tr><td>被调用者保存寄存器</td><td>%rbx ,%rbp,%r12~%r15</td></tr></tbody></table><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxn1f9t52xj31e60moq7a.jpg" alt="image-20211222234007914"></p><p><strong>操作数类型</strong></p><ul><li><p>寄存器：%rax</p></li><li><p>内存引用：(%rax)</p></li><li><p>立即数: $8</p></li></ul><h3 id="mov指令"><a href="#mov指令" class="headerlink" title="mov指令"></a>mov指令</h3><p>将数据从源位置**<u>复制</u>**到目的位置</p><p>mov 指令的后缀与寄存器的大小一定得是匹配的(e.g. ，movl 中l 表示4 bytes，而寄存器 %eax 的大小也是 4)：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxjfnvay8sj31960jy0vl.jpg" alt="image-20211219205032799"></p><p>c 语言数据类型在 x86-64中的大小：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxjfsqmt0qj30vw0d4q4g.jpg" alt="image-20211219205516203"></p><h3 id="push压栈指令"><a href="#push压栈指令" class="headerlink" title="push压栈指令"></a>push压栈指令</h3><p>e.g. 保存寄存器 rax 内存储的数据 0x123</p><p><code>pushq %rax</code></p><p>等价于如下两步：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">subq $8, %rsp     // 寄存器rsp 值 -8，为待压入的值腾位置</span><br><span class="line">movq %rax, (%rsp)  // 将 寄存器rax 中值复制到新的栈顶位置</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxjijy64hmj313c0i0di0.jpg" alt="image-20211219223036575"></p><h3 id="pop出栈"><a href="#pop出栈" class="headerlink" title="pop出栈"></a>pop出栈</h3><p>同压栈操作类似，pop指令也可等效为如下两步</p><blockquote><p>注意，pop后，内存地址 0x100中保存的数据 0x123依旧存在</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxjiskjxg4j31220hgjte.jpg" alt="image-20211219223853989"></p><h3 id="cmpq指令"><a href="#cmpq指令" class="headerlink" title="cmpq指令"></a>cmpq指令</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">comp</span><span class="params">(<span class="keyword">long</span> a, <span class="keyword">long</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a==b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a in %rdi, b in %rsi</span><br><span class="line">  cmp    %rsi,%rdi   (a-b) 设置条件码寄存器</span><br><span class="line">  sete   %al</span><br><span class="line">  movzbl %al,%eax</span><br><span class="line">  retq</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxko67rt12j313i0fagnn.jpg" alt="image-20211220223031369"></p><h3 id="栈帧-函数调用"><a href="#栈帧-函数调用" class="headerlink" title="栈帧-函数调用"></a>栈帧-函数调用</h3><p>综合以下文章理解之：</p><p>🔥<a href="https://gitbook.coder.cat/function-call-principle/">函数调用原理</a></p><blockquote><p>这是一篇讲述函数调用原理的文章，通过大量的示意图从比较基础的概念开始阐述函数调用时堆栈的完整变化过程，同时还会通过具体例子来分析在X-64平台上函数调用在汇编级的表示，从而深刻理解函数调用原理。最后会提供几个例子来发现C语言函数栈帧的一些有意思的行为</p></blockquote><p><a href="https://ctfbook.ph0en1x.com/reverse/zhan-3001-zhan-zheng-yu-han-shu-diao-yong"><strong>栈、栈帧与函数调用</strong></a></p><p><a href="https://segmentfault.com/a/1190000017151354">函数栈的实现原理</a></p><p><a href="https://www.cnblogs.com/sddai/p/9762968.html">C函数调用过程原理及函数栈帧分析</a></p><p>程序执行时，Linux 会为其在内存中分配相应的空间以支撑程序的运行，如下图所示：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxrky2ndd3j316y0gewgr.jpg" alt="image-20211226215745237"></p><p>在虚拟内存中，内存空间被分为多个区域。代码指令保存在文本段，已初始化的全局变量 <code>global</code> 保存在数据段，程序运行中动态申请的内存<code>malloc(10 * char())</code>放在堆中，而函数执行的时候则在栈中开辟空间运行。例如<code>main</code>函数便占有一个函数栈，其中的变量<code>i</code>和<code>ip</code>都保存在<code>main</code>的栈空间中。</p><p>函数的栈空间有个名字叫做 <code>栈帧</code> (stack frame）</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxrl7exqwij311w0lcq5c.jpg" alt="image-20211226220645984"></p><p>参考：<a href="https://www.bilibili.com/video/BV1DA411Y7jk?p=4">CS50：P4第3周 C语言 字符串 指针 内存管理1:51</a>  讲解交互变量值</p><h3 id="递归调用"><a href="#递归调用" class="headerlink" title="递归调用"></a>递归调用</h3><p>B站视频讲解：<a href="https://www.bilibili.com/video/BV1cD4y1D7uR?p=19">p19- 过程函数调用 07:00</a> </p><h3 id="缓冲区溢出"><a href="#缓冲区溢出" class="headerlink" title="缓冲区溢出"></a>缓冲区溢出</h3><p>of 为overflow.c的可执行文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">echo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">4</span>];   <span class="comment">// stored on the stack</span></span><br><span class="line">  gets(buf);</span><br><span class="line">  <span class="built_in">puts</span>(buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;type a string:&quot;</span>);</span><br><span class="line">  echo();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调试查看地址：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gdb of</span><br><span class="line">b overflow.c:5  # 设置断点</span><br><span class="line">r# 运行</span><br><span class="line">info f   # 打印栈信息</span><br><span class="line">p/a &amp;buf[0]  # 查看 buf地址</span><br></pre></td></tr></table></figure><h3 id="bomb-lab"><a href="#bomb-lab" class="headerlink" title="bomb lab"></a>bomb lab</h3><p><a href="https://zhuanlan.zhihu.com/p/104130161">Introduction to CSAPP（十九）：这可能是你能找到的分析最全的Bomblab了</a></p><p>bomb.c 内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***************************************************************************</span></span><br><span class="line"><span class="comment"> * Dr. Evil&#x27;s Insidious Bomb, Version 1.1</span></span><br><span class="line"><span class="comment"> * Copyright 2011, Dr. Evil Incorporated. All rights reserved.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * LICENSE:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Dr. Evil Incorporated (the PERPETRATOR) hereby grants you (the</span></span><br><span class="line"><span class="comment"> * VICTIM) explicit permission to use this bomb (the BOMB).  This is a</span></span><br><span class="line"><span class="comment"> * time limited license, which expires on the death of the VICTIM.</span></span><br><span class="line"><span class="comment"> * The PERPETRATOR takes no responsibility for damage, frustration,</span></span><br><span class="line"><span class="comment"> * insanity, bug-eyes, carpal-tunnel syndrome, loss of sleep, or other</span></span><br><span class="line"><span class="comment"> * harm to the VICTIM.  Unless the PERPETRATOR wants to take credit,</span></span><br><span class="line"><span class="comment"> * that is.  The VICTIM may not distribute this bomb source code to</span></span><br><span class="line"><span class="comment"> * any enemies of the PERPETRATOR.  No VICTIM may debug,</span></span><br><span class="line"><span class="comment"> * reverse-engineer, run &quot;strings&quot; on, decompile, decrypt, or use any</span></span><br><span class="line"><span class="comment"> * other technique to gain knowledge of and defuse the BOMB.  BOMB</span></span><br><span class="line"><span class="comment"> * proof clothing may not be worn when handling this program.  The</span></span><br><span class="line"><span class="comment"> * PERPETRATOR will not apologize for the PERPETRATOR&#x27;s poor sense of</span></span><br><span class="line"><span class="comment"> * humor.  This license is null and void where the BOMB is prohibited</span></span><br><span class="line"><span class="comment"> * by law.</span></span><br><span class="line"><span class="comment"> ***************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;support.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;phases.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * Note to self: Remember to erase this file so my victims will have no</span></span><br><span class="line"><span class="comment"> * idea what is going on, and so they will all blow up in a</span></span><br><span class="line"><span class="comment"> * spectaculary fiendish explosion. -- Dr. Evil </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">FILE *infile;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *input;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Note to self: remember to port this bomb to Windows and put a </span></span><br><span class="line"><span class="comment">     * fantastic GUI on it. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* When run with no arguments, the bomb reads its input lines </span></span><br><span class="line"><span class="comment">     * from standard input. */</span></span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">1</span>) &#123;  </span><br><span class="line">infile = <span class="built_in">stdin</span>;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* When run with one argument &lt;file&gt;, the bomb reads from &lt;file&gt; </span></span><br><span class="line"><span class="comment">     * until EOF, and then switches to standard input. Thus, as you </span></span><br><span class="line"><span class="comment">     * defuse each phase, you can add its defusing string to &lt;file&gt; and</span></span><br><span class="line"><span class="comment">     * avoid having to retype it. */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (argc == <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!(infile = fopen(argv[<span class="number">1</span>], <span class="string">&quot;r&quot;</span>))) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s: Error: Couldn&#x27;t open %s\n&quot;</span>, argv[<span class="number">0</span>], argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* You can&#x27;t call the bomb with more than 1 command line argument. */</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Usage: %s [&lt;input_file&gt;]\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">8</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Do all sorts of secret stuff that makes the bomb harder to defuse. */</span></span><br><span class="line">    initialize_bomb();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Welcome to my fiendish little bomb. You have 6 phases with\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;which to blow yourself up. Have a nice day!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Hmm...  Six phases must be more secure than one phase! */</span></span><br><span class="line">    input = read_line();             <span class="comment">/* Get input                   */</span></span><br><span class="line">    phase_1(input);                  <span class="comment">/* Run the phase               */</span></span><br><span class="line">    phase_defused();                 <span class="comment">/* Drat!  They figured it out!</span></span><br><span class="line"><span class="comment">      * Let me know how they did it. */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Phase 1 defused. How about the next one?\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The second phase is harder.  No one will ever figure out</span></span><br><span class="line"><span class="comment">     * how to defuse this... */</span></span><br><span class="line">    input = read_line();</span><br><span class="line">    phase_2(input);</span><br><span class="line">    phase_defused();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;That&#x27;s number 2.  Keep going!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* I guess this is too easy so far.  Some more complex code will</span></span><br><span class="line"><span class="comment">     * confuse people. */</span></span><br><span class="line">    input = read_line();</span><br><span class="line">    phase_3(input);</span><br><span class="line">    phase_defused();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Halfway there!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Oh yeah?  Well, how good is your math?  Try on this saucy problem! */</span></span><br><span class="line">    input = read_line();</span><br><span class="line">    phase_4(input);</span><br><span class="line">    phase_defused();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;So you got that one.  Try this one.\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Round and &#x27;round in memory we go, where we stop, the bomb blows! */</span></span><br><span class="line">    input = read_line();</span><br><span class="line">    phase_5(input);</span><br><span class="line">    phase_defused();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Good work!  On to the next...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This phase will never be used, since no one will get past the</span></span><br><span class="line"><span class="comment">     * earlier ones.  But just in case, make this one extra hard. */</span></span><br><span class="line">    input = read_line();</span><br><span class="line">    phase_6(input);</span><br><span class="line">    phase_defused();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Wow, they got it!  But isn&#x27;t something... missing?  Perhaps</span></span><br><span class="line"><span class="comment">     * something they overlooked?  Mua ha ha ha ha! */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Phase_1 秘密藏在 $0x402400</p><blockquote><p>Border relations with Canada have never been better.</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">0000000000400ee0 &lt;phase_1&gt;:</span><br><span class="line">  400ee0:48 83 ec 08          sub    $0x8,%rsp</span><br><span class="line">  400ee4:be 00 24 40 00       mov    $0x402400,%esi   &lt;--- 藏在这个地址里</span><br><span class="line">  400ee9:e8 4a 04 00 00       callq  401338 &lt;strings_not_equal&gt;</span><br><span class="line">  400eee:85 c0                test   %eax,%eax</span><br><span class="line">  400ef0:74 05                je     400ef7 &lt;phase_1+0x17&gt;</span><br><span class="line">  400ef2:e8 43 05 00 00       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400ef7:48 83 c4 08          add    $0x8,%rsp</span><br><span class="line">  400efb:c3                   retq   </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Phase_2 是在计算一个 等比数列：1 2 4 8 16 32</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">0000000000400efc &lt;phase_2&gt;:</span><br><span class="line">  400efc:55                   push   %rbp</span><br><span class="line">  400efd:53                   push   %rbx</span><br><span class="line">  400efe:48 83 ec 28          sub    $0x28,%rsp</span><br><span class="line">  400f02:48 89 e6             mov    %rsp,%rsi</span><br><span class="line">  400f05:e8 52 05 00 00       callq  40145c &lt;read_six_numbers&gt;</span><br><span class="line">  400f0a:83 3c 24 01          cmpl   $0x1,(%rsp)</span><br><span class="line">  400f0e:74 20                je     400f30 &lt;phase_2+0x34&gt;</span><br><span class="line">  400f10:e8 25 05 00 00       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400f15:eb 19                jmp    400f30 &lt;phase_2+0x34&gt;</span><br><span class="line">  400f17:8b 43 fc             mov    -0x4(%rbx),%eax</span><br><span class="line">  400f1a:01 c0                add    %eax,%eax</span><br><span class="line">  400f1c:39 03                cmp    %eax,(%rbx)</span><br><span class="line">  400f1e:74 05                je     400f25 &lt;phase_2+0x29&gt;</span><br><span class="line">  400f20:e8 15 05 00 00       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400f25:48 83 c3 04          add    $0x4,%rbx</span><br><span class="line">  400f29:48 39 eb             cmp    %rbp,%rbx</span><br><span class="line">  400f2c:75 e9                jne    400f17 &lt;phase_2+0x1b&gt;</span><br><span class="line">  400f2e:eb 0c                jmp    400f3c &lt;phase_2+0x40&gt;</span><br><span class="line">  400f30:48 8d 5c 24 04       lea    0x4(%rsp),%rbx</span><br><span class="line">  400f35:48 8d 6c 24 18       lea    0x18(%rsp),%rbp</span><br><span class="line">  400f3a:eb db                jmp    400f17 &lt;phase_2+0x1b&gt;</span><br><span class="line">  400f3c:48 83 c4 28          add    $0x28,%rsp</span><br><span class="line">  400f40:5b                   pop    %rbx</span><br><span class="line">  400f41:5d                   pop    %rbp</span><br><span class="line">  400f42:c3                   retq   </span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">0000000000400f43 &lt;phase_3&gt;:</span><br><span class="line">  400f43:48 83 ec 18          sub    $0x18,%rsp</span><br><span class="line">  400f47:48 8d 4c 24 0c       lea    0xc(%rsp),%rcx</span><br><span class="line">  400f4c:48 8d 54 24 08       lea    0x8(%rsp),%rdx</span><br><span class="line">  400f51:be cf 25 40 00       mov    $0x4025cf,%esi</span><br><span class="line">  400f56:b8 00 00 00 00       mov    $0x0,%eax</span><br><span class="line">  400f5b:e8 90 fc ff ff       callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">  400f60:83 f8 01             cmp    $0x1,%eax</span><br><span class="line">  400f63:7f 05                jg     400f6a &lt;phase_3+0x27&gt;</span><br><span class="line">  400f65:e8 d0 04 00 00       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400f6a:83 7c 24 08 07       cmpl   $0x7,0x8(%rsp)</span><br><span class="line">  400f6f:77 3c                ja     400fad &lt;phase_3+0x6a&gt;</span><br><span class="line">  400f71:8b 44 24 08          mov    0x8(%rsp),%eax</span><br><span class="line">  400f75:ff 24 c5 70 24 40 00 jmpq   *0x402470(,%rax,8)</span><br><span class="line">  400f7c:b8 cf 00 00 00       mov    $0xcf,%eax</span><br><span class="line">  400f81:eb 3b                jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f83:b8 c3 02 00 00       mov    $0x2c3,%eax</span><br><span class="line">  400f88:eb 34                jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f8a:b8 00 01 00 00       mov    $0x100,%eax</span><br><span class="line">  400f8f:eb 2d                jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f91:b8 85 01 00 00       mov    $0x185,%eax</span><br><span class="line">  400f96:eb 26                jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f98:b8 ce 00 00 00       mov    $0xce,%eax</span><br><span class="line">  400f9d:eb 1f                jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f9f:b8 aa 02 00 00       mov    $0x2aa,%eax</span><br><span class="line">  400fa4:eb 18                jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400fa6:b8 47 01 00 00       mov    $0x147,%eax</span><br><span class="line">  400fab:eb 11                jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400fad:e8 88 04 00 00       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400fb2:b8 00 00 00 00       mov    $0x0,%eax</span><br><span class="line">  400fb7:eb 05                jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400fb9:b8 37 01 00 00       mov    $0x137,%eax</span><br><span class="line">  400fbe:3b 44 24 0c          cmp    0xc(%rsp),%eax</span><br><span class="line">  400fc2:74 05                je     400fc9 &lt;phase_3+0x86&gt;</span><br><span class="line">  400fc4:e8 71 04 00 00       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400fc9:48 83 c4 18          add    $0x18,%rsp</span><br><span class="line">  400fcd:c3   </span><br></pre></td></tr></table></figure><h3 id="补充资料-1"><a href="#补充资料-1" class="headerlink" title="补充资料"></a>补充资料</h3><p><a href="https://www.youtube.com/watch?v=CS01Hmjv1pQ">拉尔夫·兰纳：破解二十一世纪的网络武器–震网病毒</a></p><ul><li><a href="https://cs.brown.edu/courses/cs033/docs/guides/x64_cheatsheet.pdf">x64 Cheat Sheet</a> pdf</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxckpmarcqj30xp0u0wja.jpg" alt="image-20211213222625144"></p><p><strong>x86</strong>指令集自诞生以来指令数量的增长：</p><blockquote><p>From book:《RISC-V-Reader-Chinese-v2p1》</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy0j2omyq4j30v60f6q3z.jpg" alt="image-20220103154354439"></p><ul><li><a href="https://www.bilibili.com/video/BV1EW411u7th?p=7">【计算机科学速成课】7：中央处理器CPU</a></li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz7o6k1pblj31cz0u07g5.jpg" alt="image-20220209231951581"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz8u16aur2j319e0u0tgs.jpg" alt="image-20220210232754012"></p><h2 id="Chap4-处理器体系结构"><a href="#Chap4-处理器体系结构" class="headerlink" title="Chap4: 处理器体系结构"></a>Chap4: 处理器体系结构</h2><h3 id="pipeline"><a href="#pipeline" class="headerlink" title="pipeline??"></a>pipeline??</h3><h3 id="补充资料-2"><a href="#补充资料-2" class="headerlink" title="补充资料"></a>补充资料</h3><p><a href="https://www.bilibili.com/video/BV1q64y1s7MH/?spm_id_from=333.788.recommend_more_video.-1">【硬核科普】全站最硬科普：7分钟带你了解造芯全过程</a></p><p>Patterson演讲：<a href="https://www.bilibili.com/video/BV1fr4y1N7hx/">计算机体系结构的新黄金时代</a>，Hennessy演讲：<a href="https://www.bilibili.com/video/BV1TV411y7Jo/">计算机体系结构的新黄金时代</a></p><p><a href="https://www.bilibili.com/video/BV12A41177Qt?p=1">计算机体系结构（胡伟武 汪文祥）20年秋季学期</a></p><p>关于现代处理器，强烈推荐阅读这份很好的在线文档：<a href="http://www.lighterra.com/papers/modernmicroprocessors/">Modern Microprocessors A 90-Minute Guide!</a><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxyktrcremj324a0r2133.jpg" alt="image-20220101231226145"></p><p>大学伯克利分校 CS61C：<a href="https://www.bilibili.com/video/BV1g5411K7Z7/">计算机架构的伟大思想</a> - 授课教授Krste</p><h2 id="Chap5-优化程序性能"><a href="#Chap5-优化程序性能" class="headerlink" title="Chap5: 优化程序性能"></a>Chap5: 优化程序性能</h2><p><strong>编译器领域最早成名的教材</strong>： <em>Compilers: Principles,Techniques,and Tools，</em>中文名（龙书）：<em>编译原理</em></p><p>本书的一大特点就是抽象难懂，主要讨论了编译器设计的重要主题，包括词法分析、语法分析、语义分析、中间代码生成、代码优化、代码生成等过程</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxtx8zt4y5j30ro0jjjug.jpg" alt="1001948-20171123164637571-2133970350_副本 (1)"></p><p><a href="https://developer.51cto.com/art/202011/630677.htm">详解三大编译器：gcc、llvm 和 clang</a></p><p>传统的编译器通常分为三个部分，前端(frontEnd)，优化器(Optimizer)和后端(backEnd)。在编译过程中，前端主要负责词法和语法分析，将源代码转化为抽象语法树；优化器则是在前端的基础上，对得到的中间代码进行优化，使代码更加高效；后端则是将已经优化的中间代码转化为针对各自平台的机器代码。</p><h2 id="Chap6-存储器层次结构"><a href="#Chap6-存储器层次结构" class="headerlink" title="Chap6: 存储器层次结构"></a>Chap6: 存储器层次结构</h2><p><a href="https://colin-scott.github.io/personal_website/research/interactive_latency.html">计算机访问不同层次存储器的时间开销：</a></p><ul><li>寄存器： 1个CPU周期（1ns）</li><li>内存：0.1-1us</li><li>磁盘： 2ms</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxtz52ohkkj31xp0u0aia.jpg" alt="image-20211228233954700"></p><p><strong>局部性原理</strong></p><p>包括时间局部性、空间局部性，这也是为何缓存为何会有用</p><ul><li>时间局部性：访问某个存储地址时，可能很快再次访问该地址</li><li>空间局部性：访问某个存储地址时，可能很快会访问与之相邻的地址</li></ul><p><strong>存储器的层次结构</strong></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gzb0qltimrj313l0u0dm8.jpg" alt="image-20220212205101744"></p><p>通过缓存机制，大约有<strong>不到 10% 的</strong>存储请求必须直接从RAM 获取</p><p>我们来看一个真实的Intel Core i7 CPU的缓存结构示意图</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxv2as1djvj30n10hcwhd.jpg" alt="img"></p><p><strong>存储器山（Memory Mountain）</strong></p><p>不同的CPU有不同的存储器山</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxv2a2u14kj30n00hbacw.jpg" alt="img"></p><h2 id="Chap7-链接"><a href="#Chap7-链接" class="headerlink" title="Chap7: 链接"></a>Chap7: 链接</h2><p>进程的虚拟地址空间：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxv46lsaolj30jc0fuwg6.jpg" alt="enter image description here"></p><p>（视频讲座）：<a href="https://www.bilibili.com/video/BV1hv411s7ew/">Linux环境下：程序的链接, 装载和库</a>   （比较详细，探讨了很多细节）</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxv4mgcj1tj31qx0u0gt5.jpg" alt="image-20211229233510335"></p><h2 id="Chap8-异常控制流"><a href="#Chap8-异常控制流" class="headerlink" title="Chap8: 异常控制流"></a>Chap8: 异常控制流</h2><p>计算机系统中的抽象：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxv5g6a0edj30zw0f0wgc.jpg" alt="image-20211230000335624"></p><p>操作系统历史：类Unix操作系统的发展与演进</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxw47m038ij30ko0eydht.jpg" alt="img"></p><p><strong>程序 vs 进程</strong></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxw52fywnej30nb0h2gna.jpg" alt="img"></p><p><strong>用户空间 vs 内核空间</strong></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxw659bc3nj30lo0ekach.jpg" alt="img"></p><p>参考：<a href="http://www.ruanyifeng.com/blog/2016/12/user_space_vs_kernel_space.html">阮一峰：User space 与 Kernel space</a></p><h3 id="补充资料-3"><a href="#补充资料-3" class="headerlink" title="补充资料"></a>补充资料</h3><p>文章：<a href="https://liam.page/2017/01/17/layers-and-operation-system/">程序员的自我修养（二）：操作系统、进程与线程</a></p><h2 id="Chap9-虚拟内存"><a href="#Chap9-虚拟内存" class="headerlink" title="Chap9: 虚拟内存"></a>Chap9: 虚拟内存</h2><p><a href="https://www.bilibili.com/video/BV1XB4y1A7vm?p=5"><strong>物理内存有什么问题？</strong></a>    1. 内存空间不够  2. 产生内存碎片  3. 没有内存保护    </p><p>（虚拟内存闪亮登场，本质就是增加一个中间层，计算机科学的任何问题都可以通过增加间接层解决！）</p><p><strong>虚拟内存有什么优点？</strong>    1**.** 可以使用磁盘交换空间  2. 虚拟地址到物理地址映射灵活  3. 进程地址空间隔离</p><p>==&gt; <a href="https://elixir.bootlin.com/glibc/latest/source/malloc/malloc.c">glibc源码一瞥</a> （相关的补充参考资料： <a href="https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/">Understanding glibc malloc</a>）</p><p><strong><em>*</em> 案例参考（遇到的问题 &amp; 解决的方法）</strong>：<a href="https://paper.seebug.org/papers/Archive/refs/heap/glibc%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86ptmalloc%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90.pdf">阿里（华庭=庄明强）：Glibc内存管理ptmalloc源代码分析</a></p><h2 id="Chap10-系统级-I-O"><a href="#Chap10-系统级-I-O" class="headerlink" title="Chap10: 系统级 I/O"></a>Chap10: 系统级 I/O</h2><p><strong>学习系统I/O，标准I/O，最好的办法是：自己动手写一个终端编辑器（功能类似vim）</strong></p><p>可以参考Redis 的作者antirez编写的Kilo，之所以称为Kilo是因为它不到1024行的代码， 他花了几个小时就编写出了文本编辑器的原型，同时antirez表示编写该编辑器的原因很简单：<a href="http://antirez.com/news/108">仅为了乐趣</a> 。</p><p>PS. 这里还有一份很棒的入门指南：<a href="https://viewsourcecode.org/snaptoken/kilo/">Build Your Own Text Editor</a></p><h2 id="Chap11-网路编程"><a href="#Chap11-网路编程" class="headerlink" title="Chap11: 网路编程"></a>Chap11: 网路编程</h2><p>今天互联网中的大千世界都立足于TCP/IP协议之上，Socket甚至已经成为了网络编程的同义词。</p><p>Socket的英文原意为 “插孔” 或者 “插座”，通常称作”套接字”，它允许两个进程进行通信，这两个进程可能运行在同一个机器上，也可能运行在不同机器上。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxyicxi46xj316o0k0wfs.jpg" alt="img"></p><p>从应用程序员的角度来看，它是应用层与TCP/IP协议族通信的中间软件抽象层，是一组接口API。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxyigr4x74j314u0rkacg.jpg" alt="img"></p><p>提及网路编程，W. Richard Stevens对我们这些学习Unix/Linux的程序员的影响是巨大的，每每捧读他写的书都会被感动，不仅被他那丰富的知识所折服，更是被他那一丝不苟，严谨治学的态度所折服。</p><p>“他不清楚的，他下决心要弄明白。他知道的，他要努力传授给所有感兴趣的人们！”这就是Stevens！</p><p>他的个人网站至今还能访问：<a href="http://www.kohala.com/start/%EF%BC%8C%E8%AE%A9%E6%88%91%E4%BB%AC%E5%90%91%E4%BB%96%E8%87%B4%E6%95%AC">http://www.kohala.com/start/，让我们向他致敬</a></p><h2 id="Chap12-并发编程"><a href="#Chap12-并发编程" class="headerlink" title="Chap12: 并发编程"></a>Chap12: 并发编程</h2><p>处理器发展的趋势：多核时代早已到来！免费的午餐已经结束了！</p><p>参考文章（Herb Sutter）：<a href="http://www.gotw.ca/publications/concurrency-ddj.htm">The Free Lunch Is Over: A Fundamental Turn Toward Concurrency in Software</a></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxyjo1ksctj30nm0e0act.jpg" alt="img"></p><p>多核处理器成为上述变革的主流解決方案，想要压榨出更多的处理器效能，软件必须跟上硬件的设计！</p><p><strong>并发与并行</strong></p><p><a href="https://www.bilibili.com/video/BV1EN411o7FY/">【大佬讲座】谷歌大神 Rob Pike：并发 vs 并行 (傻傻分不清楚？)</a></p><p>Concurrency （并发）指程序架构，将程序拆成多个可独立运行的部分，不一定要同时运行，Parallelism（并行） 指程序执行，同时执行多个程序。</p><p>Concurrency 可能会用到 Parallelism，但不一定要用 Parallelism 才能实现 Concurrency。在 Concurrent 中，工作可拆分成「独立执行」的部份，于是「可以」让很多事情一起做，但「不一定」要真的同时做，参见下图。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxyjyjtg7sj31600hitao.jpg" alt="image-20220101224145839"></p><p>那么我们究竟应该如何创建一个并行程序呢？以下流程图示取自CMU：15-418 并行计算架构与编程。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxyk3hp9ifj31490u0gq7.jpg" alt="image-20220101224710564"></p><p>【延伸阅读】：</p><p>卡内基梅隆大学：<a href="https://www.bilibili.com/video/BV1aa4y1s7EH/">并行计算架构与编程 (15-418 / 15-618)</a></p><p>伊利诺伊大学：<a href="https://www.bilibili.com/video/BV1z541137iG/">异构并行编程（胡文美教授）- 重点讲解CUDA编程</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><p><a href="https://fengmuzi2003.gitbook.io/csapp3e/">https://fengmuzi2003.gitbook.io/csapp3e/</a></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxwa4bmaqsj32480qo101.jpg" alt="image-20211202234352970"></p></li><li><p>视频：<a href="https://www.bilibili.com/video/BV1RK4y1R7Kf?p=2&spm_id_from=pageDriver">[原创] 深入理解计算机系统 - CSAPP重点导读（更新完毕）</a><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwzx5yb8rej31og0u011m.jpg" alt="image-20211202234515584"></p></li><li><p>官方Lab 实验：<a href="http://csapp.cs.cmu.edu/3e/labs.html">http://csapp.cs.cmu.edu/3e/labs.html</a></p></li><li><p>github上相关 lab 下载：<a href="https://github.com/Exely/CSAPP-Labs">https://github.com/Exely/CSAPP-Labs</a></p></li><li><p>知乎相关 lab 专栏：<a href="https://zhuanlan.zhihu.com/deeplearningcat">https://zhuanlan.zhihu.com/deeplearningcat</a>  <img src="https://tva1.sinaimg.cn/large/008i3skNgy1gx6w20frn5j31em0tidl7.jpg" alt="image-20211208233527359"></p></li><li><p><a href="https://www.bilibili.com/video/BV1cD4y1D7uR?p=23">【合集】CSAPP-深入理解计算机系统</a> <img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxykv2epifj31rs0r2q8r.jpg" alt="image-20220101231341901"></p></li><li></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;



&lt;h2 id=&quot;Chap2-信息的表示和处理&quot;&gt;&lt;a href=&quot;#Chap2-信息的表示和处理&quot; class=&quot;headerlink&quot; title=&quot;Chap2: 信息的表示和处理&quot;&gt;&lt;/a&gt;Chap2: 信息的表示和处理&lt;</summary>
      
    
    
    
    <category term="编程" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="CS" scheme="http://example.com/tags/CS/"/>
    
    <category term="框架" scheme="http://example.com/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>⭐️c语言学习</title>
    <link href="http://example.com/2021/10/21/%E3%80%90%E7%BC%96%E7%A8%8B%E3%80%91c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2021/10/21/%E3%80%90%E7%BC%96%E7%A8%8B%E3%80%91c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-10-20T16:00:00.000Z</published>
    <updated>2022-01-09T09:34:41.863Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="c语言标准"><a href="#c语言标准" class="headerlink" title="c语言标准"></a>c语言标准</h3><p>C 语言标准的第一次大型修订，发生在1999年，增加了许多语言特性，比如双斜杠（<code>//</code>）的注释语法。这个版本称为 C99，是目前最流行的 C 版本。</p><p>当代很多流行语言都是以 C 语言为基础，比如 C++、Java、C#、JavaScript 等等。学好 C 语言有助于对这些语言加深理解。</p><h3 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h3><p>c 是一种编译型语言，需要经过编译器生成二进制的可执行文件，才能执行</p><p>构建<code>test.c</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用gcc编译：<code>gcc test.c</code>生成 <code>a.out</code></p><p>运行 ‘./a.out’</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out </span><br><span class="line">hello world!</span><br></pre></td></tr></table></figure><p>‘gcc -o’ 还可以指定编译后的文件名：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -o hello test.c</span><br><span class="line">$ ./hello</span><br><span class="line">hello world!</span><br></pre></td></tr></table></figure><h3 id="argc和argv"><a href="#argc和argv" class="headerlink" title="argc和argv[ ]"></a>argc和argv[ ]</h3><p>在c语言编程中，经常可以看到如下的main函数声明：</p><p>e.g.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span>  <span class="comment">// argc: 执行时输入的参数个数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;argc is %d\n&quot;</span>,argc);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;argc;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;argv[%d] is: %s\n&quot;</span>,i,argv[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译：<code>make  hello</code></p><p>运行：<code>./hello</code></p><p>结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">argc is 1</span><br><span class="line">argv[0] is: ./hello</span><br></pre></td></tr></table></figure><p>这表明在执行这个程序时，输入的参数只有一个，而且这个参数就是执行程序的这个命令。</p><p>运行：<code>./hello 123 qwet</code></p><p>结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">argc is 3</span><br><span class="line">argv[0] is: ./hello</span><br><span class="line">argv[1] is: 123</span><br><span class="line">argv[2] is: qwet</span><br></pre></td></tr></table></figure><h3 id="指定运行"><a href="#指定运行" class="headerlink" title="指定运行"></a>指定运行</h3><p>可以通过 <code>#define DEMO_2 </code> 指定不同的函数段运行</p><p>如下，<code>#define DEMO_2</code>则 编译后只 运行 <code>DEMO_2</code> 的程序段</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEMO_2     <span class="comment">//指定运行的函数段</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEMO_1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x1 = INT_MIN;  <span class="comment">//最小值 1000....00</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;case1: x=%d, x*2=%d\n&quot;</span>, x1, x1*<span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">unsigned</span> ux=<span class="number">5</span>;   <span class="comment">//有符号数会强制转为无符号数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;case2: ux&gt;-1: %d\n&quot;</span>, ux&gt;<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> x2=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> y= INT_MIN;  <span class="comment">// y相反数为自己，仍为最小数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;case3: x &gt;y: %d\n&quot;</span>, x2&gt;y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;case3: -x&lt;-y: %d\n&quot;</span>, -x2&lt;-y);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> x3=<span class="number">50000</span>;   <span class="comment">//溢出</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;case4: x*x: %d\n&quot;</span>, x3*x3);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEMO_2</span></span><br><span class="line"><span class="comment">// Demo_2:观察字节序的一个简单例子</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *pointer;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_bytes</span><span class="params">(pointer start, <span class="keyword">size_t</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\t0x%.2x\n&quot;</span>,start+i, start[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0x01234567</span>;</span><br><span class="line">    show_bytes((pointer) &amp;a, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="printf"><a href="#printf" class="headerlink" title="printf"></a>printf</h3><ul><li>输出占位符：</li></ul><table><thead><tr><th>类型</th><th>表达式</th><th>e.g.</th></tr></thead><tbody><tr><td>整数</td><td>%i</td><td><code>printf(&quot;there are %i apples&quot;, 3);</code></td></tr><tr><td>字符串</td><td>%s</td><td><code>    printf(&quot;%s will come tonight&quot;, &quot;Jane&quot;);</code></td></tr><tr><td>小数，包含<code>float</code>类型和<code>double</code>类型）</td><td><code>%f</code></td><td></td></tr><tr><td>指针</td><td>%p</td><td></td></tr><tr><td>字符</td><td><code>%c</code></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *sp = <span class="string">&quot;pointer&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s, %p,%c,%c\n&quot;</span>,sp, sp,*sp,*(sp+<span class="number">2</span>)); </span><br><span class="line">---------</span><br><span class="line">pointer, <span class="number">0x1099d5f96</span>,p,i</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">float</span> x = <span class="number">0.1</span>+<span class="number">0.2</span>;</span><br><span class="line">   <span class="keyword">double</span> y = <span class="number">0.1</span>+<span class="number">0.2</span>;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// printf(&quot;Enter a value for x :\n&quot;);</span></span><br><span class="line">   <span class="comment">// scanf( &quot;%f&quot;, &amp;x);  //键盘输入</span></span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;x is %.17f\n&quot;</span>, x);</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// printf(&quot;Enter a value for y :\n&quot;);</span></span><br><span class="line">   <span class="comment">// scanf( &quot;%lf&quot;, &amp;y);   // 注意这里是 lf</span></span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;y is %.17f\n&quot;</span>, y);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">--------------</span><br><span class="line">x is <span class="number">0.30000001192092896</span></span><br><span class="line">y is <span class="number">0.30000000000000004</span></span><br></pre></td></tr></table></figure><ul><li>限定宽度</li></ul><p>限定占位符的最小宽度，默认为右对齐</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d!!\n&quot;</span>, <span class="number">123</span>); </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%5d!!\n&quot;</span>, <span class="number">123</span>); <span class="comment">// 输出为 &quot;  123&quot;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%-5d!!\n&quot;</span>, <span class="number">123</span>); <span class="comment">// 左对齐</span></span><br><span class="line"><span class="number">123</span>!!</span><br><span class="line">  <span class="number">123</span>!!</span><br><span class="line"><span class="number">123</span>  !!</span><br></pre></td></tr></table></figure><ul><li>小数</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出 &quot;  123.450000&quot;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;123456789012\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%12f\n&quot;</span>, <span class="number">123.45</span>);</span><br><span class="line"><span class="number">123456789012</span></span><br><span class="line">  <span class="number">123.450000</span></span><br></pre></td></tr></table></figure><blockquote><p>解释：<code>%12f</code>表示输出的浮点数最少要占据12位。由于小数的默认显示精度是小数点后6位，所以<code>123.45</code>输出结果的头部会添加2个空格。</p></blockquote><p>小数位数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.3f&quot;</span>, <span class="number">1.36893</span>);</span><br><span class="line"><span class="number">1.369</span></span><br></pre></td></tr></table></figure><p>当然， 可以与限定宽度占位符结合使用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%6.2f&quot;</span>, <span class="number">1.637</span>);</span><br><span class="line">  <span class="number">1.64</span>  <span class="comment">//头部两个空格</span></span><br></pre></td></tr></table></figure><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ul><li>变量 声明</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> height;</span><br><span class="line"><span class="keyword">int</span> height=<span class="number">1</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>变量长度</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gvp9olgt9dj60vy0oeac102.jpg" alt="image-20211023151703661"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> char_len = <span class="keyword">sizeof</span>(<span class="keyword">char</span>);</span><br><span class="line"><span class="keyword">int</span> int_len = <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">int</span> float_len = <span class="keyword">sizeof</span>(<span class="keyword">float</span>);</span><br><span class="line"><span class="keyword">int</span> double_len = <span class="keyword">sizeof</span>(<span class="keyword">double</span>);</span><br><span class="line"><span class="keyword">int</span> long_len = <span class="keyword">sizeof</span>(<span class="keyword">long</span>);</span><br><span class="line"><span class="keyword">int</span>* p;</span><br><span class="line"><span class="keyword">int</span> p_len = <span class="keyword">sizeof</span>(p);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;char length: %d\n&quot;</span>, char_len);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;int length: %d\n&quot;</span>, int_len);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;* length: %d\n&quot;</span>, p_len);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;float length: %d\n&quot;</span>, float_len);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;double length: %d\n&quot;</span>, double_len);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;long length: %d\n&quot;</span>, long_len)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">char length: 1</span><br><span class="line">int length: 4</span><br><span class="line">* length: 8</span><br><span class="line">float length: 4</span><br><span class="line">double length: 8</span><br><span class="line">long length: 8</span><br></pre></td></tr></table></figure><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>何为指针？</p><p>指针是一个值，代表一个内存的地址;</p><p>指针占的字节与平台有关，64位机器占8B</p><p>针对不同的变量类型，可以声明不同的指针，如 <code>char*</code>表示指向字符的指针，<code>int*</code>表示指向整数的指针</p><ul><li>指针变量的初始化</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p;  <span class="comment">//声明指针，这时指针p指向随机的内存地址</span></span><br><span class="line"><span class="keyword">int</span> i;  <span class="comment">//紧接着，声明一个整数变量，随后将p 指向该内存地址</span></span><br><span class="line">p = &amp;i;</span><br><span class="line">*p = <span class="number">14</span>;  <span class="comment">//进行赋值，当然也可以通过 *p 显示对应的值</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;变量值为：%d, %d\n&quot;</span>, i, *p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;内存地址为：%p\n&quot;</span>, p);</span><br><span class="line">---------</span><br><span class="line">变量值为：<span class="number">14</span>, <span class="number">14</span></span><br><span class="line">内存地址为：<span class="number">0x7ffeecb4134c</span></span><br></pre></td></tr></table></figure><ul><li>数组地址</li></ul><p>数组名等同于 起始地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>* p = a;</span><br><span class="line"><span class="keyword">int</span>* q = &amp;a[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">int</span>*r = &amp;a[<span class="number">1</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p, %p, %p&quot;</span>, p,q,r);</span><br><span class="line">------------</span><br><span class="line"><span class="number">0x7ffd4464e890</span>, <span class="number">0x7ffd4464e890</span>, <span class="number">0x7ffd4464e894</span></span><br></pre></td></tr></table></figure><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p>可以保证值在多次调用时候保持不变</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">counter</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">1</span>;  <span class="comment">// 只初始化一次</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, count);</span><br><span class="line">  count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  counter();  <span class="comment">// 1</span></span><br><span class="line">  counter();  <span class="comment">// 2</span></span><br><span class="line">  counter();  <span class="comment">// 3</span></span><br><span class="line">  counter();  <span class="comment">// 4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="od"><a href="#od" class="headerlink" title="od"></a>od</h3><ul><li><a href="https://xxg1413.gitbooks.io/csapp/content/Chapter1/1.1.html">打印文档的ascii 码</a></li></ul><p>e.g. 原始程序如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello, world\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>od -Ax -tcd1 test.c</code></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gvu9hswoqfj31740dq799.jpg" alt="image-20211027225820197"></p><ul><li>显示二进制文件</li></ul><p><code>od -Ax -tx1 hello</code></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gvvde9ol73j31680a8gr2.jpg" alt="image-20211028215854512"></p><p>当然，这些数值，要么是指令，要么是数据</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li><a href="https://wangdoc.com/clang/intro.html">阮一峰c语言教程</a></li></ol><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvnccxa6v1j61i10u041w02.jpg" alt="image-20211021231830501"></p><ol start="2"><li></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;



&lt;h3 id=&quot;c语言标准&quot;&gt;&lt;a href=&quot;#c语言标准&quot; class=&quot;headerlink&quot; title=&quot;c语言标准&quot;&gt;&lt;/a&gt;c语言标准&lt;/h3&gt;&lt;p&gt;C 语言标准的第一次大型修订，发生在1999年，增加了许多语言</summary>
      
    
    
    
    <category term="编程" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="C" scheme="http://example.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>⭐️推荐系统实践</title>
    <link href="http://example.com/2021/09/04/%E3%80%90NLP%E3%80%91%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%AE%9E%E8%B7%B5/"/>
    <id>http://example.com/2021/09/04/%E3%80%90NLP%E3%80%91%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%AE%9E%E8%B7%B5/</id>
    <published>2021-09-03T16:00:00.000Z</published>
    <updated>2021-09-14T13:30:21.332Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>要实现的推荐系统架构：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gu4b6yjw6yj60u00yh77e02.jpg"></p><p>涉及到的技术工具:</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gu4cutyjzbj61hc0rfq7i02.jpg"></p><h2 id="搜索推荐区别"><a href="#搜索推荐区别" class="headerlink" title="搜索推荐区别"></a>搜索推荐区别</h2><p><strong>搜索引擎</strong>更倾向于人们有明确的目的，可以将人们对于信息的寻求转换为精确的关键字，然后交给搜索引擎最后返回给用户一系列列表，用户可以对这些返回结果进行反馈，并且是对于用户有主动意识的，但它会有<strong>马太效应</strong>的问题，即会造成越流行的东西随着搜索过程的迭代会越流行，使得那些越不流行的东西石沉大海。</p><p>而<strong>推荐引擎</strong>更倾向于人们没有明确的目的，或者说他们的目的是模糊的，通俗来讲，用户连自己都不知道他想要什么，这时候正是推荐引擎的用户之地，推荐系统通过用户的历史行为或者用户的兴趣偏好或者用户的人口统计学特征来送给推荐算法，然后推荐系统运用推荐算法来产生用户可能感兴趣的项目列表，同时用户对于搜索引擎是被动的。其中<strong>长尾理论</strong>（人们只关注曝光率高的项目，而忽略曝光率低的项目）可以很好的解释推荐系统的存在，试验表明位于长尾位置的曝光率低的项目产生的利润不低于只销售曝光率高的项目的利润。推荐系统正好可以给所有项目提供曝光的机会，以此来挖掘长尾项目的潜在利润。<br><a href="https://www.zhihu.com/question/38978837/answer/224596814">推荐系统和搜索引擎的关系是什么？</a></p><ul><li>搜索引擎</li></ul><p>①主动&amp;明确</p><p>②个性化需求低</p><p>③快速满足：好的搜索算法让用户获取信息的效率更高、停留时间更短</p><p>④马太效应：强者愈强，弱者愈弱</p><p>⑤评价方法：基于Cranfield评价体系，如nDCG、Precision-Recall、P@N等</p><ul><li>推荐系统</li></ul><p>①被动&amp;模糊</p><p>②个性化需求高</p><p>③持续服务：让用户停留更多的时间</p><p>④满足难以用文字表述的需求——通过推荐系统设置的功能（如“相关推荐”“猜你喜欢”等模块），以及用户的交互（如筛选、排序、点击等），不断积累和挖掘用户偏好——通过分析用户历史行为和当前上下文场景自动生成复杂的查询条件，进而给出计算并推荐的结果</p><p>⑤长尾理论：越来越多被“遗忘”的非热门事物重新被人们关注起来——当我们发现的越多，就越能体会到我们需要更多的选择</p><p>⑥评价方法：Top-N结果推荐时，MAP或CTR；评分预测问题时，RMSE或MAE</p><p>⑦一些指标：增量点击、推荐成功数、成交转化提升量、用户延长的停留时间等</p><h2 id="特征工程"><a href="#特征工程" class="headerlink" title="特征工程"></a>特征工程</h2><p>推荐系统是利用用户信息、物品信息、场景信息【数据】这三大部分有价值的数据，通过构建推荐模型得出推荐列表的工程系统</p><p>特征工程就是利用工程手段从用户信息、物品信息、场景信息中提取特征的过程</p><p>构建推荐系统特征工程的原则：<strong>尽可能地让特征工程抽取出的一组特征，能够保留推荐环境及用户行为工程中的所有‘有用’ 信息，并且尽量摒弃冗余信息</strong></p><h3 id="怎么挑出有用特征"><a href="#怎么挑出有用特征" class="headerlink" title="怎么挑出有用特征"></a>怎么挑出有用特征</h3><p>1）用户行为数据<a name="feature1"></a></p><p>用户行为数据是推荐系统最常用，也是最关键的数据</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gu6598gs7rj31hc0eeq6b.jpg" alt="img"></p><p>2）用户关系数据</p><p>3）属性、标签类数据</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gu65h3i6hhj61hc0iun1202.jpg" alt="img"></p><p>4）内容类数据</p><p>5）场景信息（上下文信息）</p><h3 id="特征处理"><a href="#特征处理" class="headerlink" title="特征处理"></a>特征处理</h3><ul><li>Spark</li></ul><p>spark 是一个分布式计算平台。所谓分布式，指的是计算节点之间不共享内存，需要通过网络通信的方式交换数据</p><p>spark 架构：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gu661rimxbj30m40b8aar.jpg" alt="img"></p><ul><li>特征分类</li></ul><p>广义上，所有特征均可分为两类：</p><p>1） 类别、ID型特征</p><p><strong>序列数据：</strong></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1guatpgzsisj30qo09aabk.jpg" alt="img"></p><p>One-hot, multi-hot, Embedding</p><p>推广：item2vec</p><p><strong>图数据：</strong></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gu9ni7nb52j61hc0i6acq02.jpg" alt="img"></p><p>Graph Embedding， 可以采取如下方法：</p><p><u>【方法一】：Deep Walk</u></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gu9ne7h5fwj61hc0j7jv102.jpg" alt="img"></p><p><u>【方法二】：Node2vec</u></p><p>在同质性 和结构性间权衡</p><p>结构性：u, s_6</p><p>同质性：u,s1,s2..</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1guckvoohhwj61bw0fcwha02.jpg" alt="image-20210911123149663"></p><p>2）数值型特征</p><p>要进行归一化、分桶等.</p><h2 id="线上服务"><a href="#线上服务" class="headerlink" title="线上服务"></a>线上服务</h2><h3 id="线上服务基础"><a href="#线上服务基础" class="headerlink" title="线上服务基础"></a>线上服务基础</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1guct2p9ddcj618y0u0acq02.jpg" alt="img"></p><p>线上服务模块的功能非常繁杂，它不仅需要跟离线训练好的模型打交道，把离线模型进行上线，在线进行模型服务（Model Serving），还需要跟数据库打交道，把候选物品和离线处理好的特征载入到服务器。</p><p>而且线上服务器内部的逻辑也十分地复杂，不仅包括了一些经典的过程，比如召回层和排序层，还包括一些业务逻辑，比如照顾推荐结果多样性，流行度的一些硬性的混合规则，甚至还包括了一些 AB 测试相关的测试代码。</p><ul><li>召回、排序层的特点</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gud3avpwtqj61xv0u0gpx02.jpg" alt="image-20210911230912376"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gud3hguw7uj61hc0aqabz02.jpg" alt="img"></p><p>在设计召回层时，计算速度和召回率其实是两个矛盾的指标</p><ul><li>召回方法</li></ul><p>1）单策略召回</p><p>2）多路召回</p><p>3）基于Embedding 的召回</p><ul><li>高并发处理</li></ul><p>1）负载均衡—&gt;提升服务能力</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1guct6lrq7cj61hc0u0whp02.jpg" alt="img"></p><p>2）缓存—&gt;降低服务压力</p><p>3）推荐服务降级机制—&gt;保证故障时刻的服务不崩溃，压力不传导</p><ul><li>服务框架</li></ul><p>Java 嵌入式服务器 Jetty</p><h3 id="存储模块"><a href="#存储模块" class="headerlink" title="存储模块"></a>存储模块</h3><p><code>QPS</code>: Queries Per Second，每秒查询数。每秒能够响应的查询次数。</p><p>分级存储：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1guczncknflj61140u00uq02.jpg" alt="img"></p><p>SparrowRecsys项目的存储方案：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1guczy1zsrbj31hc0giwhe.jpg" alt="img"></p><h3 id="模型服务"><a href="#模型服务" class="headerlink" title="模型服务"></a>模型服务</h3><ul><li>预存推荐结果或Embedding 结果</li><li>预训练 Embedding +轻量级线上模型</li><li>利用PPML 转换和部署模型</li><li>TensorFLow Serving</li></ul><p>Sparrow Recsys项目模型服务部分的架构:</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gudmqml09kj616s0e2wg502.jpg" alt="img"></p><h2 id="推荐模型"><a href="#推荐模型" class="headerlink" title="推荐模型"></a>推荐模型</h2><h3 id="协同过滤"><a href="#协同过滤" class="headerlink" title="协同过滤"></a>协同过滤</h3><p>协同过滤算法，就是一种完全依赖用户和物品之间行为关系的推荐算法<a href="#feature1">（参见特征工程：怎么挑出有用特征）</a></p><p>从字面上看，就是协同大家的反馈、评价和意见一起对海量的信息进行过滤，从中筛选出用户感兴趣的信息</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gue1vzj33yj617p0u0wj102.jpg" alt="image-20210912190549435"></p><ul><li>矩阵分解算法</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gue23bh47ej60x60a4ab202.jpg" alt="image-20210912191252607"></p><h3 id="Embedding-MLP"><a href="#Embedding-MLP" class="headerlink" title="Embedding +MLP"></a>Embedding +MLP</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1guftyptql3j616o0u0gof02.jpg" alt="image-20210914080249751"></p><p>注意，不同的特征处理方式不同：类别特征Embedding，数值型特征直接连接</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ul><li>java8</li></ul><p>卸载不合适的java 版本：<a href="https://www.jianshu.com/p/8de3c3443ab4">mac下卸载jdk</a></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gu7c9vjjdsj60ii026q2w02.jpg" alt="image-20210906234615569"></p><p><a href="https://www.jianshu.com/p/a85658902f26">Mac系统安装JDK1.8及环境变量配置</a></p><ul><li>scala</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gu7c96wg90j609g022t8k02.jpg" alt="image-20210906234535857"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo vim ~/.bash_profile </span><br><span class="line">环境变量设置：</span><br><span class="line">SCALA_HOME=/Users/apple/develop/scala-2.12.1</span><br><span class="line">export PATH=$SCALA_HOME/bin:$PATH</span><br></pre></td></tr></table></figure><p>  生效： source ~/.bash_profile </p><p>(1) scala 运行报错：<a href="https://www.geek-share.com/detail/2759253029.html">https://www.geek-share.com/detail/2759253029.html</a></p><blockquote><p>[ERROR] Failed to construct terminal; falling back to unsupported</p><p>java.lang.NumberFormatException: For input string: “0x100”</p><p>…</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/profile  </span><br><span class="line"># 在环境变量中导入  </span><br><span class="line">export TERM=xterm-color  </span><br></pre></td></tr></table></figure><ul><li>Redis </li></ul><p><a href="https://www.jianshu.com/p/af33284aa57a">mac下安装配置redis</a></p><p>redis 在线：<a href="https://try.redis.io/">https://try.redis.io/</a></p><p><code>brew install redis</code></p><p>启动：<code>/usr/local/bin/redis-server /usr/local/etc/redis.conf</code></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gud2bf22x0j61bw0mkq7d02.jpg" alt="image-20210911223507567"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps aux | grep redis  # 查看redis服务是否启动</span><br><span class="line">redis-cli  # 启动客户端</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li>网课代码<a href="https://github.com/wzhe06/SparrowRecSys#toc1">https://github.com/wzhe06/SparrowRecSys#toc1</a></li><li><a href="http://www.woshipm.com/data-analysis/4542994.html">深入理解：推荐系统中的召回与排序（一）</a></li></ol><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gu8imchlgwj60rq0ei75302.jpg" alt="img"></p><ol start="3"><li>知乎：<a href="https://zhuanlan.zhihu.com/p/138235048">深入理解推荐系统：排序</a></li></ol><p><a href="https://www.zhihu.com/people/wang-he-13-93/posts">https://www.zhihu.com/people/wang-he-13-93/posts</a></p><ol start="4"><li>推荐系统论文阅读</li></ol><p><a href="https://github.com/wzhe06/Reco-papers">https://github.com/wzhe06/Reco-papers</a></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gu9m3pmwe6j622v0u012a02.jpg" alt="image-20210908225714808"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;要实现的推荐系统架构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/008i3skNly1gu4b6yjw6yj60u00yh77e02.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;涉及到的技</summary>
      
    
    
    
    <category term="NLP" scheme="http://example.com/categories/NLP/"/>
    
    
    <category term="推荐" scheme="http://example.com/tags/%E6%8E%A8%E8%8D%90/"/>
    
  </entry>
  
  <entry>
    <title>⭐️论文阅读</title>
    <link href="http://example.com/2021/08/23/%E3%80%90NLP%E3%80%91%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    <id>http://example.com/2021/08/23/%E3%80%90NLP%E3%80%91%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/</id>
    <published>2021-08-22T16:00:00.000Z</published>
    <updated>2021-11-06T14:15:49.716Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="A-Survey-of-the-Usages-of-Deep-Learning-in-Natural-Language-Processing"><a href="#A-Survey-of-the-Usages-of-Deep-Learning-in-Natural-Language-Processing" class="headerlink" title="A Survey of the Usages of Deep Learning in Natural Language Processing"></a>A Survey of the Usages of Deep Learning in Natural Language Processing</h3><p><a href="https://arxiv.org/abs/1807.10854">https://arxiv.org/abs/1807.10854</a></p><p>关于nlp 的综述，便于建立整体框架</p><h3 id="Fine-tune之后的NLP新范式：Prompt"><a href="#Fine-tune之后的NLP新范式：Prompt" class="headerlink" title="Fine-tune之后的NLP新范式：Prompt"></a>Fine-tune之后的NLP新范式：Prompt</h3><p><em><a href="https://arxiv.org/pdf/2107.13586.pdf">https://arxiv.org/pdf/2107.13586.pdf</a></em></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gu8gdf0c7aj612407u0tu02.jpg" alt="image-20210907225334299"></p><h3 id="Apollo，一种针对非凸随机优化的拟牛顿方法"><a href="#Apollo，一种针对非凸随机优化的拟牛顿方法" class="headerlink" title="Apollo，一种针对非凸随机优化的拟牛顿方法"></a>Apollo，一种针对非凸随机优化的拟牛顿方法</h3><blockquote><p>USC提出拟牛顿法深度学习优化器Apollo，效果比肩SGD和Adam</p></blockquote><p><strong>论文地址</strong></p><p><a href="https://arxiv.org/abs/2009.13586">https://arxiv.org/abs/2009.13586</a></p><p><strong>论文源码</strong></p><p><a href="https://github.com/XuezheMax/apollo">https://github.com/XuezheMax/apollo</a> 类型: PyTorch</p><h3 id="不同语言模型与大脑处理的比较"><a href="#不同语言模型与大脑处理的比较" class="headerlink" title="不同语言模型与大脑处理的比较"></a>不同语言模型与大脑处理的比较</h3><p><strong>模型预测出的下一个词越准，它和人类大脑契合度就越高</strong></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gw5sa8shd3j310c0dg0v2.jpg" alt="image-20211106220929207"></p><ul><li>论文：<a href="https://www.pnas.org/content/118/45/e2105646118">https://www.pnas.org/content/118/45/e2105646118</a></li><li>论文预印版（Biorxiv）：<a href="https://www.biorxiv.org/content/biorxiv/early/2020/10/09/2020.06.26.174482.full.pdf">https://www.biorxiv.org/content/biorxiv/early/2020/10/09/2020.06.26.174482.full.pdf</a></li><li>GitHub：<a href="https://github.com/mschrimpf/neural-nlp">https://github.com/mschrimpf/neural-nlp</a></li></ul><p><a href="https://mp.weixin.qq.com/s/_JAe8vEUTlBk1w2tzbab9Q">方向对了？MIT新研究：GPT-3和人类大脑处理语言的方式惊人相似</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;





&lt;h3 id=&quot;A-Survey-of-the-Usages-of-Deep-Learning-in-Natural-Language-Processing&quot;&gt;&lt;a href=&quot;#A-Survey-of-the-Usage</summary>
      
    
    
    
    <category term="NLP" scheme="http://example.com/categories/NLP/"/>
    
    
    <category term="nlp" scheme="http://example.com/tags/nlp/"/>
    
    <category term="论文" scheme="http://example.com/tags/%E8%AE%BA%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>⭐️搜索笔记</title>
    <link href="http://example.com/2021/08/16/%E3%80%90NLP%E3%80%91%E6%90%9C%E7%B4%A2%E8%AE%B0%E5%BD%95/"/>
    <id>http://example.com/2021/08/16/%E3%80%90NLP%E3%80%91%E6%90%9C%E7%B4%A2%E8%AE%B0%E5%BD%95/</id>
    <published>2021-08-15T16:00:00.000Z</published>
    <updated>2022-02-03T08:39:30.333Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li>倒排索引</li></ul><h2 id="学习视频"><a href="#学习视频" class="headerlink" title="学习视频"></a>学习视频</h2><ol><li><a href="https://www.youtube.com/watch?v=vpq1NL6rxog&list=PLmOn9nNkQxJE066izME0gcfLnjaB3wfFm&index=7">【尚硅谷】ElasticSearch-LogStash-Kibana全套视频 理论+实践</a></li></ol><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gyfjfub2wqj31zm0si10v.jpg" alt="image-20220116152000108"></p><p>课件：<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gyfjk7rdoaj30oe03aglt.jpg" alt="image-20220116152412714"></p><h2 id="谷歌搜索原理"><a href="#谷歌搜索原理" class="headerlink" title="谷歌搜索原理"></a>谷歌搜索原理</h2><p>1.<a href="https://www.google.com/search/howsearchworks/">Google 搜索的工作方式</a></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gtk5clpcd1j61it0u0q9m02.jpg"></p><ol start="2"><li><p><a href="https://www.youtube.com/watch?v=0eKVizvYSUQ&ab_channel=Google">How Google Search Works (in 5 minutes)</a></p></li><li><p><a href="https://www.youtube.com/watch?v=J5RZOU6vK4Q&t=130s&ab_channel=Google">How Google makes improvements to its search algorithm</a></p></li><li></li></ol><h2 id="搜索经验"><a href="#搜索经验" class="headerlink" title="搜索经验"></a>搜索经验</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">以前搞过一段时间的搜索，特别是结构化内容搜索中的垂直行业搜索。基本的步骤与非结构化搜索差不多。</span><br><span class="line"></span><br><span class="line">主要包括三块，建库数据引入，建库数据预处理，在线检索。</span><br><span class="line">对于建库数据引入，就是指如何接入站点数据，涉及到爬虫操作。因此，需要了解一下爬虫如何使用。</span><br><span class="line"></span><br><span class="line">建库数据预处理，涉及到数据解析，生成词典，索引，摘要。因为数据预处理分了多个阶段，那么还需要kafka传递，数据预处理还涉及到flink，索引涉及到类似于elasticsearch的引擎，摘要涉及到高效的kv存储系统。因此，这块需要学习。kafka,flink,elasticsearch,kv存储等。</span><br><span class="line"></span><br><span class="line">在线检索是根据用户的query给用户返回搜索结果。首先需要通过语意识别分析出query可能搜索的类别（领域），然后对query进行分词，拿着分词在特定类别下面通过状态机命中模板（词典相关），然后拿模板中字段的值去elasticsearch提取符合条件的key，然后去摘要库获取摘要结果，最后再拿一些网页/用户信息对多条返回结果进行排名，返回最精准的结果给用户。</span><br><span class="line">这里涉及到语意分析，分词，状态机，排序等知识。</span><br><span class="line"></span><br><span class="line">之前关注实战多了点，后续需要补充理论知识。</span><br><span class="line">------------from 极客时间《王喆推荐系统》国庆策划</span><br></pre></td></tr></table></figure><h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><ul><li><a href="https://tech.meituan.com/2021/07/08/multi-business-modeling.html">多业务建模在美团搜索排序中的实践</a></li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gu9lyam76bj612f0u077x02.jpg" alt="图2 系统架构图"></p><ul><li><a href="https://zhuanlan.zhihu.com/p/24083308">浅谈搜索系统</a></li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1guk2wnc9zoj61iv0u0whd02.jpg" alt="preview"></p><ul><li><a href="https://zhuanlan.zhihu.com/p/45878653">两年搜索推荐的技术演进之路</a></li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1guk301fhkwj60vv0k5q3y02.jpg" alt="img"></p><p>出自【1】<a name='toc1'></a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="">参考1</a><a href="#toc1">🔼</a></li><li></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;



&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;倒排索引&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;学习视频&quot;&gt;&lt;a href</summary>
      
    
    
    
    <category term="NLP" scheme="http://example.com/categories/NLP/"/>
    
    
    <category term="搜索" scheme="http://example.com/tags/%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>⭐️网页</title>
    <link href="http://example.com/2021/07/26/%E3%80%90%E7%BD%91%E7%BB%9C%E3%80%91%E7%BD%91%E9%A1%B5/"/>
    <id>http://example.com/2021/07/26/%E3%80%90%E7%BD%91%E7%BB%9C%E3%80%91%E7%BD%91%E9%A1%B5/</id>
    <published>2021-07-25T16:00:00.000Z</published>
    <updated>2022-01-20T14:18:58.137Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Learn/Common_questions/What_is_a_URL">什么是URL？</a></p><p><strong>URL 代表着是统一资源定位符（</strong>Uniform Resource Locator<strong>）</strong>。URL 无非就是一个给定的独特资源在 Web 上的地址。理论上说，每个有效的 URL 都指向一个唯一的资源。这个资源可以是一个 HTML 页面，一个 CSS 文档，一幅图像，等等。</p><p>下面是一些URL的示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://developer.mozilla.org</span><br><span class="line">https://developer.mozilla.org/en-US/docs/Learn/</span><br><span class="line">https://developer.mozilla.org/en-US/search?q=URL</span><br></pre></td></tr></table></figure><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><p><strong>HTML</strong> (HyperText Markup Language)，主要是将关注的内容展示出来</p><p>并且，类似于一个树结构</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gyf8og3fitj31ig0tm0vf.jpg" alt="image-20220116090742388"></p><p>e.g.</p><p>在文本框内，输入内容，点击后实现谷歌搜索</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gyes5fz69kj31jx0u0grf.jpg" alt="image-20220115233550342"></p><p>code：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span></span><br><span class="line">search</span><br><span class="line"><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;https://www.google.com/search&quot;</span> </span></span><br><span class="line"><span class="tag"><span class="attr">method</span>=<span class="string">&quot;get&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;q&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Search&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>模板</li></ul><p>方便简化html 的编写</p><p>e.g.</p><p>模板 <code>layout.html</code> 如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot; viewpoint&quot;</span> <span class="attr">content</span>=<span class="string">&quot;initial-scale=1, width=device-width&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>froshims0<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    &#123;% block body%&#125;&#123;% endblock %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>那么，原始的左侧html 文件，就可简化为➡️的：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gykhz1rucbj31we0so494.jpg" alt="image-20220120221703570"></p><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><p>调整外观</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gyf89wl2g4j31wa06ot95.jpg" alt="image-20220116085343527"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE <span class="selector-tag">html</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">html</span> lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;</span><br><span class="line">css0</span><br><span class="line">&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;<span class="selector-tag">body</span> style=&quot;<span class="attribute">text-align</span>: center;&quot;&gt;</span><br><span class="line">&lt;<span class="selector-tag">header</span> style=&quot;<span class="attribute">font-size</span>: large; &quot;&gt;</span><br><span class="line">Dufy</span><br><span class="line">&lt;/<span class="selector-tag">header</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">main</span> style=&quot;<span class="attribute">font-size</span>: medium; &quot;&gt;</span><br><span class="line">Welcome <span class="selector-tag">to</span> my home page!</span><br><span class="line">&lt;/<span class="selector-tag">main</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">footer</span> style=&quot;<span class="attribute">font-size</span>: small; &quot;&gt;</span><br><span class="line">Copyright &amp;<span class="selector-id">#169</span>; Dufy</span><br><span class="line">&lt;/<span class="selector-tag">footer</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">body</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">html</span>&gt;</span><br></pre></td></tr></table></figure><h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><p>可以实现函数功能，主要用于向HTML页面添加<strong>交互行为</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">function greet()</span><br><span class="line">&#123;</span><br><span class="line">let name = document.querySelector(&quot;#name&quot;).value;</span><br><span class="line">alert(&quot;hello, &quot;+name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;title&gt;</span><br><span class="line">hello1</span><br><span class="line">&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form onsubmit=&quot;greet(); return false;&quot;&gt;</span><br><span class="line">&lt;input autocomplete=&quot;off&quot; autofocus id=&quot;name&quot; type=&quot;text&quot;&gt;</span><br><span class="line">&lt;input type=&quot;submit&quot; &gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gyf90v4kajj31xa0e6t9g.jpg" alt="image-20220116091938174"></p><ul><li>位置定位</li></ul><p><a href="https://www.w3schools.com/html/html5_geolocation.asp">HTML Geolocation API</a></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gyfhlh7ux4j31hc0ak3zd.jpg" alt="image-20220116141612594"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Click the button to get your coordinates.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;getLocation()&quot;</span>&gt;</span>Try It<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;demo&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">var</span> x = <span class="built_in">document</span>.getElementById(<span class="string">&quot;demo&quot;</span>);</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="function"><span class="keyword">function</span> <span class="title">getLocation</span>(<span class="params"></span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="keyword">if</span> (navigator.geolocation) &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    navigator.geolocation.getCurrentPosition(showPosition);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125; <span class="keyword">else</span> &#123; </span></span></span><br><span class="line"><span class="javascript"><span class="xml">    x.innerHTML = <span class="string">&quot;Geolocation is not supported by this browser.&quot;</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="function"><span class="keyword">function</span> <span class="title">showPosition</span>(<span class="params">position</span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  x.innerHTML = <span class="string">&quot;Latitude: &quot;</span> + position.coords.latitude + </span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="string">&quot;&lt;br&gt;Longitude: &quot;</span> + position.coords.longitude;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br></pre></td></tr></table></figure><h2 id="Flask"><a href="#Flask" class="headerlink" title="Flask"></a>Flask</h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gyh349xfq2j30bn04kmxc.jpg" alt="Flask: web development, one drop at a time"></p><p>官方网址：<a href="https://flask.palletsprojects.com/en/2.0.x/">https://flask.palletsprojects.com/en/2.0.x/</a></p><ul><li>网页动态生成展示</li></ul><p>效果：根据 <code>？name=xxx</code> 来显示不同的内容</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gyh3a8dnw0j31e40g2t9k.jpg" alt="image-20220117233211110"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">==============================================================================</span></span><br><span class="line"><span class="string">Time : 2022/1/17 10:17 下午</span></span><br><span class="line"><span class="string">Author : Dufy</span></span><br><span class="line"><span class="string">Email : 813540660@qq.com</span></span><br><span class="line"><span class="string">File : flask_application.py</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">==============================================================================</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, render_template, request</span><br><span class="line"></span><br><span class="line">app = Flask(__name__, template_folder=<span class="string">&#x27;templates&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/&quot;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>():</span></span><br><span class="line">    name = request.args.get(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;world&quot;</span>)  <span class="comment"># 默认值 world</span></span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">&quot;index.html&quot;</span>, PARA=name)</span><br><span class="line">    <span class="comment"># return &quot;hello, world&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app.run(<span class="string">&#x27;0.0.0.0&#x27;</span>,port=<span class="number">8002</span>)</span><br></pre></td></tr></table></figure><h2 id="项目练习"><a href="#项目练习" class="headerlink" title="项目练习"></a>项目练习</h2><p><a href="https://www.cnblogs.com/xiaoer/p/11262456.html">自然语言处理NLP学习笔记三：使用Django做一个NLP的Web站点</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://validator.w3.org/">html合法性检查</a></li><li></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/zh</summary>
      
    
    
    
    <category term="网络" scheme="http://example.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="Django" scheme="http://example.com/tags/Django/"/>
    
    <category term="HTML" scheme="http://example.com/tags/HTML/"/>
    
    <category term="flask" scheme="http://example.com/tags/flask/"/>
    
  </entry>
  
  <entry>
    <title>⭐️TensorFlow 笔记</title>
    <link href="http://example.com/2021/07/20/%E3%80%90ML%E3%80%91TF%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2021/07/20/%E3%80%90ML%E3%80%91TF%E7%AC%94%E8%AE%B0/</id>
    <published>2021-07-19T16:00:00.000Z</published>
    <updated>2022-01-09T09:41:00.337Z</updated>
    
    <content type="html"><![CDATA[<p>TF源码：<a href="https://github.com/tensorflow/tensorflow">https://github.com/tensorflow/tensorflow</a></p><span id="more"></span><h2 id="TensorFlow-能做什么？"><a href="#TensorFlow-能做什么？" class="headerlink" title="TensorFlow 能做什么？"></a>TensorFlow 能做什么？</h2><p>TensorFlow 可以为以上的这些需求提供完整的解决方案。具体而言，TensorFlow 包含以下特性：</p><ul><li>训练流程</li></ul><p><strong>数据的处理</strong> ：使用 tf.data 和 TFRecord 可以高效地构建和预处理数据集，构建训练数据流。同时可以使用 TensorFlow Datasets 快速载入常用的公开数据集。</p><p><strong>模型的建立与调试</strong> ：使用即时执行模式和著名的神经网络高层 API 框架 Keras，结合可视化工具 TensorBoard，简易、快速地建立和调试模型。也可以通过 TensorFlow Hub 方便地载入已有的成熟模型。</p><p><strong>模型的训练</strong> ：支持在 CPU、GPU、TPU 上训练模型，支持单机和多机集群并行训练模型，充分利用海量数据和计算资源进行高效训练。</p><blockquote><p>不过远程调试对网络的稳定性要求高，如果需要长时间训练模型，建议登录远程机终端直接训练模型（Linux 下可以结合 <code>nohup</code> 命令 <a href="https://tf.wiki/zh_hans/basic/installation.html#nohup">1</a> ，让进程在后端运行，不受终端退出的影响）</p><p>—-<a href="https://tf.wiki/zh_hans/basic/installation.html#nohup">https://tf.wiki/zh_hans/basic/installation.html#nohup</a></p></blockquote><p><strong>模型的导出</strong> ：将模型打包导出为统一的 SavedModel 格式，方便迁移和部署。</p><ul><li>部署流程</li></ul><p><strong>服务器部署</strong> ：使用 TensorFlow Serving 在服务器上为训练完成的模型提供高性能、支持并发、高吞吐量的 API。</p><p><strong>移动端和嵌入式设备部署</strong> ：使用 TensorFlow Lite 将模型转换为体积小、高效率的轻量化版本，并在移动端、嵌入式端等功耗和计算能力受限的设备上运行，支持使用 GPU 代理进行硬件加速，还可以配合 Edge TPU 等外接硬件加速运算。</p><p><strong>网页端部署</strong> ：使用 TensorFlow.js，在网页端等支持 JavaScript 运行的环境上也可以运行模型，支持使用 WebGL 进行硬件加速。</p><h2 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h2><p>参考：</p><p><a href="https://github.com/yao62995/tensorflow">https://github.com/yao62995/tensorflow</a></p><p>[<a href="https://www.cnblogs.com/yao62995/p/5773578.html">图解tensorflow源码] [原创] Tensorflow 图解分析 （Session, Graph, Kernels, Devices）</a></p><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><p>Tensorflow底层最核心的概念是张量，计算图以及自动微分。</p><p>程序=算法+数据结构</p><p>Tensorflow程序 = 张量（数据结构）+计算图算法语言</p><h3 id="张量"><a href="#张量" class="headerlink" title="张量"></a>张量</h3><p>张量，即多维数组</p><p>从行为特性看，分为两种：</p><ul><li>常量constant</li></ul><p>张量的数据类型和numpy.array基本一一对应。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line">i = tf.constant(<span class="number">1</span>) <span class="comment"># tf.int32 类型常量</span></span><br><span class="line">l = tf.constant(<span class="number">1</span>,dtype = tf.int64) <span class="comment"># tf.int64 类型常量</span></span><br><span class="line">f = tf.constant(<span class="number">1.23</span>) <span class="comment">#tf.float32 类型常量</span></span><br><span class="line">d = tf.constant(<span class="number">3.14</span>,dtype = tf.double) <span class="comment"># tf.double 类型常量</span></span><br><span class="line">s = tf.constant(<span class="string">&quot;hello world&quot;</span>) <span class="comment"># tf.string类型常量</span></span><br><span class="line">b = tf.constant(<span class="literal">True</span>) <span class="comment">#tf.bool类型常量</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(tf.int64 == np.int64) </span><br><span class="line"><span class="built_in">print</span>(tf.<span class="built_in">bool</span> == np.<span class="built_in">bool</span>)</span><br><span class="line"><span class="built_in">print</span>(tf.double == np.float64)</span><br><span class="line"><span class="built_in">print</span>(tf.string == np.unicode) <span class="comment"># tf.string类型和np.unicode类型不等价</span></span><br><span class="line">------------</span><br><span class="line"><span class="literal">True</span> <span class="literal">True</span> <span class="literal">True</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>张量还有维度概念：</p><blockquote><p>0维：标量</p><p>1维：向量</p><p>2维：矩阵</p><p>3维：彩色图像有rgb三个通道</p><p>4维：视频的时间维</p></blockquote><p>有几层中括号，就是多少维的张量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">matrix = tf.constant([[1.0,2.0],[3.0,4.0]]) #矩阵, 2维张量</span><br><span class="line"></span><br><span class="line">print(tf.rank(matrix).numpy())</span><br><span class="line">print(np.ndim(matrix))</span><br><span class="line">2</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p>可以用<code>tf.cast</code>改变张量的数据类型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x= tf.constant(<span class="number">1.2</span>)</span><br><span class="line">x1 = tf.cast(x, dtype=tf.int32)</span><br><span class="line">x, x1</span><br></pre></td></tr></table></figure><p>(&lt;tf.Tensor: shape=(), dtype=float32, numpy=1.2&gt;,<br> &lt;tf.Tensor: shape=(), dtype=int32, numpy=1&gt;)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">u = tf.constant(<span class="string">u&quot;你好 世界&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(u.numpy())  <span class="comment"># 转化为numpy 张量</span></span><br><span class="line"><span class="built_in">print</span>(u.numpy().decode(<span class="string">&quot;utf-8&quot;</span>))</span><br></pre></td></tr></table></figure><p>b’\xe4\xbd\xa0\xe5\xa5\xbd \xe4\xb8\x96\xe7\x95\x8c’<br>你好 世界</p><ul><li>变量Variable</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 常量值不可以改变，常量的重新赋值相当于创造新的内存空间</span></span><br><span class="line">c = tf.constant([<span class="number">1.0</span>,<span class="number">2.0</span>])</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(c))</span><br><span class="line">c = c + tf.constant([<span class="number">1.0</span>,<span class="number">1.0</span>])</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(c))  <span class="comment"># id 变了</span></span><br></pre></td></tr></table></figure><p>tf.Tensor([1. 2.], shape=(2,), dtype=float32)<br>26874808288<br>tf.Tensor([2. 3.], shape=(2,), dtype=float32)<br>26777421616</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 变量的值可以改变，可以通过assign, assign_add等方法给变量重新赋值</span></span><br><span class="line">v = tf.Variable([<span class="number">1.0</span>,<span class="number">2.0</span>],name = <span class="string">&quot;v&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(v)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(v))</span><br><span class="line">v.assign_add([<span class="number">1.0</span>,<span class="number">1.0</span>])</span><br><span class="line"><span class="built_in">print</span>(v)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(v))</span><br></pre></td></tr></table></figure><p>&lt;tf.Variable ‘v:0’ shape=(2,) dtype=float32, numpy=array([1., 2.], dtype=float32)&gt;<br>26833443728<br>&lt;tf.Variable ‘v:0’ shape=(2,) dtype=float32, numpy=array([2., 3.], dtype=float32)&gt;<br>26833443728</p><h3 id="计算图"><a href="#计算图" class="headerlink" title="计算图"></a>计算图</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gtlag55skij613g0liwg902.jpg" alt="image-20210818220021713"></p><p>有三种计算图的构建方式：静态计算图，动态计算图，以及Autograph.</p><ul><li>静态计算图</li></ul><p>在TensorFlow1.0时代，采用的是静态计算图，需要先使用TensorFlow的各种算子创建计算图，然后再开启一个会话Session，显式执行计算图。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow.compat.v1 <span class="keyword">as</span> tf</span><br><span class="line">tf.disable_eager_execution()  <span class="comment">#禁用即时执行模式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#使用静态计算图分两步，第一步定义计算图，第二步在会话中执行计算图。</span></span><br><span class="line"><span class="comment">#定义计算图</span></span><br><span class="line">g = tf.Graph()</span><br><span class="line"><span class="keyword">with</span> g.as_default():</span><br><span class="line">    <span class="comment">#placeholder为占位符，执行会话时候指定填充对象</span></span><br><span class="line">    x = tf.placeholder(name=<span class="string">&#x27;x&#x27;</span>, shape=[], dtype=tf.string)  </span><br><span class="line">    y = tf.placeholder(name=<span class="string">&#x27;y&#x27;</span>, shape=[], dtype=tf.string)</span><br><span class="line">    z = tf.string_join([x,y],name = <span class="string">&#x27;join&#x27;</span>,separator=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#执行计算图</span></span><br><span class="line"><span class="comment"># fetches的结果非常像一个函数的返回值，而feed_dict中的占位符相当于函数的参数序列。</span></span><br><span class="line"><span class="keyword">with</span> tf.Session(graph = g) <span class="keyword">as</span> sess:</span><br><span class="line">    <span class="built_in">print</span>(sess.run(fetches = z,feed_dict = &#123;x:<span class="string">&quot;hello&quot;</span>,y:<span class="string">&quot;world&quot;</span>&#125;))</span><br><span class="line">    </span><br><span class="line">writer=tf.summary.FileWriter(<span class="string">&#x27;./graph_record&#x27;</span>,sess.graph)  <span class="comment"># tensorboard --logdir=graph_record 显示</span></span><br></pre></td></tr></table></figure><p>b’hello world’</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gtlamdf2bdj611k0dy3yz02.jpg" alt="image-20210818220621266"></p><ul><li>动态计算图</li></ul><p>而在TensorFlow2.0时代，采用的是动态计算图，即每使用一个算子后，该算子会被动态加入到隐含的默认计算图中立即执行得到结果，而无需开启Session。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import tensorflow as tf</span><br><span class="line"># 动态计算图在每个算子处都进行构建，构建后立即执行</span><br><span class="line"></span><br><span class="line">x = tf.constant(&quot;hello&quot;)</span><br><span class="line">y = tf.constant(&quot;world&quot;)</span><br><span class="line">z = tf.strings.join([x,y],separator=&quot; &quot;)</span><br><span class="line"></span><br><span class="line">tf.print(z)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import tensorflow as tf</span><br><span class="line"># 可以将动态计算图代码的输入和输出关系封装成函数</span><br><span class="line"></span><br><span class="line">def strjoin(x,y):</span><br><span class="line">    z =  tf.strings.join([x,y],separator = &quot; &quot;)</span><br><span class="line">    tf.print(z)</span><br><span class="line">    return z</span><br><span class="line"></span><br><span class="line">result = strjoin(tf.constant(&quot;hello&quot;),tf.constant(&quot;world&quot;))</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><p>hello world<br>tf.Tensor(b’hello world’, shape=(), dtype=string)</p><p>如果需要在TensorFlow2.0中使用静态图，可以使用@tf.function装饰器将普通Python函数转换成对应的TensorFlow计算图构建代码。运行该函数就相当于在TensorFlow1.0中用Session执行代码。使用tf.function构建静态图的方式叫做 Autograph.</p><p>TensorFlow 2中执行或开发TensorFlow1.x代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow.compat.v1 <span class="keyword">as</span> tf</span><br><span class="line">tf.disable_eager_execution()  <span class="comment">#禁用即时执行模式</span></span><br><span class="line">node1 = tf.constant(<span class="number">3.0</span>)</span><br><span class="line">node2 = tf.constant(<span class="number">4.0</span>)</span><br><span class="line">node3 = tf.add(node1,node2)</span><br><span class="line"><span class="built_in">print</span>(node3)</span><br><span class="line"></span><br><span class="line"><span class="comment"># &quot;由于是图执行模式，这时仅仅是建立了计算图，但没有执行</span></span><br><span class="line"><span class="comment"># &quot;定义好计算图后，需要建立一个Session，使用会话对象来实现执行图的执行&quot;</span></span><br><span class="line">sess = tf.Session()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;node1:&quot;</span>,sess.run(node1))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;node2:&quot;</span>,sess.run(node2))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;node3:&quot;</span>,sess.run(node3))</span><br><span class="line">sess.close()</span><br></pre></td></tr></table></figure><p>Tensor(“Add_3:0”, shape=(), dtype=float32)<br>node1: 3.0<br>node2: 4.0<br>node3: 7.0</p><ul><li>Autograph</li></ul><p>动态计算图运行效率相对较低。</p><p>可以用@tf.function装饰器将普通Python函数转换成和TensorFlow1.0对应的静态计算图构建代码。</p><p>在TensorFlow2.0中，如果采用Autograph的方式使用计算图，第一步定义计算图变成了定义函数，第二步执行计算图变成了调用函数。</p><p>不需要使用会话了，一些都像原始的Python语法一样自然。</p><blockquote><p>实践中，我们一般会先用动态计算图调试代码，然后在需要提高性能的的地方利用@tf.function切换成Autograph获得更高的效率。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import tensorflow as tf</span><br><span class="line"></span><br><span class="line"># 使用autograph构建静态图</span><br><span class="line"></span><br><span class="line">@tf.function</span><br><span class="line">def strjoin(x,y):</span><br><span class="line">    z =  tf.strings.join([x,y],separator = &quot; &quot;)</span><br><span class="line">    tf.print(z)</span><br><span class="line">    return z</span><br><span class="line"></span><br><span class="line">result = strjoin(tf.constant(&quot;hello&quot;),tf.constant(&quot;world&quot;))</span><br><span class="line"></span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><h3 id="自动微分"><a href="#自动微分" class="headerlink" title="自动微分"></a>自动微分</h3><p>默认情况下，调用 GradientTape.gradient() 方法时， GradientTape 占用的资源会立即得到释放。通过创建一个持久的梯度带，可以计算同个函数的多个导数。这样在磁带对象被垃圾回收时，就可以多次调用 ‘gradient()’ 方法。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x = tf.constant(<span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">with</span> tf.GradientTape(persistent=<span class="literal">True</span>) <span class="keyword">as</span> t:</span><br><span class="line">  t.watch(x)  <span class="comment"># 对常量张量也可以求导，需要增加watch</span></span><br><span class="line">  y = x * x</span><br><span class="line">  z = y * y</span><br><span class="line">dz_dx = t.gradient(z, x)  <span class="comment"># 108.0 (4*x^3 at x = 3)</span></span><br><span class="line">dy_dx = t.gradient(y, x)  <span class="comment"># 6.0</span></span><br><span class="line"><span class="keyword">del</span> t  <span class="comment"># Drop the reference to the tape</span></span><br></pre></td></tr></table></figure><blockquote><p><a href="https://www.tensorflow.org/guide/autodiff?hl=zh-cn">https://www.tensorflow.org/guide/autodiff?hl=zh-cn</a></p></blockquote><p>二阶导数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import tensorflow as tf</span><br><span class="line">import numpy as np </span><br><span class="line"></span><br><span class="line"># f(x) = a*x**2 + b*x + c的导数</span><br><span class="line"></span><br><span class="line">x = tf.Variable(0.0,name = &quot;x&quot;,dtype = tf.float32)</span><br><span class="line">a = tf.constant(1.0)</span><br><span class="line">b = tf.constant(-2.0)</span><br><span class="line">c = tf.constant(1.0)</span><br><span class="line"># 可以求二阶导数</span><br><span class="line">with tf.GradientTape() as tape2:</span><br><span class="line">    with tf.GradientTape() as tape1:   </span><br><span class="line">        y = a*tf.pow(x,2) + b*x + c</span><br><span class="line">    dy_dx = tape1.gradient(y,x)   </span><br><span class="line">dy2_dx2 = tape2.gradient(dy_dx,x)</span><br><span class="line"></span><br><span class="line">print(dy2_dx2)</span><br></pre></td></tr></table></figure><p>tf.Tensor(2.0, shape=(), dtype=float32)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 可以在autograph中使用</span><br><span class="line"></span><br><span class="line">@tf.function</span><br><span class="line">def f(x):   </span><br><span class="line">    a = tf.constant(1.0)</span><br><span class="line">    b = tf.constant(-2.0)</span><br><span class="line">    c = tf.constant(1.0)</span><br><span class="line"></span><br><span class="line">    # 自变量转换成tf.float32</span><br><span class="line">    x = tf.cast(x,tf.float32)</span><br><span class="line">    with tf.GradientTape() as tape:</span><br><span class="line">        tape.watch(x)</span><br><span class="line">        y = a*tf.pow(x,2)+b*x+c</span><br><span class="line">    dy_dx = tape.gradient(y,x) </span><br><span class="line"></span><br><span class="line">    return((dy_dx,y))</span><br><span class="line"></span><br><span class="line">tf.print(f(tf.constant(0.0)))</span><br><span class="line">tf.print(f(tf.constant(1.0)))</span><br><span class="line">(-2, 1)</span><br><span class="line">(0, 0)</span><br></pre></td></tr></table></figure><h2 id="TF-层次结构"><a href="#TF-层次结构" class="headerlink" title="TF 层次结构"></a>TF 层次结构</h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gtmf3o2l32j617w0oodjc02.jpg" alt="image-20210819212650613"></p><h2 id="一些方法"><a href="#一些方法" class="headerlink" title="一些方法"></a>一些方法</h2><h3 id="dataset"><a href="#dataset" class="headerlink" title="dataset"></a>dataset</h3><p>repeat,batch, shuffle</p><p><a href="https://www.youtube.com/watch?v=c7G5W4Wv72Q">https://www.youtube.com/watch?v=c7G5W4Wv72Q</a></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gt1htsipgij31d00okah5.jpg" alt="image-20210801190435983"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gt1hykynf1j316o0m0n27.jpg" alt="image-20210801190915257"></p><h2 id="keras"><a href="#keras" class="headerlink" title="keras"></a>keras</h2><h3 id="构建模型"><a href="#构建模型" class="headerlink" title="构建模型"></a>构建模型</h3><p>使用Keras接口有以下3种方式构建模型：</p><ul><li>使用Sequential按层顺序构建模型（最简单）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">model = models.Sequential()</span><br><span class="line">model.add(layers.Dense(20,activation = &#x27;relu&#x27;,input_shape=(15,)))</span><br><span class="line">model.add(layers.Dense(10,activation = &#x27;relu&#x27; ))</span><br><span class="line">model.add(layers.Dense(1,activation = &#x27;sigmoid&#x27; ))</span><br></pre></td></tr></table></figure><ul><li>使用函数式API构建任意结构模型，</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">inputs = layers.Input(shape=(32,32,3))</span><br><span class="line">x = layers.Conv2D(32,kernel_size=(3,3))(inputs)</span><br><span class="line">x = layers.MaxPool2D()(x)  # 默认pool_size=(2, 2),</span><br><span class="line">x = layers.Conv2D(64,kernel_size=(5,5))(x)</span><br><span class="line">x = layers.MaxPool2D()(x)</span><br><span class="line">x = layers.Dropout(rate=0.1)(x)</span><br><span class="line">x = layers.Flatten()(x)</span><br><span class="line">x = layers.Dense(32,activation=&#x27;relu&#x27;)(x)</span><br><span class="line">outputs = layers.Dense(1,activation = &#x27;sigmoid&#x27;)(x)</span><br><span class="line"></span><br><span class="line">model = models.Model(inputs = inputs,outputs = outputs)</span><br></pre></td></tr></table></figure><ul><li>继承Model基类构建自定义模型。</li></ul><h3 id="模型训练"><a href="#模型训练" class="headerlink" title="模型训练"></a>模型训练</h3><p>训练模型通常有3种方法，内置fit方法，内置train_on_batch方法，以及自定义训练循环。</p><ul><li>fit 方法</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 二分类问题选择二元交叉熵损失函数</span></span><br><span class="line">model.<span class="built_in">compile</span>(optimizer=<span class="string">&#x27;adam&#x27;</span>,</span><br><span class="line">            loss=<span class="string">&#x27;binary_crossentropy&#x27;</span>,</span><br><span class="line">            metrics=[<span class="string">&#x27;AUC&#x27;</span>])</span><br><span class="line"></span><br><span class="line">history = model.fit(x_train,y_train,</span><br><span class="line">                    batch_size= <span class="number">64</span>,</span><br><span class="line">                    epochs= <span class="number">30</span>,</span><br><span class="line">                    validation_split=<span class="number">0.2</span> <span class="comment">#分割一部分训练数据用于验证</span></span><br><span class="line">                   )</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://tf.wiki/zh_hans/">https://tf.wiki/zh_hans/</a></li></ol><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsnqwmvj2ij31xs0qigsp.jpg" alt="image-20210720214050387"></p><ol start="2"><li><a href="https://github.com/dragen1860/Deep-Learning-with-TensorFlow-book">https://github.com/dragen1860/Deep-Learning-with-TensorFlow-book</a></li></ol><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gt1n4hnwo3j31x10u011i.jpg" alt="image-20210801220754292"></p><ol start="3"><li>官方文档</li></ol><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gt39xoflqcj31qo0u0458.jpg" alt="image-20210803080243039"></p><ol start="4"><li>30天吃掉那只Tensorflow2</li></ol><p><a href="https://jackiexiao.github.io/eat_tensorflow2_in_30_days/">https://jackiexiao.github.io/eat_tensorflow2_in_30_days/</a></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gtk7a5esd0j61te0tqgsl02.jpg" alt="image-20210817232515561"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;TF源码：&lt;a href=&quot;https://github.com/tensorflow/tensorflow&quot;&gt;https://github.com/tensorflow/tensorflow&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="机器学习" scheme="http://example.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="TensorFlow" scheme="http://example.com/tags/TensorFlow/"/>
    
  </entry>
  
  <entry>
    <title>⭐️机器学习中的数学</title>
    <link href="http://example.com/2021/06/29/%E3%80%90ML%E3%80%91%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%A6/"/>
    <id>http://example.com/2021/06/29/%E3%80%90ML%E3%80%91%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%A6/</id>
    <published>2021-06-28T16:00:00.000Z</published>
    <updated>2022-01-15T15:41:05.543Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="概率、统计区别"><a href="#概率、统计区别" class="headerlink" title="概率、统计区别"></a>概率、统计区别</h2><p><a href="https://www.sohu.com/a/260383068_464088">概率论与统计学的关系是什么？ </a></p><p>概率论就好比是给你一个模型，你可以知道这个模型会产生什么样的数据；</p><p>而统计则是给你一些数据，你来判断是由什么样的模型产生的。</p><p>如下图：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gs2a76yjkxj30b408cq3b.jpg" alt="概率统计区别"></p><p>Lary Wasserman 在 《All of Statistics》 的序言里有说过概率论和统计推断的区别：</p><blockquote><p>1）The basic problem of statistical inference is the inverse of probability:Given the outcomes, what can we say about the process that generated the data?</p><p>2）The basic problem that we study in probability is: Given a data generating process, what are the properities of the outcomes?</p></blockquote><h2 id="概率"><a href="#概率" class="headerlink" title="概率"></a>概率</h2><h3 id="蒲丰投针"><a href="#蒲丰投针" class="headerlink" title="蒲丰投针"></a>蒲丰投针</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsc2ajvg1pj31os0u01kz.jpg"></p><p>模拟：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">针长a, 线间距d, a&lt;d</span></span><br><span class="line"><span class="string">针中点M 到最近的线距离为：x∈[0，d/2]</span></span><br><span class="line"><span class="string">针与线的夹角为 alpha ∈[0,pi]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">相交条件：x&lt;a*sin(alpha)/2</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">throw_needle</span>(<span class="params">n, a, d=<span class="number">1</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;布丰投针试验</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param n: 投针试验次数</span></span><br><span class="line"><span class="string">    :param a: 针长度</span></span><br><span class="line"><span class="string">    :param d: 1</span></span><br><span class="line"><span class="string">    :return: pi 的估计值</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    alpha = np.random.uniform(<span class="number">0</span>, np.pi, n)</span><br><span class="line">    x = np.random.uniform(<span class="number">0</span>, d/<span class="number">2</span>, n)</span><br><span class="line">    m = np.<span class="built_in">sum</span>(x &lt; a*np.sin(alpha)/<span class="number">2</span>)  <span class="comment"># 相交，【不进行循环，直接利用numpy的性质，计算速度会更快】</span></span><br><span class="line">    pi = <span class="number">2</span>*a*n/d/m</span><br><span class="line">    <span class="keyword">return</span> pi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">prob = throw_needle(<span class="number">10</span>**<span class="number">8</span>, <span class="number">0.8</span>)</span><br><span class="line"><span class="built_in">print</span>(prob)</span><br><span class="line"><span class="number">3.141567658362057</span></span><br></pre></td></tr></table></figure><h3 id="大数定理"><a href="#大数定理" class="headerlink" title="大数定理"></a>大数定理</h3><p>定义参考：陈希孺《概率论与数理统计》p142</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1grzjsoax1vj30ys0nmq8q.jpg"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1grzjokxpxdj30xw0u0gzz.jpg"></p><ul><li><a href="https://github.com/flitdu/consult/blob/main/jupyter/%E5%A4%A7%E6%95%B0%E5%AE%9A%E7%90%86%E4%B8%BE%E4%BE%8B.ipynb">代码展示</a></li></ul><p>以筛子为例，假设有1000万的筛子点数随机样本，然后，通过随机抽样，估计总体的均值情况：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1grzk9qi6mzj312k0k2dhc.jpg"></p><h3 id="中心极限定理"><a href="#中心极限定理" class="headerlink" title="中心极限定理"></a>中心极限定理</h3><blockquote><p>在概率论上，习惯于把和的分布收敛于正态分布的那一类定理都叫’中心极限定理‘</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1grzjy1totij30u00vl7f6.jpg"></p><ul><li>应用</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1grzjyquvjij311a0fwdlp.jpg"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1grzjz3wykdj31000lmtf3.jpg"></p><h2 id="统计"><a href="#统计" class="headerlink" title="统计"></a>统计</h2><p>视频参考：【1】</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gs14i6fqkuj317a0u07wi.jpg"></p><p>大量的独立事件相加，就成为了一种社会现象</p><h3 id="方差"><a href="#方差" class="headerlink" title="方差"></a>方差</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1grzi8hg5bwj31gk0ogafa.jpg"></p><h3 id="概率分布"><a href="#概率分布" class="headerlink" title="概率分布"></a>概率分布</h3><p>概率分布描述的对象是数据，数据分为两种：</p><p>1）连续型数据</p><p>2）离散型数据</p><p>分布，指的是数据在统计图中的形状</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gs14tw5pvlj30zm0ky7vo.jpg"></p><h3 id="分布类型"><a href="#分布类型" class="headerlink" title="分布类型"></a>分布类型</h3><table><thead><tr><th>离散概率分布</th><th>连续概率分布</th></tr></thead><tbody><tr><td>伯努利分布，又叫<strong>0-1分布</strong></td><td>正态分布</td></tr><tr><td>二项分布</td><td><a href="https://baike.baidu.com/item/%CE%B2%E5%88%86%E5%B8%83/22787190">β分布</a></td></tr><tr><td>几何分布</td><td>指数分布</td></tr><tr><td>泊松分布</td><td>Gamma分布</td></tr></tbody></table><ul><li>0-1分布</li></ul><p>分布律为：$$p(X=k)=p^k(1-p)^{1-k}$$</p><p>其中<code>k=0,1,0&lt;p&lt;1</code></p><p>使用场景：抛硬币、新生儿的性别登记、检查产品质量是否合格等</p><ul><li>泊松分布</li></ul><p>分布律为：$$p(X=k)=\frac{\lambda ^{k}e^{-\lambda}}{k!}$$</p><p>其中， <code>λ为均值，k=0,1,2.....</code></p><p>用来描述不寻常事情发生的概率，如一周内赢彩票人数，某地区一天内邮递遗失的信件数等</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gs40i7hk0dj30v60kejx9.jpg"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># p(X=k)=\frac&#123;\lambda ^&#123;k&#125;e^&#123;-\lambda&#125;&#125;&#123;k!&#125;</span></span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt </span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line">poisson = <span class="keyword">lambda</span> lam,k:(lam**k*math.exp(-lam))/math.factorial(k)</span><br><span class="line">poisson(<span class="number">0.1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">x= [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">21</span>)]</span><br><span class="line">y1= [poisson(<span class="number">2.5</span>,i) <span class="keyword">for</span> i <span class="keyword">in</span> x]</span><br><span class="line">y2= [poisson(<span class="number">5</span>,i) <span class="keyword">for</span> i <span class="keyword">in</span> x]</span><br><span class="line">y3= [poisson(<span class="number">10</span>,i) <span class="keyword">for</span> i <span class="keyword">in</span> x]</span><br><span class="line"></span><br><span class="line">plt.plot(x,y1,<span class="string">&#x27;-o&#x27;</span>, label=<span class="string">&#x27;lambda=2.5&#x27;</span>)</span><br><span class="line">plt.plot(x,y2,<span class="string">&#x27;-o&#x27;</span>, label=<span class="string">&#x27;lambda=5&#x27;</span>)</span><br><span class="line">plt.plot(x,y3,<span class="string">&#x27;-o&#x27;</span>, label=<span class="string">&#x27;lambda=10&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>如下图，某个公交站每小时平均有三辆车，可以用泊松分布得到一小时内等到不同数量车的概率</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gs1su553fnj30y40m0x2w.jpg"></p><ul><li>正态分布</li></ul><p><a href="https://zh.wikipedia.org/wiki/%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83">正态分布</a>下，和平均值偏离一个标准差以内的数据会占68.27%，偏离二个标准差以内的数据会到95.45%，偏离三个标准差以内的数据会到99.73%。</p><p>这也就是<strong>68–95–99.7法则</strong>（68–95–99.7 rule）</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/a9/Empirical_Rule.PNG/450px-Empirical_Rule.PNG"></p><h2 id="贝叶斯决策"><a href="#贝叶斯决策" class="headerlink" title="贝叶斯决策"></a>贝叶斯决策</h2><p>（1）已知类条件概率密度参数表达式和先验概率</p><p>（2）利用贝叶斯公式转成后验概率</p><p>（3）根据后验概率大小进行决策分类</p><h2 id="极大似然"><a href="#极大似然" class="headerlink" title="极大似然"></a>极大似然</h2><p><a href="https://zhuanlan.zhihu.com/p/26614750">一文搞懂极大似然估计</a></p><blockquote><p>极大似然估计用于解决参数估计，<strong>所有的采样都是独立同分布的</strong>。那么既然事情已经发生了，为什么不让这个出现的结果的可能性最大呢？<strong>这也就是最大似然估计的核心。</strong></p></blockquote><h2 id="马尔科夫链"><a href="#马尔科夫链" class="headerlink" title="马尔科夫链"></a>马尔科夫链</h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsc3fllx9lj31e2080q4s.jpg"></p><p>马尔科夫链是满足马尔科夫性质的随机过程。</p><p>马尔科夫链<code>X1,X2,...</code>描述了一个状态序列，其中每个状态值取决于前一个状态。<code>X_t</code>为随机变量，称为时刻t 的状态，其取值范围称为状态空间。</p><p>马尔科夫链的数学定义为：</p><p>$$P(X_{t+1}|X_1,X_2,…X_t-1,X_t) = P(X_{t+1}|X_t)$$</p><ul><li>举例</li></ul><p>社会学家把人按照经济状况分成三类：下层、中层、上层。用状态 <code>1,2,3</code> 代表着三个阶层。社会学家发现：决定一个人的收入阶层的最重要因素就是其父母的收入阶层。</p><p>1）如果一个人的收入属于下层，则他的孩子属于下层的概率是 0.65，属于中层的概率是 0.28，属于上层的概率是 0.07 。</p><p>2）如果一个人的收入属于中层，则他的孩子属于下层的概率是 0.15，属于中层的概率是 0.67，属于上层的概率是 0.18 。</p><p>3）如果一个人的收入属于上层，则他的孩子属于下层的概率是 0.12，属于中层的概率是 0.36，属于上层的概率是 0.52 。</p><p>从父代到子代，收入阶层的变化的转移概率如下：</p><table><thead><tr><th align="center"></th><th align="center">子代阶层1</th><th align="center">子代阶层2</th><th align="center">子代阶层3</th></tr></thead><tbody><tr><td align="center">父代阶层1</td><td align="center">0.65</td><td align="center">0.28</td><td align="center">0.07</td></tr><tr><td align="center">父代阶层2</td><td align="center">0.15</td><td align="center">0.67</td><td align="center">0.18</td></tr><tr><td align="center">父代阶层3</td><td align="center">0.12</td><td align="center">0.36</td><td align="center">0.52</td></tr></tbody></table><p>假设初始概率分布为 ，给出前 14 代人的分布状况：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">c1: 下层</span></span><br><span class="line"><span class="string">c2：中层</span></span><br><span class="line"><span class="string">c3: 上层</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> numpy.matlib</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]  <span class="comment"># 用来正常显示中文标签</span></span><br><span class="line"></span><br><span class="line">a = np.array([<span class="number">0.72</span>,<span class="number">0.19</span>,<span class="number">0.09</span>])</span><br><span class="line">b = np.array([<span class="number">0.65</span>,<span class="number">0.15</span>,<span class="number">0.12</span>])</span><br><span class="line"><span class="built_in">print</span>(np.dot(a,b))</span><br><span class="line">c1 = []</span><br><span class="line">c2= []</span><br><span class="line">c3= []</span><br><span class="line"></span><br><span class="line">pi = np.array([<span class="number">0.09</span>,<span class="number">0.19</span>,<span class="number">0.72</span>])  <span class="comment"># 初始概率</span></span><br><span class="line">A= np.array([[<span class="number">0.65</span>,<span class="number">0.28</span>,<span class="number">0.07</span>],[<span class="number">0.15</span>,<span class="number">0.67</span>,<span class="number">0.18</span>],[<span class="number">0.12</span>,<span class="number">0.36</span>,<span class="number">0.52</span>]])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;第<span class="subst">&#123;<span class="number">0</span>&#125;</span>代：<span class="subst">&#123;pi&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">15</span>):</span><br><span class="line">    c1.append(pi[<span class="number">0</span>])</span><br><span class="line">    c2.append(pi[<span class="number">1</span>])</span><br><span class="line">    c3.append(pi[<span class="number">2</span>])</span><br><span class="line">    pi = np.dot(pi, A)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;第<span class="subst">&#123;i&#125;</span>代：<span class="subst">&#123;pi&#125;</span>&#x27;</span>)</span><br><span class="line">c1,c2,c3</span><br><span class="line">plt.plot(c1,marker=<span class="string">&#x27;o&#x27;</span>,label=<span class="string">&#x27;c1-low&#x27;</span>)</span><br><span class="line">plt.plot(c2,marker=<span class="string">&#x27;o&#x27;</span>, label=<span class="string">&#x27;c2-mid&#x27;</span>)</span><br><span class="line">plt.plot(c3,marker=<span class="string">&#x27;o&#x27;</span>,label=<span class="string">&#x27;c3-upper&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.grid()</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">0.5073</span><br><span class="line">第0代：[0.09 0.19 0.72]</span><br><span class="line">第1代：[0.1734 0.4117 0.4149]</span><br><span class="line">第2代：[0.224253 0.473755 0.301992]</span><br><span class="line">第3代：[0.25306674 0.48892381 0.25800945]</span><br><span class="line">第4代：[0.26879309 0.49132104 0.23988587]</span><br><span class="line">第5代：[0.27719997 0.49080608 0.23199396]</span><br><span class="line">第6代：[0.28164016 0.48997389 0.22838595]</span><br><span class="line">第7代：[0.2839685  0.48936069 0.2266708 ]</span><br><span class="line">第8代：[0.28518413 0.48898433 0.22583154]</span><br><span class="line">第9代：[0.28581712 0.48877041 0.22541247]</span><br><span class="line">第10代：[0.28614618 0.48865346 0.22520036]</span><br><span class="line">第11代：[0.28631708 0.48859088 0.22509204]</span><br><span class="line">第12代：[0.28640578 0.48855781 0.22503641]</span><br><span class="line">第13代：[0.2864518  0.48854046 0.22500775]</span><br><span class="line">第14代：[0.28647567 0.4885314  0.22499294]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gscw4xrkjcj310y0g20vj.jpg"></p><p>从图上看出，初始概率<code>[0.09,0.19,0.72]</code> ，经过三代后，变为<code>[0.25306674 0.48892381 0.25800945]</code>，也就是将变为中层。这就是经常说的 ‘富不过三代’ ？</p><p>如果，每一代都对教育很重视，在下一代培养上进行了投入，提高进入上层的几率，那么曲线图会发生变化如下：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsczkoxr2dj314c0gmtcx.jpg"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">c1: 下层</span></span><br><span class="line"><span class="string">c2：中层</span></span><br><span class="line"><span class="string">c3: 上层</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> numpy.matlib</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]  <span class="comment"># 用来正常显示中文标签</span></span><br><span class="line"></span><br><span class="line">a = np.array([<span class="number">0.72</span>,<span class="number">0.19</span>,<span class="number">0.09</span>])</span><br><span class="line">b = np.array([<span class="number">0.65</span>,<span class="number">0.15</span>,<span class="number">0.12</span>])</span><br><span class="line"><span class="built_in">print</span>(np.dot(a,b))</span><br><span class="line">c1 = []</span><br><span class="line">c2= []</span><br><span class="line">c3= []</span><br><span class="line">c1_ = []</span><br><span class="line">c2_= []</span><br><span class="line">c3_= []</span><br><span class="line">pi = np.array([<span class="number">0.09</span>,<span class="number">0.19</span>,<span class="number">0.72</span>])  <span class="comment"># 初始概率</span></span><br><span class="line">pi_ = pi</span><br><span class="line"></span><br><span class="line">A= np.array([[<span class="number">0.65</span>,<span class="number">0.28</span>,<span class="number">0.07</span>],[<span class="number">0.15</span>,<span class="number">0.67</span>,<span class="number">0.18</span>],[<span class="number">0.12</span>,<span class="number">0.36</span>,<span class="number">0.52</span>]])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;第<span class="subst">&#123;<span class="number">0</span>&#125;</span>代：<span class="subst">&#123;pi&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">15</span>):</span><br><span class="line">    c1.append(pi[<span class="number">0</span>])</span><br><span class="line">    c2.append(pi[<span class="number">1</span>])</span><br><span class="line">    c3.append(pi[<span class="number">2</span>])</span><br><span class="line">    pi = np.dot(pi, A)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;第<span class="subst">&#123;i&#125;</span>代：<span class="subst">&#123;pi&#125;</span>&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment">#     添加受教育，提高进入上层的概率</span></span><br><span class="line">    c1_.append(pi_[<span class="number">0</span>])</span><br><span class="line">    c2_.append(pi_[<span class="number">1</span>])</span><br><span class="line">    c3_.append(pi_[<span class="number">2</span>])</span><br><span class="line">    pi_ = pi_+np.array([<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.3</span>])</span><br><span class="line">    pi_ = pi_/<span class="built_in">sum</span>(pi_)</span><br><span class="line">    pi_ = np.dot(pi_, A)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;受教育，第<span class="subst">&#123;i&#125;</span>代：<span class="subst">&#123;pi_&#125;</span>&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">c1,c2,c3</span><br><span class="line">plt.plot(c1,marker=<span class="string">&#x27;o&#x27;</span>,label=<span class="string">&#x27;c1-low&#x27;</span>)</span><br><span class="line">plt.plot(c2,marker=<span class="string">&#x27;o&#x27;</span>, label=<span class="string">&#x27;c2-mid&#x27;</span>)</span><br><span class="line">plt.plot(c3,marker=<span class="string">&#x27;o&#x27;</span>,label=<span class="string">&#x27;c3-upper&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.plot(c1_,marker=<span class="string">&#x27;*&#x27;</span>,linestyle=<span class="string">&quot;-.&quot;</span>, label=<span class="string">&#x27;edu-low&#x27;</span>,color = <span class="string">&#x27;blue&#x27;</span>)</span><br><span class="line">plt.plot(c2_,marker=<span class="string">&#x27;*&#x27;</span>, linestyle=<span class="string">&quot;-.&quot;</span>, label=<span class="string">&#x27;edu-mid&#x27;</span>,color = <span class="string">&#x27;orange&#x27;</span>)</span><br><span class="line">plt.plot(c3_,marker=<span class="string">&#x27;*&#x27;</span>,linestyle=<span class="string">&quot;-.&quot;</span>,label=<span class="string">&#x27;edu-upper&#x27;</span>,color = <span class="string">&#x27;green&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.grid()</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>值得注意的是，纯理想的情况下，最终的收敛行为由概率转移矩阵 A 决定。也就是大环境</p><p>如果社会大环境上升渠道关闭（比如封建社会末期那样），那么下层的人士就很难在进入上层了。</p><p>比如，修改A为<code>A= np.array([[0.95,0.03,0.02],[0.15,0.67,0.18],[0.12,0.36,0.52]])</code>：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsczpo3592j30x00gggpj.jpg"></p><p>当然，这只是一个简单的模拟。真实的社会情况，远比这个要复杂。</p><h2 id="熵"><a href="#熵" class="headerlink" title="熵"></a>熵</h2><p><strong>此处还需要整理~~~~</strong></p><p><u><em>数据</em></u>：承载了信息的东西</p><p>数据与否，有相当因素取决于解读者的主观视角。这也是面对同样一件普通事物，专家与普通人为何表现不一样？</p><p><em>信息</em>：是用来消除随机不确定的东西</p><p>描述一个事件所含的信息量计算：<code>I(x)=-log(P(x))</code></p><p>比如，我说了两句话：</p><blockquote><p>我今年22岁</p><p>我明年23岁</p></blockquote><p>第一句话，如果是为了向不了解我的人介绍我的年龄而可以算作信息</p><p>第二句则不是信息</p><p>关于第一句，说之前对于不知道的人，由于不确定会有一个概率假设，假设其对于年龄的估计为18-27,每个估计所含的信息量为lg(10)，那么第一句话说完后（<strong>假设说的是真话</strong>），那么每个估计的概率分布变为红色01，所以第一句话的信息量为：lg(10)=3.3bit</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1guqxuldhqnj61h20cqwhh02.jpg" alt="image-20210923223825669"></p><p>同样，对于第二句，先验概率分布为：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1guq9uk8zv7j61c80a2zmt02.jpg" alt="image-20210923084803897"></p><p>第二句话，包含消息自然为0</p><blockquote><p><strong>但是，假如我们是依据假消息来消除不确定性，那么，不仅不利于判断形势，由此造成的不确定性将会更多，也就是俗话说的‘落入圈套’</strong></p></blockquote><p>再比如，如英语有26个字母，假如每个字母在文章中出现次数平均的话，每个字母的讯息量为：-lg2(1/26)=4.7 bit</p><p>而汉字常用的有2500个，假如每个<a href="https://zh.wikipedia.org/wiki/%E6%B1%89%E5%AD%97">汉字</a>在文章中出现次数平均的话，每个汉字的信息量为：11.3 bit</p><p>正因为汉字的信息量大，所以表达同样的意思，汉字要少的多</p><ul><li>熵H(X)：</li></ul><p>信息论中的<a href="https://zh.wikipedia.org/wiki/%E7%86%B5_(%E4%BF%A1%E6%81%AF%E8%AE%BA)">熵</a>，是信息的杂乱程度的量化描述</p><p>熵是整个系统的平均消息量，即：</p><p>$$H(x) = \sum_{i}P(x_i)I(x_i)= -\sum_{i}P(x_i)\log(P(x_i))$$</p><ul><li>交叉熵</li></ul><p><a href="https://www.cnblogs.com/wangguchangqing/p/12068084.html">一文搞懂交叉熵损失</a><br>$$<br>H(p,q) = -\sum_x^{} p(x)log q(x)<br>$$<br>其中p为真实分布，q为非真实分布。交叉熵越低，意味着q越接近p。所以在机器学习分类算法中，我们总是最小化交叉熵，交叉熵越低，间接证明算法推算出的非真实分布q越接近真实分布p。</p><ul><li>相对熵D_KL</li></ul><p>表示同一个随机变量的两个不同分布间的距离（1951年提出）</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gs6gqm25rnj310u04owf5.jpg"></p><p>相对熵具有以下性质：</p><p>1）如果p(x),q(x)分布相同，则其相对熵=0</p><p>2）$$D_{KL}(p||q)\neq D_{KL}(q||p)$$，即相对熵不具有对称性</p><p>3）$$D_{KL}(p||q)\geqslant 0$$</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gs480exk50j317a0j8tb3.jpg"></p><blockquote><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gs484vv26kj31l606q40v.jpg" alt="image-20210704002541376"></p></blockquote><h2 id="范数"><a href="#范数" class="headerlink" title="范数"></a>范数</h2><p>对于一维张量，也就是向量，常引入<strong>范数</strong>的概念：<a href="https://zhuanlan.zhihu.com/p/35897775">向量范数与矩阵范数</a></p><ul><li><strong>p-范数</strong></li></ul><p>$$\left | x \right |_p = (\sum |x_i|^{p})^\frac{1}{p}$$</p><p>注意，一些特殊范数：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gs539bq10mj31100hkwgc.jpg" alt="image-20191127001638381"></p><ul><li>机器学习中应用</li></ul><p>优化目标中一般会加入参数的L范数，也就是正则化项。选择合适的𝜆超参数可以获得较好的训练性能，同时保证网络的<strong>稀疏性</strong>，从而获得不错的泛化能力。</p><p>如下图，为不同程度的正则化约束对网络权值的影响【龙书】</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gtbddjo6bqj30uk0cudgw.jpg" alt="image-20210810080613185"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gtbdb3djxjj311h0u0dl0.jpg" alt="image-20210810080348994"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://www.bilibili.com/s/video/BV1TJ411y7Mp">统计的乐趣</a><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gs3o3tsx6hj318x0u07wh.jpg" alt="image-20210703125238027"></li><li></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;



&lt;h2 id=&quot;概率、统计区别&quot;&gt;&lt;a href=&quot;#概率、统计区别&quot; class=&quot;headerlink&quot; title=&quot;概率、统计区别&quot;&gt;&lt;/a&gt;概率、统计区别&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.so</summary>
      
    
    
    
    <category term="机器学习" scheme="http://example.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="数学" scheme="http://example.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>⭐️bert源码理解</title>
    <link href="http://example.com/2021/06/06/bert%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A3/"/>
    <id>http://example.com/2021/06/06/bert%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A3/</id>
    <published>2021-06-05T16:00:00.000Z</published>
    <updated>2021-06-19T09:03:03.639Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>原始无监督语料：sample.txt</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">koa  s?peer Electr-onics upc8172tb 汽车 3v_1pf</span><br><span class="line"></span><br><span class="line">cel  eval  board  upc8172tb</span><br><span class="line"></span><br><span class="line">avx  corporation  478  08052c223kaz2atr</span><br><span class="line"></span><br><span class="line">24  024  101  dip  cable</span><br><span class="line"></span><br><span class="line">cap  tant, poly cha</span><br><span class="line">c326c561fag5ta7301  kemet  cap</span><br><span class="line"> ipp  tvs  二极管. ?</span><br><span class="line">665  ohms  0.1%  0.4w  2/5w</span><br><span class="line">薄膜  a140666ct  nd  te</span><br><span class="line">===</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h2><p>max_seq_length： 每条训练语料的所含有的最大 token数</p><p>short_seq_prob： 缩短句子的概率（针对上面 的max_seq_length）</p><h2 id="create-pretraining-data-py"><a href="#create-pretraining-data-py" class="headerlink" title="create_pretraining_data.py"></a>create_pretraining_data.py</h2><p>生成预训练的标注数据集：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">_</span>):</span></span><br><span class="line">  tf.logging.set_verbosity(tf.logging.INFO)</span><br><span class="line"></span><br><span class="line">  tokenizer = tokenization.FullTokenizer(</span><br><span class="line">      vocab_file=FLAGS.vocab_file, do_lower_case=FLAGS.do_lower_case)-------------（<span class="number">1</span>）</span><br><span class="line"></span><br><span class="line">  input_files = []</span><br><span class="line">  <span class="keyword">for</span> input_pattern <span class="keyword">in</span> FLAGS.input_file.split(<span class="string">&quot;,&quot;</span>):</span><br><span class="line">    input_files.extend(tf.gfile.Glob(input_pattern))</span><br><span class="line"></span><br><span class="line">  tf.logging.info(<span class="string">&quot;*** Reading from input files ***&quot;</span>)</span><br><span class="line">  <span class="keyword">for</span> input_file <span class="keyword">in</span> input_files:</span><br><span class="line">    tf.logging.info(<span class="string">&quot;  %s&quot;</span>, input_file)</span><br><span class="line"></span><br><span class="line">  rng = random.Random(FLAGS.random_seed)</span><br><span class="line">  instances = create_training_instances(                             -------------（<span class="number">2</span>）</span><br><span class="line">      input_files, tokenizer, FLAGS.max_seq_length, FLAGS.dupe_factor,</span><br><span class="line">      FLAGS.short_seq_prob, FLAGS.masked_lm_prob, FLAGS.max_predictions_per_seq,</span><br><span class="line">      rng)</span><br><span class="line"></span><br><span class="line">  output_files = FLAGS.output_file.split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">  tf.logging.info(<span class="string">&quot;*** Writing to output files ***&quot;</span>)</span><br><span class="line">  <span class="keyword">for</span> output_file <span class="keyword">in</span> output_files:</span><br><span class="line">    tf.logging.info(<span class="string">&quot;  %s&quot;</span>, output_file)</span><br><span class="line"></span><br><span class="line">  write_instance_to_example_files(instances, tokenizer, FLAGS.max_seq_length,</span><br><span class="line">                                  FLAGS.max_predictions_per_seq, output_files)</span><br></pre></td></tr></table></figure><h3 id="1-创建分词器-tokenizer"><a href="#1-创建分词器-tokenizer" class="headerlink" title="(1)创建分词器 tokenizer"></a>(1)创建分词器 <code>tokenizer</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tokenizer = tokenization.FullTokenizer(</span><br><span class="line">      vocab_file=FLAGS.vocab_file, do_lower_case=FLAGS.do_lower_case)</span><br></pre></td></tr></table></figure><p>并传入 词汇表和大小写标志进行初始化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FullTokenizer</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">  <span class="string">&quot;&quot;&quot;Runs end-to-end tokenziation.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, vocab_file, do_lower_case=<span class="literal">True</span></span>):</span></span><br><span class="line">    self.vocab = load_vocab(vocab_file)  <span class="comment"># 加载读取词表，字典形式</span></span><br><span class="line">    self.inv_vocab = &#123;v: k <span class="keyword">for</span> k, v <span class="keyword">in</span> self.vocab.items()&#125;</span><br><span class="line">    self.basic_tokenizer = BasicTokenizer(do_lower_case=do_lower_case)</span><br><span class="line">    self.wordpiece_tokenizer = WordpieceTokenizer(vocab=self.vocab)</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">tokenize</span>(<span class="params">self, text</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;针对每篇document 先分好词（结合词典）</span></span><br><span class="line"><span class="string">    可以看出，传入的`text` 会经过两道程序：</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    split_tokens = []</span><br><span class="line">    <span class="keyword">for</span> token <span class="keyword">in</span> self.basic_tokenizer.tokenize(text):  <span class="comment"># 先对句子清洗、拆分                  --------1.1</span></span><br><span class="line">      <span class="keyword">for</span> sub_token <span class="keyword">in</span> self.wordpiece_tokenizer.tokenize(token):  <span class="comment"># 然后依据词表对每个分词进行进一步表示  -------1.2</span></span><br><span class="line">        split_tokens.append(sub_token)</span><br></pre></td></tr></table></figure><p>self.vocab：<code>(&#39;[PAD]&#39;, 0), (&#39;[unused1]&#39;, 1), (&#39;[unused2]&#39;, 2), (&#39;[unused3]&#39;, 3), (&#39;[UNK]&#39;, 4), (&#39;[CLS]&#39;, 5....</code></p><p>self.inv_vocab:    <code> &#123;0: &#39;[PAD]&#39;, 1: &#39;[unused1]&#39;, 2: &#39;[unused2]&#39;, 3: &#39;[unused3]&#39;, 4: &#39;[UNK]&#39;, 5: &#39;[CLS]&#39;, 6: &#39;[SEP]&#39;, 7: &#39;[MASK]...</code></p><ul><li>1.1 basic_tokenizer.tokenize(text):</li></ul><p>进行清洗和拆分</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BasicTokenizer</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">  <span class="string">&quot;&quot;&quot;Runs basic tokenization (punctuation splitting, lower casing, etc.).&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, do_lower_case=<span class="literal">True</span></span>):</span></span><br><span class="line">    self.do_lower_case = do_lower_case</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">tokenize</span>(<span class="params">self, text</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Tokenizes a piece of text.</span></span><br><span class="line"><span class="string">    举例：</span></span><br><span class="line"><span class="string">    text：【koa  s�peer Electr-onics 汽车 3v_1pf】</span></span><br><span class="line"><span class="string">    输出：[&#x27;koa&#x27;, &#x27;speer&#x27;, &#x27;Electr&#x27;, &#x27;-&#x27;, &#x27;onics&#x27;, &#x27;汽&#x27;, &#x27;车&#x27;, &#x27;3v&#x27;, &#x27;_&#x27;, &#x27;1pf&#x27;]</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    text = convert_to_unicode(text)</span><br><span class="line">    tf.logging.info(<span class="string">f&#x27;after [convert_to_unicode] :<span class="subst">&#123;text&#125;</span>&#x27;</span>)</span><br><span class="line">    text = self._clean_text(text)  <span class="comment">#检查单个字符是否合理, 以及空格的处理</span></span><br><span class="line">    tf.logging.info(<span class="string">f&#x27;after [_clean_text] :<span class="subst">&#123;text&#125;</span>&#x27;</span>)  <span class="comment"># 【koa   speer Electr-onics 汽车 3v_1pf】</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 中文处理</span></span><br><span class="line">    text = self._tokenize_chinese_chars(text)  <span class="comment"># 对中文进行单字的分隔</span></span><br><span class="line">    tf.logging.info(<span class="string">f&#x27;after [_tokenize_chinese_chars] :<span class="subst">&#123;text&#125;</span>&#x27;</span>)  <span class="comment"># 【koa   speer Electr-onics  汽  车  3v_1pf】</span></span><br><span class="line"></span><br><span class="line">    orig_tokens = whitespace_tokenize(text)  <span class="comment"># split（），转为列表</span></span><br><span class="line">    tf.logging.info(<span class="string">f&#x27;after [whitespace_tokenize] :<span class="subst">&#123;orig_tokens&#125;</span>&#x27;</span>) <span class="comment">#【[&#x27;koa&#x27;, &#x27;speer&#x27;, &#x27;Electr-onics&#x27;, &#x27;汽&#x27;, &#x27;车&#x27;, &#x27;3v_1pf&#x27;]】</span></span><br><span class="line">    split_tokens = []</span><br><span class="line">    <span class="keyword">for</span> token <span class="keyword">in</span> orig_tokens:  <span class="comment"># 逐个选取单个词，按照标点符号进行进一步的拆分</span></span><br><span class="line">      <span class="keyword">if</span> self.do_lower_case:</span><br><span class="line">        token = token.lower()</span><br><span class="line">        token = self._run_strip_accents(token)</span><br><span class="line">        tf.logging.info(<span class="string">f&#x27;token :<span class="subst">&#123;token&#125;</span>&#x27;</span>)</span><br><span class="line">      split_tokens.extend(self._run_split_on_punc(token))</span><br><span class="line">    tf.logging.info(<span class="string">f&#x27;split_tokens :<span class="subst">&#123;split_tokens&#125;</span>&#x27;</span>)  <span class="comment">#  【[&#x27;koa&#x27;, &#x27;speer&#x27;, &#x27;Electr&#x27;, &#x27;-&#x27;, &#x27;onics&#x27;, &#x27;汽&#x27;, &#x27;车&#x27;, &#x27;3v&#x27;, &#x27;_&#x27;, &#x27;1pf&#x27;]】</span></span><br><span class="line"></span><br><span class="line">    output_tokens = whitespace_tokenize(<span class="string">&quot; &quot;</span>.join(split_tokens))</span><br><span class="line">    tf.logging.info(<span class="string">f&#x27;after [basic_tokenizer.tokenize] :<span class="subst">&#123;output_tokens&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> output_tokens</span><br></pre></td></tr></table></figure><ul><li>1.2 wordpiece_tokenizer.tokenize(token)</li></ul><p>对上一步每个token 进行进一步的拆分，方便后续的词典表示</p><p>结合词典进行前缀匹配，贪心算法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordpieceTokenizer</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">  <span class="string">&quot;&quot;&quot;Runs WordPiece tokenziation.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, vocab, unk_token=<span class="string">&quot;[UNK]&quot;</span>, max_input_chars_per_word=<span class="number">200</span></span>):</span></span><br><span class="line">    self.vocab = vocab</span><br><span class="line">    self.unk_token = unk_token</span><br><span class="line">    self.max_input_chars_per_word = max_input_chars_per_word</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">tokenize</span>(<span class="params">self, text</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Tokenizes a piece of text into its word pieces.</span></span><br><span class="line"><span class="string">    This uses a greedy longest-match-first algorithm to perform tokenization</span></span><br><span class="line"><span class="string">    using the given vocabulary.</span></span><br><span class="line"><span class="string">    For example:</span></span><br><span class="line"><span class="string">      input = &quot;unaffable&quot;</span></span><br><span class="line"><span class="string">      output = [&quot;un&quot;, &quot;##aff&quot;, &quot;##able&quot;]</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">      text: A single token or whitespace separated tokens. This should have</span></span><br><span class="line"><span class="string">        already been passed through `BasicTokenizer.</span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">      A list of wordpiece tokens.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    tf.logging.info(<span class="string">f&#x27;[wordpiece_tokenizer.tokenize]传入 :<span class="subst">&#123;text&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    text = convert_to_unicode(text)</span><br><span class="line"></span><br><span class="line">    output_tokens = []</span><br><span class="line">    tf.logging.info(<span class="string">f&#x27;[whitespace_tokenize(text) :<span class="subst">&#123;whitespace_tokenize(text)&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> token <span class="keyword">in</span> whitespace_tokenize(text):</span><br><span class="line">      chars = <span class="built_in">list</span>(token)</span><br><span class="line">      <span class="keyword">if</span> <span class="built_in">len</span>(chars) &gt; self.max_input_chars_per_word:</span><br><span class="line">        output_tokens.append(self.unk_token)</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">      is_bad = <span class="literal">False</span></span><br><span class="line">      start = <span class="number">0</span></span><br><span class="line">      sub_tokens = []</span><br><span class="line">      <span class="keyword">while</span> start &lt; <span class="built_in">len</span>(chars):</span><br><span class="line">        end = <span class="built_in">len</span>(chars)</span><br><span class="line">        cur_substr = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> start &lt; end:</span><br><span class="line">          substr = <span class="string">&quot;&quot;</span>.join(chars[start:end])</span><br><span class="line">          <span class="keyword">if</span> start &gt; <span class="number">0</span>:</span><br><span class="line">            substr = <span class="string">&quot;##&quot;</span> + substr</span><br><span class="line">          <span class="keyword">if</span> substr <span class="keyword">in</span> self.vocab:</span><br><span class="line">            cur_substr = substr</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">          end -= <span class="number">1</span>  <span class="comment"># 从这里可以看出，优先匹配前缀</span></span><br><span class="line">        tf.logging.info(<span class="string">f&#x27;cur_substr :<span class="subst">&#123;cur_substr&#125;</span>&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> cur_substr <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># 如果遇到子字符串为None，则查找失败</span></span><br><span class="line">          is_bad = <span class="literal">True</span></span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">        sub_tokens.append(cur_substr)</span><br><span class="line">        start = end  <span class="comment"># 去除前缀后继续查找</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> is_bad:</span><br><span class="line">        output_tokens.append(self.unk_token)</span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">        output_tokens.extend(sub_tokens)</span><br><span class="line">    tf.logging.info(<span class="string">f&#x27;[wordpiece_tokenizer.tokenize]返回 :<span class="subst">&#123;output_tokens&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> output_tokens</span><br></pre></td></tr></table></figure><p>比如，传入 ‘electronics’，</p><p>词表中有：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">....</span><br><span class="line">cap</span><br><span class="line">cel</span><br><span class="line">ele</span><br><span class="line">##ctronics</span><br><span class="line">elec</span><br><span class="line">##tronics</span><br><span class="line">cer</span><br><span class="line">cha</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>那么，结果返回为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INFO - [wordpiece_tokenizer.tokenize]传入 :electronics</span><br><span class="line">2021-06-06 19:25:55,843 - tensorflow - INFO - cur_substr :elec</span><br><span class="line">2021-06-06 19:25:55,843 - tensorflow - INFO - cur_substr :##tronics</span><br><span class="line">2021-06-06 19:25:55,843 - tensorflow - INFO - [wordpiece_tokenizer.tokenize]返回 :[&#x27;elec&#x27;, &#x27;##tronics&#x27;]</span><br></pre></td></tr></table></figure><p>但是，如果词表又仅仅增加了 <code>electro</code></p><p>那么，结果就将为 [UNK]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">INFO - [wordpiece_tokenizer.tokenize]传入 :electronics</span><br><span class="line">2021-06-06 19:35:10,232 - tensorflow - INFO - cur_substr :electro</span><br><span class="line">2021-06-06 19:35:10,232 - tensorflow - INFO - [wordpiece_tokenizer.tokenize]返回 :[&#x27;[UNK]&#x27;]</span><br></pre></td></tr></table></figure><h3 id="2-create-training-instances"><a href="#2-create-training-instances" class="headerlink" title="(2)create_training_instances()"></a>(2)create_training_instances()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_training_instances</span>(<span class="params">input_files, tokenizer, max_seq_length,</span></span></span><br><span class="line"><span class="params"><span class="function">                              dupe_factor, short_seq_prob, masked_lm_prob,</span></span></span><br><span class="line"><span class="params"><span class="function">                              max_predictions_per_seq, rng</span>):</span></span><br><span class="line">  <span class="string">&quot;&quot;&quot;Create `TrainingInstance`s from raw text.&quot;&quot;&quot;</span></span><br><span class="line">  all_documents = [[]]</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 输入文件格式：</span></span><br><span class="line">  <span class="comment"># 每行一句话，空行表示document 分割，也即属于不同的文档</span></span><br><span class="line">  <span class="keyword">for</span> input_file <span class="keyword">in</span> input_files:</span><br><span class="line">    <span class="keyword">with</span> tf.gfile.GFile(input_file, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> reader:</span><br><span class="line">      <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        line = tokenization.convert_to_unicode(reader.readline())</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> line:  <span class="comment"># 表示读完</span></span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">        line = line.strip()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Empty lines are used as document delimiters</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> line:  <span class="comment"># 空行，表示新的文档</span></span><br><span class="line">          all_documents.append([])</span><br><span class="line">        tokens = tokenizer.tokenize(line)   <span class="comment"># 参见（1）</span></span><br><span class="line">        <span class="keyword">if</span> tokens:</span><br><span class="line">          all_documents[-<span class="number">1</span>].append(tokens)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># Remove empty documents</span></span><br><span class="line">  all_documents = [x <span class="keyword">for</span> x <span class="keyword">in</span> all_documents <span class="keyword">if</span> x]</span><br><span class="line">  rng.shuffle(all_documents)</span><br><span class="line"></span><br><span class="line">  vocab_words = <span class="built_in">list</span>(tokenizer.vocab.keys())</span><br><span class="line">  instances = []</span><br><span class="line">  <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(dupe_factor):</span><br><span class="line">    <span class="keyword">for</span> document_index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(all_documents)): <span class="comment"># 按照document_index 取值</span></span><br><span class="line">      instances.extend(</span><br><span class="line">          create_instances_from_document(---------------<span class="number">2.1</span></span><br><span class="line">              all_documents, document_index, max_seq_length, short_seq_prob,</span><br><span class="line">              masked_lm_prob, max_predictions_per_seq, vocab_words, rng))</span><br><span class="line"></span><br><span class="line">  rng.shuffle(instances)</span><br><span class="line">  <span class="keyword">return</span> instances</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>2.1 create_instances_from_document()</li></ul><p>生成训练集</p><p>依据 （1）产生的分词结果，进行遮盖替换，并标注正确标签</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_instances_from_document</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    all_documents, document_index, max_seq_length, short_seq_prob,</span></span></span><br><span class="line"><span class="params"><span class="function">    masked_lm_prob, max_predictions_per_seq, vocab_words, rng</span>):</span></span><br><span class="line">  <span class="string">&quot;&quot;&quot;Creates `TrainingInstance`s for a single document.&quot;&quot;&quot;</span></span><br><span class="line">  document = all_documents[document_index]</span><br><span class="line"></span><br><span class="line">  <span class="comment"># Account for [CLS], [SEP], [SEP]</span></span><br><span class="line">  max_num_tokens = max_seq_length - <span class="number">3</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 在max_num_tokens基础上，缩短句子的概率</span></span><br><span class="line">  target_seq_length = max_num_tokens</span><br><span class="line">  <span class="keyword">if</span> rng.random() &lt; short_seq_prob:</span><br><span class="line">    target_seq_length = rng.randint(<span class="number">2</span>, max_num_tokens)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># We DON&#x27;T just concatenate all of the tokens from a document into a long</span></span><br><span class="line">  <span class="comment"># sequence and choose an arbitrary split point because this would make the</span></span><br><span class="line">  <span class="comment"># next sentence prediction task too easy. Instead, we split the input into</span></span><br><span class="line">  <span class="comment"># segments &quot;A&quot; and &quot;B&quot; based on the actual &quot;sentences&quot; provided by the user</span></span><br><span class="line">  <span class="comment"># input.</span></span><br><span class="line">  instances = []</span><br><span class="line">  current_chunk = []</span><br><span class="line">  current_length = <span class="number">0</span></span><br><span class="line">  i = <span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(document):   <span class="comment"># 从doucument 不断选择segment，受制于target_seq_length</span></span><br><span class="line">    segment = document[i]</span><br><span class="line">    current_chunk.append(segment)</span><br><span class="line">    current_length += <span class="built_in">len</span>(segment)</span><br><span class="line">    <span class="keyword">if</span> i == <span class="built_in">len</span>(document) - <span class="number">1</span> <span class="keyword">or</span> current_length &gt;= target_seq_length:</span><br><span class="line">      <span class="keyword">if</span> current_chunk:</span><br><span class="line">        <span class="comment"># `a_end` is how many segments from `current_chunk` go into the `A`</span></span><br><span class="line">        <span class="comment"># (first) sentence.</span></span><br><span class="line">        a_end = <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(current_chunk) &gt;= <span class="number">2</span>:</span><br><span class="line">          a_end = rng.randint(<span class="number">1</span>, <span class="built_in">len</span>(current_chunk) - <span class="number">1</span>)  <span class="comment"># 决定选择多少个segment，对于多segment 的文档</span></span><br><span class="line"></span><br><span class="line">        tokens_a = []</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(a_end):</span><br><span class="line">          tokens_a.extend(current_chunk[j])</span><br><span class="line"></span><br><span class="line">        tokens_b = []</span><br><span class="line">        <span class="comment"># Random next</span></span><br><span class="line">        is_random_next = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(current_chunk) == <span class="number">1</span> <span class="keyword">or</span> rng.random() &lt; <span class="number">0.5</span>:</span><br><span class="line">          is_random_next = <span class="literal">True</span></span><br><span class="line">          target_b_length = target_seq_length - <span class="built_in">len</span>(tokens_a)</span><br><span class="line"></span><br><span class="line">          <span class="comment"># This should rarely go for more than one iteration for large</span></span><br><span class="line">          <span class="comment"># corpora. However, just to be careful, we try to make sure that</span></span><br><span class="line">          <span class="comment"># the random document is not the same as the document</span></span><br><span class="line">          <span class="comment"># we&#x27;re processing.</span></span><br><span class="line">          <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">            random_document_index = rng.randint(<span class="number">0</span>, <span class="built_in">len</span>(all_documents) - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> random_document_index != document_index:</span><br><span class="line">              <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">          random_document = all_documents[random_document_index]</span><br><span class="line">          random_start = rng.randint(<span class="number">0</span>, <span class="built_in">len</span>(random_document) - <span class="number">1</span>)</span><br><span class="line">          <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(random_start, <span class="built_in">len</span>(random_document)):</span><br><span class="line">            tokens_b.extend(random_document[j])</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(tokens_b) &gt;= target_b_length:</span><br><span class="line">              <span class="keyword">break</span></span><br><span class="line">          <span class="comment"># We didn&#x27;t actually use these segments so we &quot;put them back&quot; so</span></span><br><span class="line">          <span class="comment"># they don&#x27;t go to waste.</span></span><br><span class="line">          num_unused_segments = <span class="built_in">len</span>(current_chunk) - a_end</span><br><span class="line">          i -= num_unused_segments</span><br><span class="line">        <span class="comment"># Actual next</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">          is_random_next = <span class="literal">False</span></span><br><span class="line">          <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(a_end, <span class="built_in">len</span>(current_chunk)):</span><br><span class="line">            tokens_b.extend(current_chunk[j])</span><br><span class="line">        truncate_seq_pair(tokens_a, tokens_b, max_num_tokens, rng)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">len</span>(tokens_a) &gt;= <span class="number">1</span></span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">len</span>(tokens_b) &gt;= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        tokens = []</span><br><span class="line">        segment_ids = []</span><br><span class="line">        tokens.append(<span class="string">&quot;[CLS]&quot;</span>)</span><br><span class="line">        segment_ids.append(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> token <span class="keyword">in</span> tokens_a:</span><br><span class="line">          tokens.append(token)</span><br><span class="line">          segment_ids.append(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        tokens.append(<span class="string">&quot;[SEP]&quot;</span>)</span><br><span class="line">        segment_ids.append(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> token <span class="keyword">in</span> tokens_b:</span><br><span class="line">          tokens.append(token)</span><br><span class="line">          segment_ids.append(<span class="number">1</span>)</span><br><span class="line">        tokens.append(<span class="string">&quot;[SEP]&quot;</span>)</span><br><span class="line">        segment_ids.append(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        (tokens, masked_lm_positions,</span><br><span class="line">         masked_lm_labels) = create_masked_lm_predictions(</span><br><span class="line">             tokens, masked_lm_prob, max_predictions_per_seq, vocab_words, rng)</span><br><span class="line">        instance = TrainingInstance(</span><br><span class="line">            tokens=tokens,</span><br><span class="line">            segment_ids=segment_ids,</span><br><span class="line">            is_random_next=is_random_next,</span><br><span class="line">            masked_lm_positions=masked_lm_positions,</span><br><span class="line">            masked_lm_labels=masked_lm_labels)</span><br><span class="line">        instances.append(instance)</span><br><span class="line">      current_chunk = []</span><br><span class="line">      current_length = <span class="number">0</span></span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> instances</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://hanielxx.com/MachineLearning/2021-02-23-bert-create-pretrain-data-analysis.html">BERT-预训练源码理解</a></li><li></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;



&lt;p&gt;原始无监督语料：sample.txt&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1</summary>
      
    
    
    
    <category term="NLP" scheme="http://example.com/categories/NLP/"/>
    
    
    <category term="bert" scheme="http://example.com/tags/bert/"/>
    
  </entry>
  
  <entry>
    <title>⭐️jieba分词原理解读</title>
    <link href="http://example.com/2021/05/30/Jieba%E5%88%86%E8%AF%8D%E5%8E%9F%E7%90%86%E8%A7%A3%E8%AF%BB/"/>
    <id>http://example.com/2021/05/30/Jieba%E5%88%86%E8%AF%8D%E5%8E%9F%E7%90%86%E8%A7%A3%E8%AF%BB/</id>
    <published>2021-05-29T16:00:00.000Z</published>
    <updated>2021-06-30T14:44:27.786Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ul><li>基于前缀词典实现高效的词图扫描，生成句子中汉字所有可能成词情况所构成的有向无环图(DAG)</li><li>采用了动态规划查找最大概率路径, 找出基于词频的最大切分组合</li><li>对于未登录词，采用了基于汉字成词能力的HMM 模型，使用了Viterbi 算法</li></ul><h2 id="前缀词典"><a href="#前缀词典" class="headerlink" title="前缀词典"></a>前缀词典</h2><p><code>self.FREQ, self.total = self.gen_pfdict(self.get_dict_file())</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_pfdict</span>(<span class="params">f</span>):</span></span><br><span class="line">    lfreq = &#123;&#125;</span><br><span class="line">    ltotal = <span class="number">0</span></span><br><span class="line">    f_name = resolve_filename(f)</span><br><span class="line">    <span class="keyword">for</span> lineno, line <span class="keyword">in</span> <span class="built_in">enumerate</span>(f, <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            line = line.strip().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">            word, freq = line.split(<span class="string">&#x27; &#x27;</span>)[:<span class="number">2</span>]</span><br><span class="line">            freq = <span class="built_in">int</span>(freq)</span><br><span class="line">            lfreq[word] = freq</span><br><span class="line">            ltotal += freq</span><br><span class="line">            <span class="keyword">for</span> ch <span class="keyword">in</span> xrange(<span class="built_in">len</span>(word)):</span><br><span class="line">                wfrag = word[:ch + <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span> wfrag <span class="keyword">not</span> <span class="keyword">in</span> lfreq:</span><br><span class="line">                    lfreq[wfrag] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">except</span> ValueError:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(</span><br><span class="line">                <span class="string">&#x27;invalid dictionary entry in %s at Line %s: %s&#x27;</span> % (f_name, lineno, line))</span><br><span class="line">    f.close()</span><br><span class="line">    <span class="keyword">return</span> lfreq, ltotal</span><br></pre></td></tr></table></figure><h2 id="Tokenizer-cut"><a href="#Tokenizer-cut" class="headerlink" title="Tokenizer.cut()"></a>Tokenizer.cut()</h2><p>以对句子 ’我来到清华大学‘分词为例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#encoding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> unicode_literals</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.append(<span class="string">&quot;../&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line"></span><br><span class="line">seg_list = jieba.cut(<span class="string">&quot;我来到 我来到北京清华大学&quot;</span>, cut_all=<span class="literal">False</span>)</span><br><span class="line"><span class="built_in">print</span>(seg_list)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Default Mode: &quot;</span> + <span class="string">&quot;/ &quot;</span>.join(seg_list))  <span class="comment"># 默认模式</span></span><br></pre></td></tr></table></figure><p>调用<strong>类Tokenizer</strong> 中cut() 方法 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cut</span>(<span class="params">self, sentence, cut_all=<span class="literal">False</span>, HMM=<span class="literal">True</span>, use_paddle=<span class="literal">False</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The main function that segments an entire sentence that contains</span></span><br><span class="line"><span class="string">    Chinese characters into separated words.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Parameter:</span></span><br><span class="line"><span class="string">        - sentence: The str(unicode) to be segmented.</span></span><br><span class="line"><span class="string">        - cut_all: Model type. True for full pattern, False for accurate pattern.</span></span><br><span class="line"><span class="string">        - HMM: Whether to use the Hidden Markov Model.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    re_han = re_han_default</span><br><span class="line">    re_skip = re_skip_default</span><br><span class="line">    <span class="keyword">if</span> cut_all:</span><br><span class="line">        cut_block = self.__cut_all</span><br><span class="line">    <span class="keyword">elif</span> HMM:</span><br><span class="line">        cut_block = self.__cut_DAG  <span class="comment"># 有向无环图 (DAG)------（1）</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        cut_block = self.__cut_DAG_NO_HMM</span><br><span class="line">    blocks = re_han.split(sentence)  <span class="comment"># [&#x27;&#x27;, &#x27;我来到北京清华大学&#x27;, &#x27;&#x27;]</span></span><br><span class="line">    <span class="keyword">for</span> blk <span class="keyword">in</span> blocks:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> blk:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> re_han.match(blk):  <span class="comment"># 如果有意义，即内容在 re_han 匹配里面</span></span><br><span class="line">            <span class="keyword">for</span> word <span class="keyword">in</span> cut_block(blk):</span><br><span class="line">                <span class="keyword">yield</span> word</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            tmp = re_skip.split(blk)</span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> tmp:</span><br><span class="line">                <span class="keyword">if</span> re_skip.match(x):</span><br><span class="line">                    <span class="keyword">yield</span> x</span><br><span class="line">                <span class="keyword">elif</span> <span class="keyword">not</span> cut_all:</span><br><span class="line">                    <span class="keyword">for</span> xx <span class="keyword">in</span> x:</span><br><span class="line">                        <span class="keyword">yield</span> xx</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">yield</span> x</span><br></pre></td></tr></table></figure><p>（1）cut_block 调用下面代码，进行DAG 的生成和概率计算：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__cut_DAG</span>(<span class="params">self, sentence</span>):</span></span><br><span class="line">    DAG = self.get_DAG(sentence)<span class="comment"># ---------1.1  &#123;0: [0], 1: [1, 2], 2: [2], 3: [3, 4], 4: [4], 5: [5, 6, 8], 6: [6, 7], 7: [7, 8], 8: [8]&#125;</span></span><br><span class="line">    route = &#123;&#125;</span><br><span class="line">    self.calc(sentence, DAG, route)<span class="comment"># ---------1.2，计算概率，修改 route</span></span><br><span class="line">    x = <span class="number">0</span></span><br><span class="line">    buf = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    N = <span class="built_in">len</span>(sentence)</span><br><span class="line">    <span class="keyword">while</span> x &lt; N:</span><br><span class="line">        y = route[x][<span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">        l_word = sentence[x:y]</span><br><span class="line">        <span class="keyword">if</span> y - x == <span class="number">1</span>:</span><br><span class="line">            buf += l_word</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> buf:</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(buf) == <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">yield</span> buf</span><br><span class="line">                    buf = <span class="string">&#x27;&#x27;</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> self.FREQ.get(buf):</span><br><span class="line">                        recognized = finalseg.cut(buf)  <span class="comment"># ---------1.3，HMM维特比</span></span><br><span class="line">                        <span class="keyword">for</span> t <span class="keyword">in</span> recognized:</span><br><span class="line">                            <span class="keyword">yield</span> t</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">for</span> elem <span class="keyword">in</span> buf:</span><br><span class="line">                            <span class="keyword">yield</span> elem</span><br><span class="line">                    buf = <span class="string">&#x27;&#x27;</span></span><br><span class="line">            <span class="keyword">yield</span> l_word</span><br><span class="line">        x = y</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> buf:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(buf) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">yield</span> buf</span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> self.FREQ.get(buf):</span><br><span class="line">            recognized = finalseg.cut(buf)</span><br><span class="line">            <span class="keyword">for</span> t <span class="keyword">in</span> recognized:</span><br><span class="line">                <span class="keyword">yield</span> t</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> elem <span class="keyword">in</span> buf:</span><br><span class="line">                <span class="keyword">yield</span> elem</span><br></pre></td></tr></table></figure><p>route:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">dict</span>&#x27;&gt;:</span> &#123;<span class="number">9</span>: (<span class="number">0</span>, <span class="number">0</span>), <span class="number">8</span>: (-<span class="number">8.142626068614787</span>, <span class="number">8</span>), <span class="number">7</span>: (-<span class="number">8.006816355818659</span>, <span class="number">8</span>), <span class="number">6</span>: (-<span class="number">17.53722513662092</span>, <span class="number">6</span>), <span class="number">5</span>: (-<span class="number">11.085007904198626</span>, <span class="number">8</span>), <span class="number">4</span>: (-<span class="number">20.20431518448597</span>, <span class="number">4</span>), <span class="number">3</span>: (-<span class="number">18.548194315526874</span>, <span class="number">4</span>), <span class="number">2</span>: (-<span class="number">24.22732015246924</span>, <span class="number">2</span>), <span class="number">1</span>: (-<span class="number">27.379629658355885</span>, <span class="number">2</span>), <span class="number">0</span>: (-<span class="number">32.587853155857076</span>, <span class="number">0</span>)&#125;</span><br></pre></td></tr></table></figure><h3 id="1-1-get-DAG"><a href="#1-1-get-DAG" class="headerlink" title="1.1 get_DAG()"></a>1.1 get_DAG()</h3><p>生成DAG 图，含义为一句话中每个字可以到达的有意义的位置</p><p>需结合 self.FREQ 词典</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_DAG</span>(<span class="params">self, sentence</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; </span></span><br><span class="line"><span class="string">    生成有向无环图</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param sentence: &#x27;我来到清华大学&#x27;</span></span><br><span class="line"><span class="string">    :return: &#123;0: [0], 1: [1, 2], 2: [2], 3: [3, 4], 4: [4], 5: [5, 6, 8], 6: [6, 7], 7: [7, 8], 8: [8]&#125;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    self.check_initialized()</span><br><span class="line">    DAG = &#123;&#125;</span><br><span class="line">    N = <span class="built_in">len</span>(sentence)</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> xrange(N):</span><br><span class="line">        tmplist = []</span><br><span class="line">        i = k</span><br><span class="line">        frag = sentence[k]</span><br><span class="line">        <span class="keyword">while</span> i &lt; N <span class="keyword">and</span> frag <span class="keyword">in</span> self.FREQ:  <span class="comment"># 只要不在就终止判断了，结合词典</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;frag&#125;</span>: <span class="subst">&#123;self.FREQ[frag]&#125;</span>&#x27;</span> ) ---------（<span class="number">1.1</span><span class="number">.1</span>）</span><br><span class="line">            <span class="keyword">if</span> self.FREQ[frag]:  <span class="comment"># 如果词频不为0</span></span><br><span class="line">                tmplist.append(i)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            frag = sentence[k:i + <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> tmplist:  <span class="comment"># tmplist为空</span></span><br><span class="line">            tmplist.append(k)</span><br><span class="line">        DAG[k] = tmplist</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;DAG:<span class="subst">&#123;DAG&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> DAG</span><br></pre></td></tr></table></figure><p>frag  显示过程如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">我: <span class="number">328841</span></span><br><span class="line">来: <span class="number">161501</span></span><br><span class="line">来到: <span class="number">8779</span></span><br><span class="line">到: <span class="number">205341</span></span><br><span class="line">北: <span class="number">17860</span></span><br><span class="line">北京: <span class="number">34488</span></span><br><span class="line">京: <span class="number">6583</span></span><br><span class="line">清: <span class="number">17519</span>-----<span class="number">5</span></span><br><span class="line">清华: <span class="number">1057</span>----<span class="number">6</span></span><br><span class="line">清华大: <span class="number">0</span>  <span class="comment"># 注意</span></span><br><span class="line">清华大学: <span class="number">922</span>---<span class="number">8</span></span><br><span class="line">华: <span class="number">4364</span></span><br><span class="line">华大: <span class="number">12</span></span><br><span class="line">大: <span class="number">144099</span></span><br><span class="line">大学: <span class="number">20025</span></span><br><span class="line">学: <span class="number">17482</span></span><br></pre></td></tr></table></figure><p>以 ‘清’ 为例，5: [5, 6, 8]表示，从‘清’出发，可以分出：清，清华，清华大学。刚好对应下图的三条路径</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1grvue0pwggj318409umyl.jpg" alt="image-20210626182531251"></p><h3 id="1-2-calc"><a href="#1-2-calc" class="headerlink" title="1.2 calc()"></a>1.2 calc()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc</span>(<span class="params">self, sentence, DAG, route</span>):</span></span><br><span class="line">    N = <span class="built_in">len</span>(sentence)</span><br><span class="line">    route[N] = (<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    logtotal = log(self.total)</span><br><span class="line">    <span class="keyword">for</span> idx <span class="keyword">in</span> xrange(N - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):  <span class="comment"># 倒着取值</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;-&#x27;</span> * <span class="number">10</span>)</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> DAG[idx]:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;考察词为：<span class="subst">&#123;sentence[idx:x + <span class="number">1</span>]&#125;</span>&#x27;</span>)</span><br><span class="line">            freq = self.FREQ.get(sentence[idx:x + <span class="number">1</span>]) <span class="keyword">or</span> <span class="number">1</span>  <span class="comment"># 获取</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;后一个词概率为：<span class="subst">&#123;route[x + <span class="number">1</span>][<span class="number">0</span>]&#125;</span>&#x27;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;当前词概率为：<span class="subst">&#123;log(freq) - logtotal&#125;</span>&#x27;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;【<span class="subst">&#123;sentence[idx:x + <span class="number">1</span>]&#125;</span>】概率计算: <span class="subst">&#123;(log(freq) - logtotal + route[x + <span class="number">1</span>][<span class="number">0</span>], x)&#125;</span>&#x27;</span>)</span><br><span class="line">        <span class="comment"># -------</span></span><br><span class="line">        route[idx] = <span class="built_in">max</span>(</span><br><span class="line">            (log(self.FREQ.get(sentence[idx:x + <span class="number">1</span>]) <span class="keyword">or</span> <span class="number">1</span>) - logtotal + route[x + <span class="number">1</span>][<span class="number">0</span>], x) <span class="keyword">for</span> x <span class="keyword">in</span> DAG[idx])</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;route: <span class="subst">&#123;route&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure><p>采用动态规划，计算逆向最大匹配</p><p>其实是一个概率相乘问题，用对数后变为相加</p><p>根据上一步的<code>DAG：&#123;0: [0], 1: [1, 2], 2: [2], 3: [3, 4], 4: [4], 5: [5, 6, 8], 6: [6, 7], 7: [7, 8], 8: [8]&#125;</code>，进行倒序计算</p><p>过程如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">----------</span><br><span class="line">考察词为：学</span><br><span class="line">后一个词概率为：<span class="number">0</span></span><br><span class="line">当前词概率为：-<span class="number">8.142626068614787</span></span><br><span class="line">【学】概率计算: (-<span class="number">8.142626068614787</span>, <span class="number">8</span>)</span><br><span class="line">route: &#123;<span class="number">9</span>: (<span class="number">0</span>, <span class="number">0</span>), <span class="number">8</span>: (-<span class="number">8.142626068614787</span>, <span class="number">8</span>)&#125;</span><br><span class="line">----------</span><br><span class="line">考察词为：大</span><br><span class="line">后一个词概率为：-<span class="number">8.142626068614787</span></span><br><span class="line">当前词概率为：-<span class="number">6.033297285416946</span></span><br><span class="line">【大】概率计算: (-<span class="number">14.175923354031733</span>, <span class="number">7</span>)</span><br><span class="line">考察词为：大学</span><br><span class="line">后一个词概率为：<span class="number">0</span></span><br><span class="line">当前词概率为：-<span class="number">8.006816355818659</span></span><br><span class="line">【大学】概率计算: (-<span class="number">8.006816355818659</span>, <span class="number">8</span>)</span><br><span class="line">route: &#123;<span class="number">9</span>: (<span class="number">0</span>, <span class="number">0</span>), <span class="number">8</span>: (-<span class="number">8.142626068614787</span>, <span class="number">8</span>), <span class="number">7</span>: (-<span class="number">8.006816355818659</span>, <span class="number">8</span>)&#125;</span><br><span class="line">----------</span><br><span class="line">考察词为：华</span><br><span class="line">后一个词概率为：-<span class="number">8.006816355818659</span></span><br><span class="line">当前词概率为：-<span class="number">9.530408780802258</span></span><br><span class="line">【华】概率计算: (-<span class="number">17.53722513662092</span>, <span class="number">6</span>)</span><br><span class="line">考察词为：华大</span><br><span class="line">后一个词概率为：-<span class="number">8.142626068614787</span></span><br><span class="line">当前词概率为：-<span class="number">15.42664647796722</span></span><br><span class="line">【华大】概率计算: (-<span class="number">23.569272546582006</span>, <span class="number">7</span>)</span><br><span class="line">route: &#123;<span class="number">9</span>: (<span class="number">0</span>, <span class="number">0</span>), <span class="number">8</span>: (-<span class="number">8.142626068614787</span>, <span class="number">8</span>), <span class="number">7</span>: (-<span class="number">8.006816355818659</span>, <span class="number">8</span>), <span class="number">6</span>: (-<span class="number">17.53722513662092</span>, <span class="number">6</span>)&#125;</span><br><span class="line">----------</span><br><span class="line">考察词为：清</span><br><span class="line">后一个词概率为：-<span class="number">17.53722513662092</span></span><br><span class="line">当前词概率为：-<span class="number">8.140511842519397</span></span><br><span class="line">【清】概率计算: (-<span class="number">25.677736979140313</span>, <span class="number">5</span>)</span><br><span class="line">考察词为：清华</span><br><span class="line">后一个词概率为：-<span class="number">8.006816355818659</span></span><br><span class="line">当前词概率为：-<span class="number">10.948363141884982</span></span><br><span class="line">【清华】概率计算: (-<span class="number">18.95517949770364</span>, <span class="number">6</span>)</span><br><span class="line">考察词为：清华大学</span><br><span class="line">后一个词概率为：<span class="number">0</span></span><br><span class="line">当前词概率为：-<span class="number">11.085007904198626</span></span><br><span class="line">【清华大学】概率计算: (-<span class="number">11.085007904198626</span>, <span class="number">8</span>)</span><br><span class="line">route: &#123;<span class="number">9</span>: (<span class="number">0</span>, <span class="number">0</span>), <span class="number">8</span>: (-<span class="number">8.142626068614787</span>, <span class="number">8</span>), <span class="number">7</span>: (-<span class="number">8.006816355818659</span>, <span class="number">8</span>), <span class="number">6</span>: (-<span class="number">17.53722513662092</span>, <span class="number">6</span>), <span class="number">5</span>: (-<span class="number">11.085007904198626</span>, <span class="number">8</span>)&#125;</span><br><span class="line">----------</span><br><span class="line">考察词为：京</span><br><span class="line">后一个词概率为：-<span class="number">11.085007904198626</span></span><br><span class="line">当前词概率为：-<span class="number">9.119307280287343</span></span><br><span class="line">【京】概率计算: (-<span class="number">20.20431518448597</span>, <span class="number">4</span>)</span><br><span class="line">route: &#123;<span class="number">9</span>: (<span class="number">0</span>, <span class="number">0</span>), <span class="number">8</span>: (-<span class="number">8.142626068614787</span>, <span class="number">8</span>), <span class="number">7</span>: (-<span class="number">8.006816355818659</span>, <span class="number">8</span>), <span class="number">6</span>: (-<span class="number">17.53722513662092</span>, <span class="number">6</span>), <span class="number">5</span>: (-<span class="number">11.085007904198626</span>, <span class="number">8</span>), <span class="number">4</span>: (-<span class="number">20.20431518448597</span>, <span class="number">4</span>)&#125;</span><br><span class="line">----------</span><br><span class="line">考察词为：北</span><br><span class="line">后一个词概率为：-<span class="number">20.20431518448597</span></span><br><span class="line">当前词概率为：-<span class="number">8.12123427332473</span></span><br><span class="line">【北】概率计算: (-<span class="number">28.325549457810702</span>, <span class="number">3</span>)</span><br><span class="line">考察词为：北京</span><br><span class="line">后一个词概率为：-<span class="number">11.085007904198626</span></span><br><span class="line">当前词概率为：-<span class="number">7.463186411328248</span></span><br><span class="line">【北京】概率计算: (-<span class="number">18.548194315526874</span>, <span class="number">4</span>)</span><br><span class="line">route: &#123;<span class="number">9</span>: (<span class="number">0</span>, <span class="number">0</span>), <span class="number">8</span>: (-<span class="number">8.142626068614787</span>, <span class="number">8</span>), <span class="number">7</span>: (-<span class="number">8.006816355818659</span>, <span class="number">8</span>), <span class="number">6</span>: (-<span class="number">17.53722513662092</span>, <span class="number">6</span>), <span class="number">5</span>: (-<span class="number">11.085007904198626</span>, <span class="number">8</span>), <span class="number">4</span>: (-<span class="number">20.20431518448597</span>, <span class="number">4</span>), <span class="number">3</span>: (-<span class="number">18.548194315526874</span>, <span class="number">4</span>)&#125;</span><br><span class="line">----------</span><br><span class="line">考察词为：到</span><br><span class="line">后一个词概率为：-<span class="number">18.548194315526874</span></span><br><span class="line">当前词概率为：-<span class="number">5.679125836942367</span></span><br><span class="line">【到】概率计算: (-<span class="number">24.22732015246924</span>, <span class="number">2</span>)</span><br><span class="line">route: &#123;<span class="number">9</span>: (<span class="number">0</span>, <span class="number">0</span>), <span class="number">8</span>: (-<span class="number">8.142626068614787</span>, <span class="number">8</span>), <span class="number">7</span>: (-<span class="number">8.006816355818659</span>, <span class="number">8</span>), <span class="number">6</span>: (-<span class="number">17.53722513662092</span>, <span class="number">6</span>), <span class="number">5</span>: (-<span class="number">11.085007904198626</span>, <span class="number">8</span>), <span class="number">4</span>: (-<span class="number">20.20431518448597</span>, <span class="number">4</span>), <span class="number">3</span>: (-<span class="number">18.548194315526874</span>, <span class="number">4</span>), <span class="number">2</span>: (-<span class="number">24.22732015246924</span>, <span class="number">2</span>)&#125;</span><br><span class="line">----------</span><br><span class="line">考察词为：来</span><br><span class="line">后一个词概率为：-<span class="number">24.22732015246924</span></span><br><span class="line">当前词概率为：-<span class="number">5.919286514179078</span></span><br><span class="line">【来】概率计算: (-<span class="number">30.146606666648317</span>, <span class="number">1</span>)</span><br><span class="line">考察词为：来到</span><br><span class="line">后一个词概率为：-<span class="number">18.548194315526874</span></span><br><span class="line">当前词概率为：-<span class="number">8.83143534282901</span></span><br><span class="line">【来到】概率计算: (-<span class="number">27.379629658355885</span>, <span class="number">2</span>)</span><br><span class="line">route: &#123;<span class="number">9</span>: (<span class="number">0</span>, <span class="number">0</span>), <span class="number">8</span>: (-<span class="number">8.142626068614787</span>, <span class="number">8</span>), <span class="number">7</span>: (-<span class="number">8.006816355818659</span>, <span class="number">8</span>), <span class="number">6</span>: (-<span class="number">17.53722513662092</span>, <span class="number">6</span>), <span class="number">5</span>: (-<span class="number">11.085007904198626</span>, <span class="number">8</span>), <span class="number">4</span>: (-<span class="number">20.20431518448597</span>, <span class="number">4</span>), <span class="number">3</span>: (-<span class="number">18.548194315526874</span>, <span class="number">4</span>), <span class="number">2</span>: (-<span class="number">24.22732015246924</span>, <span class="number">2</span>), <span class="number">1</span>: (-<span class="number">27.379629658355885</span>, <span class="number">2</span>)&#125;</span><br><span class="line">----------</span><br><span class="line">考察词为：我</span><br><span class="line">后一个词概率为：-<span class="number">27.379629658355885</span></span><br><span class="line">当前词概率为：-<span class="number">5.208223497501194</span></span><br><span class="line">【我】概率计算: (-<span class="number">32.587853155857076</span>, <span class="number">0</span>)</span><br><span class="line">route: &#123;<span class="number">9</span>: (<span class="number">0</span>, <span class="number">0</span>), <span class="number">8</span>: (-<span class="number">8.142626068614787</span>, <span class="number">8</span>), <span class="number">7</span>: (-<span class="number">8.006816355818659</span>, <span class="number">8</span>), <span class="number">6</span>: (-<span class="number">17.53722513662092</span>, <span class="number">6</span>), <span class="number">5</span>: (-<span class="number">11.085007904198626</span>, <span class="number">8</span>), <span class="number">4</span>: (-<span class="number">20.20431518448597</span>, <span class="number">4</span>), <span class="number">3</span>: (-<span class="number">18.548194315526874</span>, <span class="number">4</span>), <span class="number">2</span>: (-<span class="number">24.22732015246924</span>, <span class="number">2</span>), <span class="number">1</span>: (-<span class="number">27.379629658355885</span>, <span class="number">2</span>), <span class="number">0</span>: (-<span class="number">32.587853155857076</span>, <span class="number">0</span>)&#125;</span><br><span class="line">route: &#123;<span class="number">9</span>: (<span class="number">0</span>, <span class="number">0</span>), <span class="number">8</span>: (-<span class="number">8.142626068614787</span>, <span class="number">8</span>), <span class="number">7</span>: (-<span class="number">8.006816355818659</span>, <span class="number">8</span>), <span class="number">6</span>: (-<span class="number">17.53722513662092</span>, <span class="number">6</span>), <span class="number">5</span>: (-<span class="number">11.085007904198626</span>, <span class="number">8</span>), <span class="number">4</span>: (-<span class="number">20.20431518448597</span>, <span class="number">4</span>), <span class="number">3</span>: (-<span class="number">18.548194315526874</span>, <span class="number">4</span>), <span class="number">2</span>: (-<span class="number">24.22732015246924</span>, <span class="number">2</span>), <span class="number">1</span>: (-<span class="number">27.379629658355885</span>, <span class="number">2</span>), <span class="number">0</span>: (-<span class="number">32.587853155857076</span>, <span class="number">0</span>)&#125;</span><br><span class="line">Default Mode: 我/ 来到/ 北京/ 清华大学</span><br></pre></td></tr></table></figure><h3 id="1-3-finalseg-cut"><a href="#1-3-finalseg-cut" class="headerlink" title="1.3 finalseg.cut()"></a>1.3 finalseg.cut()</h3><p>使用维特比算法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__cut</span>(<span class="params">sentence</span>):</span></span><br><span class="line">    <span class="keyword">global</span> emit_P</span><br><span class="line">    prob, pos_list = viterbi(sentence, <span class="string">&#x27;BMES&#x27;</span>, start_P, trans_P, emit_P)</span><br><span class="line">    begin, nexti = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="comment"># print pos_list, sentence</span></span><br><span class="line">    <span class="keyword">for</span> i, char <span class="keyword">in</span> <span class="built_in">enumerate</span>(sentence):</span><br><span class="line">        pos = pos_list[i]</span><br><span class="line">        <span class="keyword">if</span> pos == <span class="string">&#x27;B&#x27;</span>:</span><br><span class="line">            begin = i</span><br><span class="line">        <span class="keyword">elif</span> pos == <span class="string">&#x27;E&#x27;</span>:</span><br><span class="line">            <span class="keyword">yield</span> sentence[begin:i + <span class="number">1</span>]</span><br><span class="line">            nexti = i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> pos == <span class="string">&#x27;S&#x27;</span>:</span><br><span class="line">            <span class="keyword">yield</span> char</span><br><span class="line">            nexti = i + <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> nexti &lt; <span class="built_in">len</span>(sentence):</span><br><span class="line">        <span class="keyword">yield</span> sentence[nexti:]</span><br></pre></td></tr></table></figure><h2 id="特殊修改"><a href="#特殊修改" class="headerlink" title="特殊修改"></a>特殊修改</h2><p>1）jieba.load_userdict 对标点符号失效</p><p><a href="https://github.com/fxsjy/jieba/issues/749">https://github.com/fxsjy/jieba/issues/749</a></p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># user_dict 如&quot;糖类抗原19-9 9999&quot;</span><br><span class="line">import jieba</span><br><span class="line"></span><br><span class="line">jieba.load_userdict(&#x27;user_dict.txt&#x27;)</span><br><span class="line">list(jieba.cut(&#x27;糖类抗原19-9&#x27;)) # [&#x27;糖类&#x27;, &#x27;抗原&#x27;, &#x27;19&#x27;, &#x27;-&#x27;, &#x27;9&#x27;]</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>jieba的__init__.py里面的第43行改成如下所示：<br>re_han_default = re.compile(“([\u4E00-\u9FD5a-zA-Z0-9+#&amp;._%-]+)”, re.U)</p></blockquote><p>2）关键词带空格和特殊字符方法</p><p>参考：<a href="https://github.com/fxsjy/jieba/issues/423">https://github.com/fxsjy/jieba/issues/423</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">免费分享，造损免责。</span><br><span class="line">打开默认词典（根目录）或自定义词典，把所有用来间隔词频和词性的空格间隔符改成@@</span><br><span class="line">（选用@@是因为一般关键词里遇到这个分隔符的几率比较小吧）</span><br><span class="line"></span><br><span class="line">继续，打开jieba根目录下init.py</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 搜索✅</span><br><span class="line">re_han_default = re.<span class="built_in">compile</span>(<span class="string">&quot;([\u4E00-\u9FD5a-zA-Z0-9+#&amp;\._]+)&quot;</span>, re.U)</span><br><span class="line">改成</span><br><span class="line">re_han_default = re.<span class="built_in">compile</span>(<span class="string">&quot;(.+)&quot;</span>, re.U)</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 搜索✅</span><br><span class="line">re_userdict = re.<span class="built_in">compile</span>(<span class="string">&#x27;^(.+?)( [0-9]+)?( [a-z]+)?$&#x27;</span>, re.U)</span><br><span class="line">改成</span><br><span class="line">re_userdict = re.<span class="built_in">compile</span>(<span class="string">&#x27;^(.+?)(\u0040\u0040[0-9]+)?(\u0040\u0040[a-z]+)?$&#x27;</span>, re.U)</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 搜索✅</span><br><span class="line">word, freq = line.split(<span class="string">&#x27; &#x27;</span>)[:<span class="number">2</span>]</span><br><span class="line">改成</span><br><span class="line">word, freq = line.split(<span class="string">&#x27;\u0040\u0040&#x27;</span>)[:<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> 补充：若用的全模式继续改。</span><br><span class="line">搜索</span><br><span class="line">re_han_cut_all = re.<span class="built_in">compile</span>(<span class="string">&quot;([\u4E00-\u9FD5]+)&quot;</span>, re.U)</span><br><span class="line">改成</span><br><span class="line">re_han_cut_all = re.<span class="built_in">compile</span>(<span class="string">&quot;(.+)&quot;</span>, re.U)</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">然后继续打开 posseg  __init__.py</span><br><span class="line"><span class="number">1.</span> 搜索</span><br><span class="line">re_han_internal = re.<span class="built_in">compile</span>(<span class="string">&quot;([\u4E00-\u9FD5a-zA-Z0-9+#&amp;\._]+)&quot;</span>)</span><br><span class="line">替换为：</span><br><span class="line">re_han_internal = re.<span class="built_in">compile</span>(<span class="string">&quot;(.+)&quot;</span>, re.U)</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 搜索</span><br><span class="line">word, _, tag = line.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">替换为：</span><br><span class="line">word, _, tag = line.split(<span class="string">&quot;\u0040\u0040&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>搜索</span><br><span class="line">word, _, tag = line.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">替换为：</span><br><span class="line">word, _, tag = line.split(<span class="string">&quot;\u0040\u0040&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>试验</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#encoding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> unicode_literals</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.append(<span class="string">&quot;../&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line"><span class="keyword">import</span> jieba.posseg</span><br><span class="line"><span class="keyword">import</span> jieba.analyse</span><br><span class="line"></span><br><span class="line">sentence = <span class="string">&quot;我来到北京清华大学c++，并且bav99-w,2?10不错哦&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;=&#x27;</span>*<span class="number">40</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;1. 分词&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;-&#x27;</span>*<span class="number">40</span>)</span><br><span class="line">seg_list = jieba.cut(sentence, cut_all=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Full Mode: &quot;</span> + <span class="string">&quot;/ &quot;</span>.join(seg_list))  <span class="comment"># 全模式</span></span><br><span class="line"></span><br><span class="line">seg_list = jieba.cut(sentence, cut_all=<span class="literal">False</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Default Mode: &quot;</span> + <span class="string">&quot;/ &quot;</span>.join(seg_list))  <span class="comment"># 默认模式</span></span><br><span class="line"></span><br><span class="line">seg_list = jieba.cut(sentence)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;, &quot;</span>.join(seg_list))</span><br><span class="line"></span><br><span class="line">seg_list = jieba.cut_for_search(sentence)  <span class="comment"># 搜索引擎模式</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;, &quot;</span>.join(seg_list))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;=&#x27;</span>*<span class="number">40</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;4. 词性标注&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;-&#x27;</span>*<span class="number">40</span>)</span><br><span class="line"></span><br><span class="line">words = jieba.posseg.cut(sentence)</span><br><span class="line"><span class="keyword">for</span> word, flag <span class="keyword">in</span> words:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s %s&#x27;</span> % (word, flag))</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>原始效果如下：</li></ul><p>dict.txt</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">AT&amp;T 3 nz</span><br><span class="line">B超 3 n</span><br><span class="line">c# 3 nz</span><br><span class="line">C# 3 nz</span><br><span class="line">c++ 3 nz</span><br><span class="line">bav99-w,2?10 3000000 pn</span><br></pre></td></tr></table></figure><p>程序运行结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">========================================</span><br><span class="line"><span class="number">1.</span> 分词</span><br><span class="line">----------------------------------------</span><br><span class="line">Full Mode: 我/ 来/ 到/ 北/ 京/ 清/ 华/ 大/ 学/ c++/ ，/ 并/ 且/ bav99/ -/ w/ ,/ <span class="number">2</span>/ ?/ <span class="number">10</span>/ 不/ 错/ 哦</span><br><span class="line">Default Mode: 我来/ 到/ 北京/ 清华大学/ c++/ ，/ 并且/ bav99/ -/ w/ ,/ <span class="number">2</span>/ ?/ <span class="number">10</span>/ 不错/ 哦</span><br><span class="line">我来, 到, 北京, 清华大学, c++, ，, 并且, bav99, -, w, ,, <span class="number">2</span>, ?, <span class="number">10</span>, 不错, 哦</span><br><span class="line">我来, 到, 北京, 清华大学, c++, ，, 并且, bav99, -, w, ,, <span class="number">2</span>, ?, <span class="number">10</span>, 不错, 哦</span><br><span class="line">========================================</span><br><span class="line"><span class="number">4.</span> 词性标注</span><br><span class="line">----------------------------------------</span><br><span class="line">我 r</span><br><span class="line">来 v</span><br><span class="line">到 v</span><br><span class="line">北京 ns</span><br><span class="line">清华大学 nt</span><br><span class="line">c++ nz</span><br><span class="line">， x</span><br><span class="line">并且 c</span><br><span class="line">bav99 eng</span><br><span class="line">- x</span><br><span class="line">w x</span><br><span class="line">, x</span><br><span class="line"><span class="number">2</span> x</span><br><span class="line">? x</span><br><span class="line"><span class="number">10</span> m</span><br><span class="line">不错 a</span><br><span class="line">哦 e</span><br></pre></td></tr></table></figure><ul><li>改完后效果：</li></ul><p>dict.txt变为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AT&amp;T@@3@@nz</span><br><span class="line">B超@@3@@n</span><br><span class="line">c#@@3@@nz</span><br><span class="line">C#@@3@@nz</span><br><span class="line">c++@@3@@nz</span><br><span class="line">bav99-w,2?10@@3@@pn</span><br><span class="line">bav99-w,2?1 0@@3@@pn</span><br></pre></td></tr></table></figure><p>程序运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">========================================</span><br><span class="line"><span class="number">1.</span> 分词</span><br><span class="line">----------------------------------------</span><br><span class="line">Full Mode: 我/ 来/ 到/ 北/ 京/ 清/ 华/ 大/ 学/ c++/ ，/ 并/ 且/ bav99-w,<span class="number">2</span>?<span class="number">1</span> <span class="number">0</span>/ 不/ 错/ 哦</span><br><span class="line">Default Mode: 我来/ 到/ 北京/ 清华大学/ c++/ ，/ 并且/ bav99-w,<span class="number">2</span>?<span class="number">1</span> <span class="number">0</span>/ 不错/ 哦</span><br><span class="line">我来, 到, 北京, 清华大学, c++, ，, 并且, bav99-w,<span class="number">2</span>?<span class="number">1</span> <span class="number">0</span>, 不错, 哦</span><br><span class="line">我来, 到, 北京, 清华大学, c++, ，, 并且, bav99-w,<span class="number">2</span>?<span class="number">1</span> <span class="number">0</span>, 不错, 哦</span><br><span class="line">========================================</span><br><span class="line"><span class="number">4.</span> 词性标注</span><br><span class="line">----------------------------------------</span><br><span class="line">我 r</span><br><span class="line">来 v</span><br><span class="line">到 v</span><br><span class="line">北京 ns</span><br><span class="line">清华大学 nt</span><br><span class="line">c++ nz</span><br><span class="line">， x</span><br><span class="line">并且 c</span><br><span class="line">bav99-w,<span class="number">2</span>?<span class="number">1</span> <span class="number">0</span> pn</span><br><span class="line">不错 a</span><br><span class="line">哦 e</span><br></pre></td></tr></table></figure><p>甚至，<code>bav99-w,2?10</code> 变为<code>bav99-w,2?1 0</code>依旧没有问题</p><ul><li>加载自定义词库太慢的问题</li></ul><blockquote><p>修改完jieba默认词库,就不需要再使用 <strong>jieba.load_userdict</strong> 方法去加载自定义词库了。省去了大笔自定义词库加载的时间成本。</p></blockquote><p><a href="https://www.jianshu.com/p/dbaa4421b4ce">解决jieba分词 load_userdict 加载自定义词库太慢的问题</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://www.jianshu.com/p/d232d344e23f">jieba分词原理</a></li><li><a href="https://blog.csdn.net/miner_zhu/article/details/83246153">NLP之jieba分词原理简析</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;



&lt;h2 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;基于前缀词典实现高效的词图扫描，生成句子中汉字所有可能成词情况所构成的有向</summary>
      
    
    
    
    <category term="NLP" scheme="http://example.com/categories/NLP/"/>
    
    
    <category term="分词" scheme="http://example.com/tags/%E5%88%86%E8%AF%8D/"/>
    
  </entry>
  
  <entry>
    <title>⭐️数据结构与算法之美（加餐）</title>
    <link href="http://example.com/2021/04/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%EF%BC%88%E5%8A%A0%E9%A4%90%EF%BC%89/"/>
    <id>http://example.com/2021/04/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%EF%BC%88%E5%8A%A0%E9%A4%90%EF%BC%89/</id>
    <published>2021-04-03T16:00:00.000Z</published>
    <updated>2022-01-15T15:41:57.607Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="不定期福利第一期-数据结构与算法学习书单"><a href="#不定期福利第一期-数据结构与算法学习书单" class="headerlink" title="不定期福利第一期 | 数据结构与算法学习书单"></a>不定期福利第一期 | 数据结构与算法学习书单</h2><p>王争 2018-09-30</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp84d2959kj30vq0hsacb.jpg" alt="img"></p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADYAAAABCAYAAACVOl3IAAAAJUlEQVQYV2N89+7df0FBQQYQeP/+PZgGAUJilMpjs4dSM5H1AwBwSSrLZGasMwAAAABJRU5ErkJggg==" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAABCAYAAADeko4lAAAAHUlEQVQYV2N89+7dfwYoEBQUBLPev3/PgItNSC0ADtASy+rFJtUAAAAASUVORK5CYII=" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADoAAAABCAYAAACPBr1GAAAAJ0lEQVQYV2N89+7dfwYoEBQUBLPev3/PQAkbm3mE7KBUHpd7YeYCAE50MMsBeqQ5AAAAAElFTkSuQmCC" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAABCAYAAAAB3PQ6AAAAHUlEQVQYV2N89+7df0FBQQYQeP/+PQMxbLBiIAAAQE0Py6Kq0rkAAAAASUVORK5CYII=" alt="img"></p><p>你好，我是王争。欢迎来到不定期更新的周末福利时间。</p><p>专栏已经上线两周了，看到这么多人在留言区写下自己的疑惑或者观点，我特别开心。在留言里，很多同学让我推荐一些学习数据结构与算法的书籍。因此我特意跟编辑商量了，给你一个周末福利。所以这一期呢，我们就来聊一聊数据结构和算法学习过程中有哪些必读书籍。</p><p>有的同学还在读大学，代码还没写过几行；有的同学已经工作数十年，这之间的差别还是挺大的。而不同基础的人，适宜看的书是完全不一样的。因此，<strong>针对不同层次、不同语言的同学，我分别推荐了不同的书</strong>。希望每个同学，都能找到适合自己的学习资料，都能在现有水平上有所提高。</p><h3 id="针对入门的趣味书"><a href="#针对入门的趣味书" class="headerlink" title="针对入门的趣味书"></a>针对入门的趣味书</h3><p>入门的同学，我建议你不要过度追求上去就看经典书。像《算法导论》《算法》这些书，虽然比较经典、比较权威，但是非常厚。初学就去啃这些书肯定会很费劲。而一旦啃不下来，挫败感就会很强。所以，入门的同学，我建议你找一些比较容易看的书来看，比如《大话数据结构》和《算法图解》。<strong>不要太在意书写得深浅，重要的是能不能坚持看完。</strong></p><p>《<strong>大话数据结构</strong>》 这本书最大的特点是，它把理论讲得很有趣，不枯燥。而且每个数据结构和算法，作者都结合生活中的例子进行了讲解，能让你有非常直观的感受。虽然这本书有 400 多页，但是花两天时间读完，应该是没问题的。如果你之前完全不懂数据结构和算法，可以先从这本书看起。</p><p>《<strong>算法图解</strong>》 跟《大话数据结构》走的是同样的路线，就像这本书副标题写的那样，“像小说一样有趣的算法入门书”，主打“图解”，通俗易懂。它只有不到 200 页，所以内容比较少。作为入门，看看这本书，能让你对数据结构和算法有个大概的认识。</p><p>这些入门书共同的问题是，缺少细节，不够系统，也不够严谨。所以，如果你想要系统地学数据结构和算法，看这两本书肯定是不够的。</p><h3 id="针对特定编程语言的教科书"><a href="#针对特定编程语言的教科书" class="headerlink" title="针对特定编程语言的教科书"></a>针对特定编程语言的教科书</h3><p>讲数据结构和算法，肯定会跟代码实现挂钩。所以，很多人就很关心，某某书籍是用什么语言实现的，是不是自己熟悉的语言。市面大部分数据结构和算法书籍都是用 C、C++、Java 语言实现的，还有些是用伪代码。而使用 Python、Go、PHP、JavaScript、Objective-C 这些编程语言实现的就更少了。</p><p>我这里推荐《数据结构和算法分析》。国内外很多大学都拿这本书当作教材。这本书非常系统、全面、严谨，而且又不是特别难，适合对数据结构和算法有些了解，并且掌握了至少一门编程语言的同学。而且，这个作者也很用心。他用了三种语言，写了三个版本，分别是：《<strong>数据结构与算法分析 ：C 语言描述</strong>》《<strong>数据结构与算法分析：C++ 描述</strong>》《<strong>数据结构与算法分析：Java 语言描述</strong>》。</p><p>如果你熟悉的是 Python 或者 JavaScript，可以参考《<strong>数据结构与算法 JavaScript 描述</strong>》《<strong>数据结构与算法：Python 语言描述</strong>》 。至于其他语言的算法书籍，确实比较少。如果你有推荐，可以在留言区补充一下。</p><h3 id="面试必刷的宝典"><a href="#面试必刷的宝典" class="headerlink" title="面试必刷的宝典"></a>面试必刷的宝典</h3><p>算法对面试很重要，很多人也很关心。我这里推荐几本有益于面试的书籍，分别是：《剑指 offer》《编程珠玑》《编程之美》。</p><p>从《<strong>剑指 offer</strong>》这本书的名字就可以看出，作者的写作目的非常明确，就是为了面试。这本书几乎包含了所有常见的、经典的面试题。如果能搞懂这本书里的内容，应付一般公司的面试应该不成问题。</p><p>《<strong>编程珠玑</strong>》这本书的豆瓣评分非常高，有 9 分。这本书最大的特色就是讲了很多针对海量数据的处理技巧。这个可能是其他算法书籍很少涉及的。面试的时候，海量数据处理的问题也是经常会问的，特别是校招面试。不管是开拓眼界，还是应付面试，这本书都很值得一看。</p><p>《<strong>编程之美</strong>》这本书有多位作者，其中绝大部分是微软的工程师，所以书的质量很有保证。不过，这里面的算法题目稍微有点难，也不是很系统，这也是我把它归到面试这一部分的原因。如果你有一定基础，也喜欢钻研些算法问题，或者要面试 Google、Facebook 这样的公司，可以拿这本书里的题，先来自测一下。</p><h3 id="经典大部头"><a href="#经典大部头" class="headerlink" title="经典大部头"></a>经典大部头</h3><p>很多人一提到算法书就会搬出《算法导论》和《算法》。这两本确实非常经典，但是都太厚了，看起来比较费劲，我估计很少有人能坚持全部看下来。如果你想更加深入地学一学数据结构和算法，我还是强烈建议你看看。</p><p>我个人觉得，《<strong>算法导论</strong>》这本书的章节安排不是循序渐进的，里面充斥着各种算法的正确性、复杂度的证明、推导，数学公式比较多，一般人看起来会比较吃力。所以，作为入门书籍，并不是很推荐。</p><p>《<strong>算法</strong>》这本书也是一本经典大部头，不过它比起《算法导论》来要友好很多，更容易看懂，更适合初学者入门。但是这本书的缺点也很明显，就是内容不够全面，比如动态规划这么重要的知识点，这本书就没有讲。对于数据结构的东西，它讲的也不多，基本就是偏重讲算法。</p><h3 id="殿堂级经典"><a href="#殿堂级经典" class="headerlink" title="殿堂级经典"></a>殿堂级经典</h3><p>说到殿堂级经典书，如果《<strong>计算机程序设计艺术</strong>》称第二，我想没人敢称第一。这本书包括很多卷。说实话，我也只看过比较简单的几卷，比如《基本算法》《排序和查找》。</p><p>这套书的深度、广度、系统性、全面性是其他所有数据结构和算法书籍都无法相比的。但是，如果你对算法和数据结构不是特别感兴趣，没有很好的数学、算法、计算机基础，想要把这套书读完、读懂是比较难的。你可以把它当作你算法学习的终极挑战。</p><h3 id="闲暇阅读"><a href="#闲暇阅读" class="headerlink" title="闲暇阅读"></a>闲暇阅读</h3><p>算法无处不在。我这里再推荐几本适合闲暇时间阅读的书：《<strong>算法帝国</strong>》《<strong>数学之美</strong>》《<strong>算法之美</strong>》。</p><p>这些书共同的特点是，都列举了大量的例子，非常通俗易懂。夸张点说，像《算法帝国》，文科生都能读懂。当你看这些书的时候，你常常会深深感受到算法的力量，被算法的优美之处折服。即便不是从事 IT 工作的，看完这几本书也可以开拓眼界。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp84cy0f32j30vq0na0x1.jpg" alt="img"></p><p>书籍差不多就是这些。除此之外，留言区很多人问到算法的实现语言。我这里也解释一下。因为我现在比较常用的编程语言是 Java。所以，在专栏里，特别简单的、不涉及高级语法的，我会用 Java 或者 C、C++ 来实现。稍微复杂的，为了让你能看懂，我会用伪代码。所以你完全不用担心语言的问题。</p><p>每节课中有需要代码实现的数据结构和算法，我都另外用 Java 语言实现一遍，然后放到 Github 上，供你参考。Github 的地址我放在这里，你可以收藏一下：<a href="https://github.com/wangzheng0822/algo%E3%80%82">https://github.com/wangzheng0822/algo。</a></p><p>至于其他语言的同学，比如 C、C++、Python、Go、PHP、JavaScript、Objective-C 等，我想了一个 crowd sourcing 的方法。</p><p>我希望基础较好的同学，参照我的 Java 实现，用你熟悉的编程语言再实现一遍，并且将代码留言给我。如果你写得正确，我会将你的代码上传到 Github 上，分享给更多人。</p><p>还有人问，我学完这个专栏，就可以拿下数据结构和算法吗？我想说的是，<strong>每个人的基础、学习能力都不一样，掌握程度取决于你的努力程度</strong>。除了你之外，没有人能百分之百保证你能掌握什么知识。</p><p>有的同学只是把每一节课听下来、看下来，就束之高阁，也不求甚解，那效果肯定会很差。而有些同学除了听、看之外，遇到不懂的会自己去查资料、看参考书籍，还会把我讲的数据结构和算法都认真地实现一遍，这样的学习效果自然就比只听一遍、看一遍要好很多。即便我已经尽我所能把这些知识讲得深入浅出，通俗易懂，但是学习依然还是要靠你自己啊。</p><p>这种答疑的方式也会成为我们之后的固定动作，我会把留言里有价值的问题和反馈沉淀下来，希望对你的日常学习起到补充作用。<strong>如果你有什么看不懂、听不懂的地方，或者工作中有遇到算法问题、技术难题，欢迎写在留言区。</strong>（我发现留言区里卧虎藏龙啊，没事儿可以多扫扫留言区。）</p><p>这次的周末福利时间就到这啦，我们下次见！</p><h2 id="不定期福利第二期-王争：羁绊前行的，不是肆虐的狂风，而是内心的迷茫"><a href="#不定期福利第二期-王争：羁绊前行的，不是肆虐的狂风，而是内心的迷茫" class="headerlink" title="不定期福利第二期 | 王争：羁绊前行的，不是肆虐的狂风，而是内心的迷茫"></a>不定期福利第二期 | 王争：羁绊前行的，不是肆虐的狂风，而是内心的迷茫</h2><p>王争 2018-11-23</p><p><img src="https://static001.geekbang.org/resource/image/1f/85/1fca022ef82d07dcb93cd173026d7385.jpg" alt="img"></p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADYAAAABCAYAAACVOl3IAAAAJUlEQVQYV2N89+7df0FBQQYQeP/+PZgGAUJilMpjs4dSM5H1AwBwSSrLZGasMwAAAABJRU5ErkJggg==" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAABCAYAAADeko4lAAAAHUlEQVQYV2N89+7dfwYoEBQUBLPev3/PgItNSC0ADtASy+rFJtUAAAAASUVORK5CYII=" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADoAAAABCAYAAACPBr1GAAAAJ0lEQVQYV2N89+7dfwYoEBQUBLPev3/PQAkbm3mE7KBUHpd7YeYCAE50MMsBeqQ5AAAAAElFTkSuQmCC" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAABCAYAAAAB3PQ6AAAAHUlEQVQYV2N89+7df0FBQQYQeP/+PQMxbLBiIAAAQE0Py6Kq0rkAAAAASUVORK5CYII=" alt="img"></p><p>专栏更新过半，我发现有些小伙伴已经掉队，虽然有人掉队也挺正常，但是我还是想尽量拉一把。于是，周末的时间，我就在想，究竟是什么原因让有些小伙伴掉队了？是内容本身太难了吗？是我讲得不够清楚吗？还是小伙伴本身基础太差、不够努力、没有掌握学习方法？</p><p>我觉得都不是，让你掉队的原因，从根儿上讲，是你内心的迷茫。<strong>如果我们不那么确信能不能看懂、能不能学会的时候，当面对困难的时候，很容易就会否定自己，也就很容易半途而废</strong>。</p><p>这就好比你迷失在沙漠中，对你来说，肆虐的狂风并不可怕，可怕的是，你不知道该努力多久才能走出沙漠，不知道到底能不能走出沙漠。这种对结果的未知、不确定，导致了你内心的恐惧，最后就差那么一点点就可以走出沙漠的时候，你放弃了。</p><p>学习也是同样的道理。所以，<strong>我今天不打算讲学习方法，也不打算给你灌输心灵鸡汤，我就讲讲，对这个专栏的学习，或者对于任何学习来说，我觉得你应该建立的一些正确认知。</strong>有了这些认知，希望你能在后面的专栏学习中，少一点迷茫，多一份坚持。</p><h3 id="没有捷径，没有杀手锏，更没有一招致胜的“葵花宝典”"><a href="#没有捷径，没有杀手锏，更没有一招致胜的“葵花宝典”" class="headerlink" title="没有捷径，没有杀手锏，更没有一招致胜的“葵花宝典”"></a>没有捷径，没有杀手锏，更没有一招致胜的“葵花宝典”</h3><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp7wq9togjj30vq0k5adv.jpg" alt="img"></p><p>有小伙伴给我留言说：“看书五分钟，笔记两小时，急求学霸的学习方法”，还有人问，“数据结构和算法好难，到底该怎么学？是我的学习方法不对？还是我太笨？”</p><p>我想说，并没有什么杀手锏的学习方法，更没有一招致胜的“葵花宝典”。不知道这么说有没有让你失望。<strong>如果你真要“求”一个学习方法，那就再看看我在专栏开始写的“<strong><strong>如何抓住重点，系统高效地学习数据结构与算法</strong></strong>”那篇文章吧</strong>。</p><p>说实话，我也挺想知道学霸的学习方法的，所以，在求学路上，每当有学霸来分享学习方法，我都要去听一听。但是，听多了之后，我发现其实并没有太多用。因为那些所谓学霸的学习方法，其实都很简单，比如“认认真真听讲”“认认真真做每一道题”等等。</p><p>也不是他们说的不对，但是这种大实话，我总有一种领会不了的感觉，更别说真正指导我的学习了。而且，我觉得，很多时候，<strong>这些方法论的难点并不在于能不能听懂，而是在于能不能执行到位</strong>。比如很多人都听过“一万小时定律”，坚持一万个小时，你就能成为大牛，但有多少人能坚持一万个小时呢？</p><p>所以，这里我要纠正一个认知，那就是，学习没有“杀手锏”似的方法论。不要怀疑是不是自己的学习方法不对，不要在开始就否定自己。因为否定得越多，你就越迷茫，越不能坚持。</p><h3 id="不要浮躁，不要丧失思考能力，不要丧失学习能力"><a href="#不要浮躁，不要丧失思考能力，不要丧失学习能力" class="headerlink" title="不要浮躁，不要丧失思考能力，不要丧失学习能力"></a>不要浮躁，不要丧失思考能力，不要丧失学习能力</h3><p><img src="https://static001.geekbang.org/resource/image/8c/ca/8c1963cc2a871f4c2de8631d4f8684ca.jpg" alt="img"></p><p>有小伙伴给我留言说：“老师，这个地方看不懂，你能不能再解释一下”，还有小伙伴留言说：“《红黑树（上）》里的图为什么跟你的定义不相符？”</p><p>对于留言的问题，我都挺重视的，但是当仔细看这些问题的时候，我发现，实际上文章里已经有答案了，他根本没有认真看、认真思考，更别说去自己搜搜资料，再研究下，就来提问了。</p><p>一般情况下，我都会回复“你自己再认真看一遍”或者“你自己先去网上搜一下，研究研究，如果还不懂再给我留言”。告诉你答案，并不会花费我太长时间，但是，这样会让你丢失最宝贵的东西，那就是，你自己的思考能力、学习能力，能自己沉下心来研究的能力。这个是很可怕的。</p><p>现在，互联网如此发达，我们每天都会面对各种各样的信息轰炸，人也变得越来越浮躁。很多人习惯看些不动脑子就能看懂的东西，看到稍微复杂的东西，就感觉脑子转不动了。</p><p>上学的时候还好，要考试，有老师督促，还能坚持学习。但是工作之后，没有人监督，很多人陷入各种手机 App 中不能自拔，学一会儿就想玩会儿手机，想静下心来学上半个小时都无比困难。无法自律，沉不下心来，那你就基本可以跟学习说拜拜了。</p><h3 id="只有做好打硬仗的心理准备，遇到困难才能心态平和"><a href="#只有做好打硬仗的心理准备，遇到困难才能心态平和" class="headerlink" title="只有做好打硬仗的心理准备，遇到困难才能心态平和"></a>只有做好打硬仗的心理准备，遇到困难才能心态平和</h3><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp84deegnlj30vq0kln00.jpg" alt="img"></p><p>还有小伙伴给我留言说：“看不懂，一个 4000 多字的文章、10 分钟的音频，反复看了、听了 2 个小时都没怎么看懂”。我给他的回复是：“<strong>如果之前没有基础或者基础不好的话，看 2 个小时还不懂，很正常，看一个礼拜试试。</strong>”</p><p>“一个礼拜”的说法，我一点都不是夸张。虽然专栏的每篇文章都只有三四千字，10 分钟左右的音频，但是知识点的密度还是很高的。如果你潜意识里觉得应该一下子就能看懂，就会出现这样的情况：看了一遍不懂，又看了一遍还是不怎么懂，然后就放弃了。</p><p>数据结构和算法就是一个非常难啃的硬骨头，可以说是计算机学科中最难学的学科之一了。<strong>我当时学习也费了老大的劲，能做到讲给你听，我靠的也是十年如一的积累和坚持</strong>。如果没有基础、或者基础不好，你怎能期望看 2 个小时就能完全掌握呢？</p><p>面对这种硬骨头，我觉得我们要有打硬仗、打持久战的心理准备。只有这样，在学习的过程中遇到困难的时候，心态才能更加平和，才能沉下心来有条不紊地去解决一个个的疑难问题。这样，碰到问题，你可能还会“窃喜”，我又遇到了一个之前不怎么懂的知识点了，看懂它我又进步了一点。甚至你还会“坏坏地”想，又多了一个拉开我跟其他人距离的地方了。跨过这些点，我就能比别人更厉害。</p><p>一口吃不成胖子，如果你基础不好，那就从长计议吧，给自己定一个长一点的“死磕”计划，比如一年。面对不懂的知识点，沉下心来逐个突破，这样你的信心慢慢也就建立了。</p><h3 id="“放弃”的念头像是一个心魔，它会一直围绕着你"><a href="#“放弃”的念头像是一个心魔，它会一直围绕着你" class="headerlink" title="“放弃”的念头像是一个心魔，它会一直围绕着你"></a>“放弃”的念头像是一个心魔，它会一直围绕着你</h3><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp84cwvac1j30vq0jywhr.jpg" alt="img"></p><p>还有小伙伴给我留言说：“开始没怎么看懂，看了一下午，终于看懂了”。看到这样的留言，我其实挺为他感到庆幸的，庆幸他没有中途放弃。因为，放弃的念头就像一个心魔，在我们的学习过程中，它会一直围绕着我们，一旦被它打败一次，你就会被它打败很多次，掉队就不可避免了。</p><p>我分享一个我最近思考比较多的事情。前一段时间，我在研究多线程方面的东西，它涉及一块比较复杂的内容，“Java 内存模型”。虽然看懂并不难，但是要透彻、无盲点地理解并不容易。本来以为半天就能看懂的东西，结果我从周一一直看到周五下午，断断续续花了 5 天的时间才把它彻底搞懂。回忆起这 5 天，我有不下 10 次都想放弃，每次心里都在想：“算了，先放一放，以后再说吧”“太难了，啃不下来，算了。”“就这样吧，反正也用不到，没必要浪费时间”等等。这种放弃的念头就像一个邪恶的魔鬼一样，一直围绕着我这 5 天的研究中。</p><p>现在回想起来，我很庆幸我当时没有放弃，多坚持了几天。如果当时我放弃了，那之后再遇到技术难题时，“放弃”的心魔还会再来拜访我，潜意识里我还是会认输。</p><p>之所以没有放弃，我自己总结了两点原因。</p><p>第一，我对学习这件事情认识得比较清楚，我一直觉得，没有学不会的东西，没有攻克不了的技术难题，如果有，那就说明时间花得还不够多。</p><p>第二，我之前遇到卡壳的时候，几乎从来没有放弃过，即便短暂地停歇，我也会继续拎起来再死磕，而且每次都能搞定，正是这种正向的激励，给了我信心，让我再遇到困难的时候，都能坚信自己能搞定它。</p><h3 id="入门是一个非常漫长和煎熬的过程，谁都逃不过"><a href="#入门是一个非常漫长和煎熬的过程，谁都逃不过" class="headerlink" title="入门是一个非常漫长和煎熬的过程，谁都逃不过"></a>入门是一个非常漫长和煎熬的过程，谁都逃不过</h3><p><img src="https://static001.geekbang.org/resource/image/c3/67/c3db74036668f2d279e9a4a7b8468167.jpg" alt="img"></p><p>还有小伙伴留言说：“看到有小伙伴有很多疑问，我来帮作者说句话，文章写得很好，通俗易懂，如果有一定基础，看懂还是不成问题的。”</p><p>我觉得，有些小伙伴的觉悟还是挺高的：）。我文章写得再通俗易懂，对于之前没有任何基础的人来说，看起来还是挺费劲的。</p><p>第一，数据结构和算法这门课程本身的难度摆在那里，想要轻松看懂，本身就不太现实。第二，对于任何新知识的学习，入门都是一个非常漫长和煎熬的过程。但是这个过程都是要经历的，谁都逃不过。只要你挺过去，入了门，再学习更深的知识就简单多了。</p><p>我大学里的第一堂课是 C 语言，现在回想起来，当时对我来说，简直就是听天书。因为之前没有接触过计算机，更别说编程语言，对我来说，C 语言就像另一个世界的东西。从完全看不懂，到慢慢有点看懂，再到完全看懂，不夸张地讲，我花了好几年的时间，但是当掌握了之后，我发现这个东西其实也不难。但是如果没有度过漫长和煎熬的入门的过程，如果没有一点韧性，没有一点点信念，那可能也没有现在的我了。</p><p>其实我一直觉得<strong>情商比智商更重要</strong>。对于很多学科的学习，智商并不是瓶颈，最终能够决定你能达到的高度的，还是情商，而情商中最重要的，我觉得就是<strong>逆商</strong>（逆境商数，Adversity Quotient），也就是，<strong>当你遇到困难时，你会如何去面对，这将会决定你的人生最终能够走多远。</strong></p><p><img src="https://static001.geekbang.org/resource/image/56/c2/56db1ff64199a020ef376187f75304c2.jpg" alt="img"></p><p>好了，今天我想分享的关于学习的几个认知就讲完了。现在，你有没有对学习这件事有更加清晰的认识呢？能不能让你少一点迷茫，多一份坚持呢？</p><p>最后，我有一句送给你：吃得苦中苦，方为人上人。耐得住寂寞，才能守得住繁华。</p><h2 id="不定期福利第三期-测一测你的算法阶段学习成果"><a href="#不定期福利第三期-测一测你的算法阶段学习成果" class="headerlink" title="不定期福利第三期 | 测一测你的算法阶段学习成果"></a>不定期福利第三期 | 测一测你的算法阶段学习成果</h2><p>王争 2018-12-21</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp7wu2xk8qj30vq0hs41j.jpg" alt="img"></p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADYAAAABCAYAAACVOl3IAAAAJUlEQVQYV2N89+7df0FBQQYQeP/+PZgGAUJilMpjs4dSM5H1AwBwSSrLZGasMwAAAABJRU5ErkJggg==" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAABCAYAAADeko4lAAAAHUlEQVQYV2N89+7dfwYoEBQUBLPev3/PgItNSC0ADtASy+rFJtUAAAAASUVORK5CYII=" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADoAAAABCAYAAACPBr1GAAAAJ0lEQVQYV2N89+7dfwYoEBQUBLPev3/PQAkbm3mE7KBUHpd7YeYCAE50MMsBeqQ5AAAAAElFTkSuQmCC" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAABCAYAAAAB3PQ6AAAAHUlEQVQYV2N89+7df0FBQQYQeP/+PQMxbLBiIAAAQE0Py6Kq0rkAAAAASUVORK5CYII=" alt="img"></p><p>专栏最重要的基础篇马上就要讲完了，不知道你掌握了多少？我从前面的文章中挑选了一些案例，稍加修改，组成了一套测试题。</p><p>你先不要着急看答案，自己先想一想怎么解决，测一测自己对之前的知识掌握的程度。如果有哪里卡壳或者不怎么清楚的，可以回过头再复习一下。</p><p>正所谓温故知新，这种通过实际问题查缺补漏的学习方法，非常利于你巩固前面讲的知识点，你可要好好珍惜这次机会哦！</p><h3 id="实战测试题（一）"><a href="#实战测试题（一）" class="headerlink" title="实战测试题（一）"></a>实战测试题（一）</h3><p>假设猎聘网有 10 万名猎头顾问，每个猎头顾问都可以通过做任务（比如发布职位），来积累积分，然后通过积分来下载简历。<strong>假设你是猎聘网的一名工程师，如何在内存中存储这 10 万个猎头 ID 和积分信息，让它能够支持这样几个操作：</strong></p><p>根据猎头的 ID 快速查找、删除、更新这个猎头的积分信息；</p><p>查找积分在某个区间的猎头 ID 列表；</p><p>查询积分从小到大排在第 x 位的猎头 ID 信息；</p><p>查找按照积分从小到大排名在第 x 位到第 y 位之间的猎头 ID 列表。</p><h3 id="相关章节"><a href="#相关章节" class="headerlink" title="相关章节"></a>相关章节</h3><p>17 | 跳表：为什么 Redis 一定要用跳表来实现有序集合？</p><p>20 | 散列表（下）：为什么散列表和链表经常会一起使用？</p><p>25 | 红黑树：为什么工程中都用红黑树这种二叉树？</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><p>这个问题既要通过 ID 来查询，又要通过积分来查询，所以，对于猎头这样一个对象，我们需要将其组织成两种数据结构，才能支持这两类操作。</p><p>我们按照 ID，将猎头信息组织成散列表。这样，就可以根据 ID 信息快速地查找、删除、更新猎头的信息。我们按照积分，将猎头信息组织成跳表这种数据结构，按照积分来查找猎头信息，就非常高效，时间复杂度是 O(logn)。</p><p>我刚刚讲的是针对第一个、第二个操作的解决方案。第三个、第四个操作是类似的，按照排名来查询，这两个操作该如何实现呢？</p><p>我们可以对刚刚的跳表进行改造，每个索引结点中加入一个 span 字段，记录这个索引结点到下一个索引结点的包含的链表结点的个数。这样就可以利用跳表索引，快速计算出排名在某一位的猎头或者排名在某个区间的猎头列表。</p><p>实际上，这些就是 Redis 中有序集合这种数据类型的实现原理。在开发中，我们并不需要从零开始代码实现一个散列表和跳表，我们可以直接利用 Redis 的有序集合来完成。</p><h3 id="实战测试题（二）"><a href="#实战测试题（二）" class="headerlink" title="实战测试题（二）"></a>实战测试题（二）</h3><p>电商交易系统中，订单数据一般都会很大，我们一般都分库分表来存储。假设我们分了 10 个库并存储在不同的机器上，在不引入复杂的分库分表中间件的情况下，我们希望开发一个小的功能，能够快速地查询金额最大的前 K 个订单（K 是输入参数，可能是 1、10、1000、10000，假设最大不会超过 10 万）。<strong>如果你是这个功能的设计开发负责人，你会如何设计一个比较详细的、可以落地执行的设计方案呢？</strong></p><p>为了方便你设计，我先交代一些必要的背景，在设计过程中，如果有其他需要明确的背景，你可以自行假设。</p><p>数据库中，订单表的金额字段上建有索引，我们可以通过 select order by limit 语句来获取数据库中的数据；</p><p>我们的机器的可用内存有限，比如只有几百 M 剩余可用内存。希望你的设计尽量节省内存，不要发生 Out of Memory Error。</p><h3 id="相关章节-1"><a href="#相关章节-1" class="headerlink" title="相关章节"></a>相关章节</h3><p>12 | 排序（下）：如何用快排思想在 O(n) 内查找第 K 大元素？</p><p>28 | 堆和堆排序：为什么说堆排序没有快速排序快？</p><p>29 | 堆的应用：如何快速获取到 Top 10 最热门的搜索关键词？</p><h3 id="题目解析-1"><a href="#题目解析-1" class="headerlink" title="题目解析"></a>题目解析</h3><p>解决这个题目的基本思路我想你应该能想到，就是借助归并排序中的合并函数，这个我们在排序（下）以及堆的应用那一节中讲过。</p><p>我们从每个数据库中，通过 select order by limit 语句，各取局部金额最大的订单，把取出来的 10 个订单放到优先级队列中，取出最大值（也就是大顶堆堆顶数据），就是全局金额最大的订单。然后再从这个全局金额最大订单对应的数据库中，取出下一条订单（按照订单金额从大到小排列的），然后放到优先级队列中。一直重复上面的过程，直到找到金额前 K（K 是用户输入的）大订单。</p><p>从算法的角度看起来，这个方案非常完美，但是，从实战的角度来说，这个方案并不高效，甚至很低效。因为我们忽略了，数据库读取数据的性能才是这个问题的性能瓶颈。所以，我们要尽量减少 SQL 请求，每次多取一些数据出来，那一次性取出多少才合适呢？这就比较灵活、比较有技巧了。一次性取太多，会导致数据量太大，SQL 执行很慢，还有可能触发超时，而且，我们题目中也说了，内存有限，太多的数据加载到内存中，还有可能导致 Out of Memory Error。</p><p>所以，一次性不能取太多数据，也不能取太少数据，到底是多少，还要根据实际的硬件环境做 benchmark 测试去找最合适的。</p><h3 id="实战测试题（三）"><a href="#实战测试题（三）" class="headerlink" title="实战测试题（三）"></a>实战测试题（三）</h3><p>我们知道，CPU 资源是有限的，任务的处理速度与线程个数并不是线性正相关。相反，过多的线程反而会导致 CPU 频繁切换，处理性能下降。所以，线程池的大小一般都是综合考虑要处理任务的特点和硬件环境，来事先设置的。</p><p><strong>当我们向固定大小的线程池中请求一个线程时，如果线程池中没有空闲资源了，这个时候线程池如何处理这个请求？是拒绝请求还是排队请求？各种处理策略又是怎么实现的呢？</strong></p><h3 id="相关章节-2"><a href="#相关章节-2" class="headerlink" title="相关章节"></a>相关章节</h3><p>09 | 队列：队列在线程池等有限资源池中的应用</p><h3 id="题目解析-2"><a href="#题目解析-2" class="headerlink" title="题目解析"></a>题目解析</h3><p>这个问题的答案涉及队列这种数据结构。队列可以应用在任何有限资源池中，用于排队请求，比如数据库连接池等。实际上，对于大部分资源有限的场景，当没有空闲资源时，基本上都可以通过“队列”这种数据结构来实现请求排队。</p><p>这个问题的具体答案，在队列那一节我已经讲得非常详细了，你可以回去看看，这里我就不赘述了。</p><h3 id="实战测试题（四）"><a href="#实战测试题（四）" class="headerlink" title="实战测试题（四）"></a>实战测试题（四）</h3><p>通过 IP 地址来查找 IP 归属地的功能，不知道你有没有用过？没用过也没关系，你现在可以打开百度，在搜索框里随便输一个 IP 地址，就会看到它的归属地。</p><p>这个功能并不复杂，它是通过维护一个很大的 IP 地址库来实现的。地址库中包括 IP 地址范围和归属地的对应关系。比如，当我们想要查询 202.102.133.13 这个 IP 地址的归属地时，我们就在地址库中搜索，发现这个 IP 地址落在[202.102.133.0, 202.102.133.255]这个地址范围内，那我们就可以将这个 IP 地址范围对应的归属地“山东东营市”显示给用户了。</p><p>[202.102.133.0, 202.102.133.255]  山东东营市 </p><p>[202.102.135.0, 202.102.136.255]  山东烟台 </p><p>[202.102.156.34, 202.102.157.255] 山东青岛 </p><p>[202.102.48.0, 202.102.48.255] 江苏宿迁 </p><p>[202.102.49.15, 202.102.51.251] 江苏泰州 </p><p>[202.102.56.0, 202.102.56.255] 江苏连云港</p><p>在庞大的地址库中逐一比对 IP 地址所在的区间，是非常耗时的。<strong>假设在内存中有 12 万条这样的 IP 区间与归属地的对应关系，如何快速定位出一个 IP 地址的归属地呢？</strong></p><h3 id="相关章节-3"><a href="#相关章节-3" class="headerlink" title="相关章节"></a>相关章节</h3><p>15 | 二分查找（上）：如何用最省内存的方式实现快速查找功能？</p><p>16 | 二分查找（下）：如何快速定位 IP 对应的省份地址？</p><h3 id="题目解析-3"><a href="#题目解析-3" class="headerlink" title="题目解析"></a>题目解析</h3><p>这个问题可以用二分查找来解决，不过，普通的二分查找是不行的，我们需要用到二分查找的变形算法，查找最后一个小于等于某个给定值的数据。不过，二分查找最难的不是原理，而是实现。要实现一个二分查找的变形算法，并且实现的代码没有 bug，可不是一件容易的事情，不信你自己写写试试。</p><p>关于这个问题的解答以及写出 bug free 的二分查找代码的技巧，我们在二分查找（下）那一节有非常详细的讲解，你可以回去看看，我这里就不赘述了。</p><h3 id="实战测试题（五）"><a href="#实战测试题（五）" class="headerlink" title="实战测试题（五）"></a>实战测试题（五）</h3><p>假设我们现在希望设计一个简单的海量图片存储系统，最大预期能够存储 1 亿张图片，并且希望这个海量图片存储系统具有下面这样几个功能：</p><p>存储一张图片及其它的元信息，主要的元信息有：图片名称以及一组 tag 信息。比如图片名称叫玫瑰花，tag 信息是{红色，花，情人节}；</p><p>根据关键词搜索一张图片，比如关键词是“情人节 花”“玫瑰花”；</p><p>避免重复插入相同的图片。这里，我们不能单纯地用图片的元信息，来比对是否是同一张图片，因为有可能存在名称相同但图片内容不同，或者名称不同图片内容相同的情况。</p><p>我们希望自主开发一个简单的系统，不希望借助和维护过于复杂的三方系统，比如数据库（MySQL、Redis 等）、分布式存储系统（GFS、Bigtable 等），并且我们单台机器的性能有限，比如硬盘只有 1TB，内存只有 2GB，<strong>如何设计一个符合我们上面要求，操作高效，且使用机器资源最少的存储系统呢？</strong></p><h3 id="相关章节-4"><a href="#相关章节-4" class="headerlink" title="相关章节"></a>相关章节</h3><p>21 | 哈希算法（上）：如何防止数据库中的用户信息被脱库？</p><p>22 | 哈希算法（下）：哈希算法在分布式系统中有哪些应用？</p><h3 id="题目解析-4"><a href="#题目解析-4" class="headerlink" title="题目解析"></a>题目解析</h3><p>这个问题可以分成两部分，第一部分是根据元信息的搜索功能，第二部分是图片判重。</p><p>第一部分，我们可以借助搜索引擎中的倒排索引结构。关于倒排索引我会在实战篇详细讲解，我这里先简要说下。</p><p>如题目中所说，一个图片会对应一组元信息，比如玫瑰花对应{红色，花，情人节}，牡丹花对应{白色，花}，我们可以将这种图片与元信息之间的关系，倒置过来建立索引。“花”这个关键词对应{玫瑰花，牡丹花}，“红色”对应{玫瑰花}，“白色”对应{牡丹花}，“情人节”对应{玫瑰花}。</p><p>当我们搜索“情人节 花”的时候，我们拿两个搜索关键词分别在倒排索引中查找，“花”查找到了{玫瑰花，牡丹花}，“情人节”查找到了{玫瑰花}，两个关键词对应的结果取交集，就是最终的结果了。</p><p>第二部分关于图片判重，我们要基于图片本身来判重，所以可以用哈希算法，对图片内容取哈希值。我们对哈希值建立散列表，这样就可以通过哈希值以及散列表，快速判断图片是否存在。</p><p>我这里只说说我的思路，这个问题中还有详细的内存和硬盘的限制。要想给出更加详细的设计思路，还需要根据这些限制，给出一个估算。详细的解答，我都放在哈希算法（下）那一节里了，你可以自己回去看。</p><h3 id="实战测试题（六）"><a href="#实战测试题（六）" class="headerlink" title="实战测试题（六）"></a>实战测试题（六）</h3><p>我们知道，散列表的查询效率并不能笼统地说成是 O(1)。它跟散列函数、装载因子、散列冲突等都有关系。如果散列函数设计得不好，或者装载因子过高，都可能导致散列冲突发生的概率升高，查询效率下降。</p><p>在极端情况下，有些恶意的攻击者，还有可能通过精心构造的数据，使得所有的数据经过散列函数之后，都散列到同一个槽里。如果我们使用的是基于链表的冲突解决方法，那这个时候，散列表就会退化为链表，查询的时间复杂度就从 O(1) 急剧退化为 O(n)。</p><p>如果散列表中有 10 万个数据，退化后的散列表查询的效率就下降了 10 万倍。更直观点说，如果之前运行 100 次查询只需要 0.1 秒，那现在就需要 1 万秒。这样就有可能因为查询操作消耗大量 CPU 或者线程资源，导致系统无法响应其他请求，从而达到拒绝服务攻击（DoS）的目的。这也就是散列表碰撞攻击的基本原理。</p><p><strong>如何设计一个可以应对各种异常情况的工业级散列表，来避免在散列冲突的情况下，散列表性能的急剧下降，并且能抵抗散列碰撞攻击？</strong></p><h3 id="相关章节-5"><a href="#相关章节-5" class="headerlink" title="相关章节"></a>相关章节</h3><p>18 | 散列表（上）：Word 文档中的单词拼写检查功能是如何实现的？</p><p>19 | 散列表（中）：如何打造一个工业级水平的散列表？</p><h3 id="题目解析-5"><a href="#题目解析-5" class="headerlink" title="题目解析"></a>题目解析</h3><p>我经常把这道题拿来作为面试题考察候选人。散列表可以说是我们最常用的一种数据结构了，编程语言中很多数据类型，都是用散列表来实现的。尽管很多人能对散列表都知道一二，知道有几种散列表冲突解决方案，知道散列表操作的时间复杂度，但是理论跟实践还是有一定距离的。光知道这些基础的理论并不足以开发一个工业级的散列表。</p><p>所以，我在散列表（中）那一节中详细给你展示了一个工业级的散列表要处理哪些问题，以及如何处理的，也就是这个问题的详细答案。</p><p>这六道题你回答得怎么样呢？或许你还无法 100% 回答正确，没关系。其实只要你看了解析之后，有比较深的印象，能立马想到哪节课里讲过，这已经说明你掌握得不错了。毕竟想要完全掌握我讲的全部内容还是需要时间沉淀的。对于这门课的学习，你一定不要心急，慢慢来。只要方向对了就都对了，剩下就交给时间和努力吧！</p><p>通过这套题，你对自己的学习状况应该有了一个了解。从专栏开始到现在，三个月过去了，我们的内容也更新了大半。<strong>你在专栏开始的时候设定的目标是什么？现在实施得如何了？<strong><strong>你可以在留言区给这三个月的学习做个</strong></strong>阶段性学习复盘</strong>。重新整理，继续出发！</p><h2 id="不定期福利第四期-刘超：我是怎么学习《数据结构与算法之美》的？"><a href="#不定期福利第四期-刘超：我是怎么学习《数据结构与算法之美》的？" class="headerlink" title="不定期福利第四期 | 刘超：我是怎么学习《数据结构与算法之美》的？"></a>不定期福利第四期 | 刘超：我是怎么学习《数据结构与算法之美》的？</h2><p>刘超 2018-12-28</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp84d3pag8j30vq0hs788.jpg" alt="img"></p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADYAAAABCAYAAACVOl3IAAAAJUlEQVQYV2N89+7df0FBQQYQeP/+PZgGAUJilMpjs4dSM5H1AwBwSSrLZGasMwAAAABJRU5ErkJggg==" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAABCAYAAADeko4lAAAAHUlEQVQYV2N89+7dfwYoEBQUBLPev3/PgItNSC0ADtASy+rFJtUAAAAASUVORK5CYII=" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADoAAAABCAYAAACPBr1GAAAAJ0lEQVQYV2N89+7dfwYoEBQUBLPev3/PQAkbm3mE7KBUHpd7YeYCAE50MMsBeqQ5AAAAAElFTkSuQmCC" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAABCAYAAAAB3PQ6AAAAHUlEQVQYV2N89+7df0FBQQYQeP/+PQMxbLBiIAAAQE0Py6Kq0rkAAAAASUVORK5CYII=" alt="img"></p><p>你好，我是刘超，是隔壁《趣谈网络协议》专栏的作者。今天来“串个门儿”，讲讲我学习《数据结构与算法之美》这个专栏的一些体会和感受。</p><p>《数据结构与算法之美》是目前“极客时间”订阅量最多的专栏，我也是其中最早购买的一员。我之所以一看就心动了，源于王争老师在开篇词里面说的那段话：</p><p>基础知识就像是一座大楼的地基，它决定了我们的技术高度。那技术人究竟都需要修炼哪些“内功”呢？我觉得，无外乎就是大学里的那些基础课程，操作系统、计算机网络、编译原理等等，当然还有数据结构和算法。</p><p>这个也是我写《趣谈网络协议》的时候，在开篇词里反复强调的观点。我为什么这么说呢？因为，我们作为面试官，在招人的时候，往往发现，使用框架速成的人很多，基础知识扎实的人少见，而基础不扎实会影响你以后学习新技术的速度和职业发展的广度。</p><p>和“极客时间”编辑聊的时候，我也多次表达，希望我们讲的东西和一般的培训机构有所区别，希望“极客时间”能做真正对程序员的技能提升和职业发展有价值的内容，希望“极客时间”能够成为真正帮助程序员成长的助手。</p><p>所以，当“极客时间”相继推出《Java 核心技术 36 讲》《零基础学 Python》《从 0 开始学架构》《MySQL 实战 45 讲》这些课程的时候，我非常开心。我希望将来能够继续覆盖到编译原理、操作系统、计算机组成原理等等。在这些课程里，算法是基础的基础，也是我本人很想精进的部分。</p><p>当然，除了长远的职业发展需要，搞定算法还有一个看得见、摸得着的好处，面试。</p><p>我经常讲，越是薪资低的企业，面试的时候，它们往往越注重你会不会做网站，甚至会要求你现场做出个东西来。你要注意了，这其实是在找代码熟练工。相反，越是薪资高的企业，越是重视考察基础知识。基础好，说明可塑性强，培养起来也比较快。<strong>而最牛的公司，考的往往是算法和思路。</strong></p><p>相信很多购买《数据结构与算法之美》专栏的同学，下单的时候，已经想象自己面试的时候，在白板上挥洒代码，面试官频频点头的场景，想着自己马上就能“进驻牛公司，迎娶白富美”了。</p><p>然而，事实却是，<strong>武功套路容易学，扎马步基本功难练</strong>，编程也是一样。框架容易学，基本功难。你没办法讨巧，你要像郭靖学习降龙十八掌那样，一掌一掌劈下去才行。</p><p>于是，咱们这个专栏就开始了，你见到的仍然是困难的复杂度计算，指针指来指去，烧脑的逻辑，小心翼翼的边界条件判断。你发现，数据结构和算法好像并不是你上下班时间顺便听一听就能攻克的问题。你需要静下心来仔细想，拿个笔画一画，甚至要写一写代码，Debug 一下，才能够理解。是的，的确不轻松，那你坚持下来了吗？</p><p>我在这里分享一下我的学习思路，我将这个看起来困难的过程分成了几部分来完成。</p><p>第一部分，数据结构和算法的基础知识部分。如果在大学学过这门课，在专栏里，你会看到很多熟悉的描述。有些基础比较好的同学会质疑写这些知识的必要性。这大可不必，因为每个人的基础不一样，为了专栏内容的系统性和完整性，老师肯定要把这些基础知识重新讲述一遍的。对于这一部分内容，如果你的基础比较好，可以像学其他课程一样，在上下班或者午休的时候进行学习，主要是起到温习的作用。</p><p>第二部分，需要代码练习的部分。由于王争老师面试过很多人，所以在专栏里，他会列举一些他在面试中常常会问的题目。很多情况下，这些题目需要当场就能在白板上写出来。这些问题对于想要提升自己面试能力的同学来说，应该是很有帮助的。</p><p>我这里列举几个，你可以看看，是不是都能回答出来呢？</p><p>在链表这一节：单链表反转，链表中环的检测，两个有序的链表合并，删除链表倒数第 n 个结点，求链表的中间结点等。</p><p>在栈这一节，在函数调用中的应用，在表达式求值中的应用，在括号匹配中的应用。</p><p>在排序这一节，如何在 O(n) 的时间复杂度内查找一个无序数组中的第 K 大元素？</p><p>在二分查找这一节，二分查找的四个变体。</p><p>这些问题你都应该上手写写代码，或者在面试之前拿来练练手，而且，不仅仅只是实现主要功能。大公司的面试很多情况下都会考虑边界条件。只要被面试官抓住漏洞，就会被扣分，所以你最好事先写写。</p><p>第三部分，对于海量数据的处理思路问题。现在排名靠前的大公司，大都存在海量数据的处理问题。对于这一类问题，在面试的时候，也是经常会问到的。由于这类问题复杂度比较高，很少让当场就写代码，但是基本上会让你说一个思路，或者写写伪代码。想要解决海量数据的问题，你会的就不能只是基础的数据结构和算法了，你需要综合应用。如果平时没有想过这部分问题，临时被问，肯定会懵。</p><p>在专栏里，王争老师列举了大量这类问题，你要重点思考这类问题背后的思路，然后平时自己处理问题的时候，也多想想，如果这个问题数据量大的话，应该怎么办。这样多思考，面试的时候，思路很容易就来了。</p><p>比如，我这里随便列了几个，都是很经典的问题。你要是想不起来，就赶紧去复习吧！</p><p>比如说，我们有 10GB 的订单数据，我们希望按订单金额（假设金额都是正整数）进行排序，但是我们的内存有限，只有几百 MB，没办法一次性把 10GB 的数据都加载到内存中。这个时候该怎么办呢？</p><p>如果你所在的省有 50 万考生，如何通过成绩快速排序得出名次呢？</p><p>假设我们有 10 万个手机号码，希望将这 10 万个手机号码从小到大排序，你有什么比较快速的排序方法呢？</p><p>假设我们有 1000 万个整型数据，每个数据占 8 个字节，如何设计数据结构和算法，快速判断某个整数是否出现在这 1000 万数据中？ 我们希望这个功能不要占用太多的内存空间，最多不要超过 100MB，你会怎么做呢？</p><p>第四部分，工业实践部分。在每种数据结构的讲解中，老师会重点分析一些这些数据结构在工业上的实践，封装在库里面的，一般人不注意的。</p><p>我看王争老师也是个代码分析控。一般同学可能遇到问题，查一查有没有开源软件或者现成的库，可以用就完了。而王争老师会研究底层代码的实现，解析为什么这些在工业中大量使用的库，应该这样实现。这部分不但对于面试有帮助，对于实际开发也有很大的帮助。普通程序员和高手的差距，就是一个用完了就完了，一个用完了要看看为啥这样用。</p><p>例如，老师解析了 Glibc 中的 qsort() 函数，Java 中的 HashMap 如何实现工业级的散列表，Redis 中的有序集合（Sorted Set）的实现，工程上使用的红黑树等等。</p><p>尤其是对于哈希算法，老师解析了安全加密、数据校验、唯一标识、散列函数，负载均衡、数据分片、分布式存储等应用。如果你同时订阅了架构、微服务的课程，你会发现这些算法在目前最火的架构设计中，都有使用。</p><p>师傅领进门，修行在个人。尽管老师只是解析了其中一部分，但是咱们在平时使用开源软件和库的时候，也要多问个为什么。写完了程序，看看官方文档，看看原理解析的书，看看源代码，然后映射到算法与数据结构中，你会发现，这些知识和思路到处都在使用。</p><p>最后，我还想说一句，坚持，别放弃，啃下来。基础越扎实，路走得越远，走得越宽。加油！</p><h2 id="总结课-在实际开发中，如何权衡选择使用哪种数据结构和算法？"><a href="#总结课-在实际开发中，如何权衡选择使用哪种数据结构和算法？" class="headerlink" title="总结课 | 在实际开发中，如何权衡选择使用哪种数据结构和算法？"></a>总结课 | 在实际开发中，如何权衡选择使用哪种数据结构和算法？</h2><p>王争 2019-02-18</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp84d4go78j30vq0hsq5b.jpg" alt="img"></p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADYAAAABCAYAAACVOl3IAAAAJUlEQVQYV2N89+7df0FBQQYQeP/+PZgGAUJilMpjs4dSM5H1AwBwSSrLZGasMwAAAABJRU5ErkJggg==" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAABCAYAAADeko4lAAAAHUlEQVQYV2N89+7dfwYoEBQUBLPev3/PgItNSC0ADtASy+rFJtUAAAAASUVORK5CYII=" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADoAAAABCAYAAACPBr1GAAAAJ0lEQVQYV2N89+7dfwYoEBQUBLPev3/PQAkbm3mE7KBUHpd7YeYCAE50MMsBeqQ5AAAAAElFTkSuQmCC" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAABCAYAAAAB3PQ6AAAAHUlEQVQYV2N89+7df0FBQQYQeP/+PQMxbLBiIAAAQE0Py6Kq0rkAAAAASUVORK5CYII=" alt="img"></p><p></p><p>00:00</p><p><a href="javascript:;">1.25x<em></em></a></p><p>讲述：冯永吉 大小：9.47M 时长：10:20</p><p>你好，我是王争，今天是一篇总结课。我们学了这么多数据结构和算法，在实际开发中，究竟该如何权衡选择使用哪种数据结构和算法呢？今天我们就来聊一聊这个问题，希望能帮你把学习带回实践中。</p><p>我一直强调，学习数据结构和算法，不要停留在学院派的思维中，只把算法当作应付面试、考试或者竞赛的花拳绣腿。作为软件开发工程师，我们要把数据结构和算法，应用到软件开发中，解决实际的开发问题。</p><p>不过，要想在实际的开发中，灵活、恰到好处地应用数据结构和算法，需要非常深厚的实战经验积累。尽管我在课程中，一直都结合实际的开发场景来讲解，希望带你真枪实弹地演练算法如何解决实际的问题。但是，在今后的软件开发中，你要面对的问题远比我讲的场景要复杂、多变、不确定。</p><p>要想游刃有余地解决今后你要面对的问题，光是熟知每种数据结构和算法的功能、特点、时间空间复杂度，还是不够的。毕竟工程上的问题不是算法题。算法题的背景、条件、限制都非常明确，我们只需要在规定的输入、输出下，找最优解就可以了。</p><p>而工程上的问题往往都比较开放，在选择数据结构和算法的时候，我们往往需要综合各种因素，比如编码难度、维护成本、数据特征、数据规模等，最终选择一个<strong>工程的最合适解</strong>，而非<strong>理论上的最优解</strong>。</p><p>为了让你能做到活学活用，在实际的软件开发中，不生搬硬套数据结构和算法，今天，我们就聊一聊，在实际的软件开发中，如何权衡各种因素，合理地选择使用哪种数据结构和算法？关于这个问题，我总结了六条经验。</p><h3 id="1-时间、空间复杂度不能跟性能划等号"><a href="#1-时间、空间复杂度不能跟性能划等号" class="headerlink" title="1. 时间、空间复杂度不能跟性能划等号"></a>1. 时间、空间复杂度不能跟性能划等号</h3><p>我们在学习每种数据结构和算法的时候，都详细分析了算法的时间复杂度、空间复杂度，但是，在实际的软件开发中，复杂度不能与性能简单划等号，不能表示执行时间和内存消耗的确切数据量。为什么这么说呢？原因有下面几点。</p><p><strong>复杂度不是执行时间和内存消耗的精确值</strong></p><p>在用大 O 表示法表示复杂度的时候，我们会忽略掉低阶、常数、系数，只保留高阶，并且它的度量单位是语句的执行频度。每条语句的执行时间，并非是相同、确定的。所以，复杂度给出的只能是一个非精确量值的趋势。</p><p><strong>代码的执行时间有时不跟时间复杂度成正比</strong></p><p>我们常说，时间复杂度是 O(nlogn) 的算法，比时间复杂度是 O(n^2) 的算法，执行效率要高。这样说的一个前提是，算法处理的是大规模数据的情况。对于小规模数据的处理，算法的执行效率并不一定跟时间复杂度成正比，有时还会跟复杂度成反比。</p><p><strong>对于处理不同问题的不同算法，其复杂度大小没有可比性</strong></p><p>复杂度只能用来表征不同算法，在处理同样的问题，以及同样数据类型的情况下的性能表现。但是，对于不同的问题、不同的数据类型，不同算法之间的复杂度大小并没有可比性。</p><h3 id="2-抛开数据规模谈数据结构和算法都是“耍流氓”"><a href="#2-抛开数据规模谈数据结构和算法都是“耍流氓”" class="headerlink" title="2. 抛开数据规模谈数据结构和算法都是“耍流氓”"></a>2. 抛开数据规模谈数据结构和算法都是“耍流氓”</h3><p>在平时的开发中，在数据规模很小的情况下，普通算法和高级算法之间的性能差距会非常小。如果代码执行频率不高、又不是核心代码，这个时候，我们选择数据结构和算法的主要依据是，其是否简单、容易维护、容易实现。大部分情况下，我们直接用最简单的存储结构和最暴力的算法就可以了。</p><p>比如，对于长度在一百以内的字符串匹配，我们直接使用朴素的字符串匹配算法就够了。如果用 KMP、BM 这些更加高效的字符串匹配算法，实际上就大材小用了。因为这对于处理时间是毫秒量级敏感的系统来说，性能的提升并不大。相反，这些高级算法会徒增编码的难度，还容易产生 bug。</p><h3 id="3-结合数据特征和访问方式来选择数据结构"><a href="#3-结合数据特征和访问方式来选择数据结构" class="headerlink" title="3. 结合数据特征和访问方式来选择数据结构"></a>3. 结合数据特征和访问方式来选择数据结构</h3><p>面对实际的软件开发场景，当我们掌握了基础数据结构和算法之后，最考验能力的并不是数据结构和算法本身，而是对问题需求的挖掘、抽象、建模。<strong>如何将一个背景复杂、开放的问题，通过细致的观察、调研、假设，理清楚要处理数据的特征与访问方式，这才是解决问题的重点。</strong>只有理清楚了这些东西，我们才能将问题转化成合理的数据结构模型，进而找到满足需求的算法。</p><p>比如我们前面讲过，Trie 树这种数据结构是一种非常高效的字符串匹配算法。但是，如果你要处理的数据，并没有太多的前缀重合，并且字符集很大，显然就不适合利用 Trie 树了。所以，在用 Trie 树之前，我们需要详细地分析数据的特点，甚至还要写些分析代码、测试代码，明确要处理的数据是否适合使用 Trie 树这种数据结构。</p><p>再比如，图的表示方式有很多种，邻接矩阵、邻接表、逆邻接表、二元组等等。你面对的场景应该用哪种方式来表示，具体还要看你的数据特征和访问方式。如果每个数据之间联系很少，对应到图中，就是一个稀疏图，就比较适合用邻接表来存储。相反，如果是稠密图，那就比较适合采用邻接矩阵来存储。</p><h3 id="4-区别对待-IO-密集、内存密集和计算密集"><a href="#4-区别对待-IO-密集、内存密集和计算密集" class="headerlink" title="4. 区别对待 IO 密集、内存密集和计算密集"></a>4. 区别对待 IO 密集、内存密集和计算密集</h3><p>如果你要处理的数据存储在磁盘，比如数据库中。那代码的性能瓶颈有可能在磁盘 IO，而并非算法本身。这个时候，你需要合理地选择数据存储格式和存取方式，减少磁盘 IO 的次数。</p><p>比如我们在递归那一节讲过最终推荐人的例子。你应该注意到了，当时我给出的代码尽管正确，但其实并不高效。如果某个用户是经过层层推荐才来注册的，那我们获取他的最终推荐人的时候，就需要多次访问数据库，性能显然就不高了。</p><p>不过，这个问题解决起来不难。我们知道，某个用户的最终推荐人一旦确定，就不会变动。所以，我们可以离线计算每个用户的最终推荐人，并且保存在表中的某个字段里。当我们要查看某个用户的最终推荐人的时候，访问一次数据库就可以获取到。</p><p>刚刚我们讲了数据存储在磁盘的情况，现在我们再来看下，数据存储在内存中的情况。如果你的数据是存储在内存中，那我们还需要考虑，代码是内存密集型的还是 CPU 密集型的。</p><p>所谓 CPU 密集型，简单点理解就是，代码执行效率的瓶颈主要在 CPU 执行的效率。我们从内存中读取一次数据，到 CPU 缓存或者寄存器之后，会进行多次频繁的 CPU 计算（比如加减乘除），CPU 计算耗时占大部分。所以，在选择数据结构和算法的时候，要尽量减少逻辑计算的复杂度。比如，用位运算代替加减乘除运算等。</p><p>所谓内存密集型，简单点理解就是，代码执行效率的瓶颈在内存数据的存取。对于内存密集型的代码，计算操作都比较简单，比如，字符串比较操作，实际上就是内存密集型的。每次从内存中读取数据之后，我们只需要进行一次简单的比较操作。所以，内存数据的读取速度，是字符串比较操作的瓶颈。因此，在选择数据结构和算法的时候，需要考虑是否能减少数据的读取量，数据是否在内存中连续存储，是否能利用 CPU 缓存预读。</p><h3 id="5-善用语言提供的类，避免重复造轮子"><a href="#5-善用语言提供的类，避免重复造轮子" class="headerlink" title="5. 善用语言提供的类，避免重复造轮子"></a>5. 善用语言提供的类，避免重复造轮子</h3><p>实际上，对于大部分常用的数据结构和算法，编程语言都提供了现成的类和函数实现。比如，Java 中的 HashMap 就是散列表的实现，TreeMap 就是红黑树的实现等。在实际的软件开发中，除非有特殊的要求，我们都可以直接使用编程语言中提供的这些类或函数。</p><p>这些编程语言提供的类和函数，都是经过无数验证过的，不管是正确性、鲁棒性，都要超过你自己造的轮子。而且，你要知道，重复造轮子，并没有那么简单。你需要写大量的测试用例，并且考虑各种异常情况，还要团队能看懂、能维护。这显然是一个出力不讨好的事情。这也是很多高级的数据结构和算法，比如 Trie 树、跳表等，在工程中，并不经常被应用的原因。</p><p>但这并不代表，学习数据结构和算法是没用的。深入理解原理，有助于你能更好地应用这些编程语言提供的类和函数。能否深入理解所用工具、类的原理，这也是普通程序员跟技术专家的区别。</p><h3 id="6-千万不要漫无目的地过度优化"><a href="#6-千万不要漫无目的地过度优化" class="headerlink" title="6. 千万不要漫无目的地过度优化"></a>6. 千万不要漫无目的地过度优化</h3><p>掌握了数据结构和算法这把锤子，不要看哪里都是钉子。比如，一段代码执行只需要 0.01 秒，你非得用一个非常复杂的算法或者数据结构，将其优化成 0.005 秒。即便你的算法再优秀，这种微小优化的意义也并不大。相反，对应的代码维护成本可能要高很多。</p><p>不过度优化并不代表，我们在软件开发的时候，可以不加思考地随意选择数据结构和算法。我们要学会估算。估算能力实际上也是一个非常重要的能力。我们不仅要对普通情况下的数据规模和性能压力做估算，还需要对异常以及将来一段时间内，可能达到的数据规模和性能压力做估算。这样，我们才能做到未雨绸缪，写出来的代码才能经久可用。</p><p>还有，当你真的要优化代码的时候，一定要先做 Benchmark 基准测试。这样才能避免你想当然地换了一个更高效的算法，但真实情况下，性能反倒下降了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>工程上的问题，远比课本上的要复杂。所以，我今天总结了六条经验，希望你能把数据结构和算法用在刀刃上，恰当地解决实际问题。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp84d7c0o1j30vq0mn0x1.jpg" alt="img"></p><p>我们在利用数据结构和算法解决问题的时候，一定要先分析清楚问题的需求、限制、隐藏的特点等。只有搞清楚了这些，才能有针对性地选择恰当的数据结构和算法。这种灵活应用的实战能力，需要长期的刻意锻炼和积累。这是一个有经验的工程师和一个学院派的工程师的区别。</p><p>好了，今天的内容就到这里了。最后，我想听你谈一谈，你在实际开发选择数据结构和算法时，有什么感受和方法呢？</p><p>欢迎在留言区写下你的想法，也欢迎你把今天的文章分享给你的朋友，帮助他在数据结构和算法的实际运用中走得更远。</p><h2 id="《数据结构与算法之美》学习指导手册"><a href="#《数据结构与算法之美》学习指导手册" class="headerlink" title="《数据结构与算法之美》学习指导手册"></a>《数据结构与算法之美》学习指导手册</h2><p>王争 2019-04-22</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp7wxcgewaj30vq0hs7a5.jpg" alt="img"></p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADYAAAABCAYAAACVOl3IAAAAJUlEQVQYV2N89+7df0FBQQYQeP/+PZgGAUJilMpjs4dSM5H1AwBwSSrLZGasMwAAAABJRU5ErkJggg==" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAABCAYAAADeko4lAAAAHUlEQVQYV2N89+7dfwYoEBQUBLPev3/PgItNSC0ADtASy+rFJtUAAAAASUVORK5CYII=" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADoAAAABCAYAAACPBr1GAAAAJ0lEQVQYV2N89+7dfwYoEBQUBLPev3/PQAkbm3mE7KBUHpd7YeYCAE50MMsBeqQ5AAAAAElFTkSuQmCC" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAABCAYAAAAB3PQ6AAAAHUlEQVQYV2N89+7df0FBQQYQeP/+PQMxbLBiIAAAQE0Py6Kq0rkAAAAASUVORK5CYII=" alt="img"></p><p>你好，我是王争。</p><p>在设计专栏内容的时候，为了兼顾不同基础的同学，我在内容上做到了难易结合，既有简单的数组、链表、栈、队列这些基础内容，也有红黑树、BM、KMP 这些难度较大的算法。但是，对于初学者来说，一下子面对这么多知识，可能还是比较懵。</p><p>我觉得，对于初学者来说，先把最简单、最基础、最重要的知识点掌握好，再去研究难度较高、更加高级的知识点，这样由易到难、循序渐进的学习路径，无疑是最合理的。</p><p>基于这个路径，我对专栏内容，重新做了一次梳理，希望给你一份具体、明确、有效的学习指导。我会写清楚<strong>每个知识点的难易程度、需要你掌握到什么程度、具体如何来学习</strong>。</p><p>如果你是数据结构和算法的初学者，或者你觉得自己的基础比较薄弱，希望这份学习指导，能够让你学起来能更加有的放矢，能把精力、时间花在刀刃上，获得更好的学习效果。</p><p>下面，我先给出一个大致的学习路线。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp84d6ioopj31400u0gri.jpg" alt="img"></p><p>（建议保存后查看大图）</p><p>现在，针对每个知识点，我再给你逐一解释一下。我这里先说明一下，下面标记的难易程度、是否重点、掌握程度，都只是针对初学者来说的，如果你已经有一定基础，可以根据自己的情况，安排自己的学习。</p><h3 id="1-复杂度分析"><a href="#1-复杂度分析" class="headerlink" title="1. 复杂度分析"></a>1. 复杂度分析</h3><p>尽管在专栏中，我只用了两节课的内容，来讲复杂度分析这个知识点。但是，我想说的是，它真的非常重要。你必须要牢牢掌握这两节，基本上要做到，简单代码能很快分析出时间、空间复杂度；对于复杂点的代码，比如递归代码，你也要掌握专栏中讲到的两种分析方法：递推公式和递归树。</p><p>对于初学者来说，光看入门篇的两节复杂度分析文章，可能还不足以完全掌握复杂度分析。不过，在后续讲解每种数据结构和算法的时候，我都有详细分析它们的时间、空间复杂度。所以，你可以在学习专栏中其他章节的时候，再不停地、有意识地去训练自己的复杂度分析能力。</p><p>难易程度：Medium</p><p>是否重点：10 分</p><p>掌握程度：在不看我的分析的情况下，能自行分析专栏中大部分数据结构和算法的时间、空间复杂度</p><h3 id="2-数组、栈、队列"><a href="#2-数组、栈、队列" class="headerlink" title="2. 数组、栈、队列"></a>2. 数组、栈、队列</h3><p>这一部分内容非常简单，初学者学起来也不会很难。但是，作为基础的数据结构，数组、栈、队列，是后续很多复杂数据结构和算法的基础，所以，这些内容你一定要掌握。</p><p>难易程度：Easy</p><p>是否重点：8 分</p><p>掌握程度：能自己实现动态数组、栈、队列</p><h3 id="3-链表"><a href="#3-链表" class="headerlink" title="3. 链表"></a>3. 链表</h3><p>链表非常重要！虽然理论内容不多，但链表上的操作却很复杂。所以，面试中经常会考察，你一定要掌握。而且，我这里说“掌握”不只是能看懂专栏中的内容，还能将专栏中提到的经典链表题目，比如链表反转、求中间结点等，轻松无 bug 地实现出来。</p><p>难易程度：Medium</p><p>是否重点：9 分</p><p>掌握程度：能轻松写出经典链表题目代码</p><h3 id="4-递归"><a href="#4-递归" class="headerlink" title="4. 递归"></a>4. 递归</h3><p>对于初学者来说，递归代码非常难掌握，不管是读起来，还是写起来。但是，这道坎你必须要跨过，跨不过就不能算是入门数据结构和算法。我们后面讲到的很多数据结构和算法的代码实现，都要用到递归。</p><p>递归相关的理论知识也不多，所以还是要多练。你可以先在网上找些简单的题目练手，比如斐波那契数列、求阶乘等，然后再慢慢过渡到更加有难度的，比如归并排序、快速排序、二叉树的遍历、求高度，最后是回溯八皇后、背包问题等。</p><p>难易程度：Hard</p><p>是否重点：10 分</p><p>掌握程度：轻松写出二叉树遍历、八皇后、背包问题、DFS 的递归代码</p><h3 id="5-排序、二分查找"><a href="#5-排序、二分查找" class="headerlink" title="5. 排序、二分查找"></a>5. 排序、二分查找</h3><p>这一部分并不难，你只需要能看懂我专栏里的内容即可。</p><p>难易程度：Easy</p><p>是否重点：7 分</p><p>掌握程度：能自己把各种排序算法、二分查找及其变体代码写一遍就可以了</p><h3 id="6-跳表"><a href="#6-跳表" class="headerlink" title="6. 跳表"></a>6. 跳表</h3><p>对于初学者来说，并不需要非得掌握跳表，所以，如果没有精力，这一章节可以先跳过。</p><p>难易程度：Medium</p><p>是否重点：6 分</p><p>掌握程度：初学者可以先跳过。如果感兴趣，看懂专栏内容即可，不需要掌握代码实现</p><h3 id="7-散列表"><a href="#7-散列表" class="headerlink" title="7. 散列表"></a>7. 散列表</h3><p>尽管散列表的内容我讲了很多，有三节课。但是，总体上来讲，这块内容理解起来并不难。但是，作为一种应用非常广泛的数据结构，你还是要掌握牢固散列表。</p><p>难易程度：Medium</p><p>是否重点：8 分</p><p>掌握程度：对于初学者来说，自己能代码实现一个拉链法解决冲突的散列表即可</p><h3 id="8-哈希算法"><a href="#8-哈希算法" class="headerlink" title="8. 哈希算法"></a>8. 哈希算法</h3><p>这部分纯粹是为了开拓思路，初学者可以略过。</p><p>难易程度：Easy</p><p>是否重点：3 分</p><p>掌握程度：可以暂时不看</p><h3 id="9-二叉树"><a href="#9-二叉树" class="headerlink" title="9. 二叉树"></a>9. 二叉树</h3><p>这一部分非常重要！二叉树在面试中经常会被考到，所以要重点掌握。但是我这里说的二叉树，并不包含专栏中红黑树的内容。红黑树我们待会再讲。</p><p>难易程度：Medium</p><p>是否重点：9 分</p><p>掌握程度：能代码实现二叉树的三种遍历算法、按层遍历、求高度等经典二叉树题目</p><h3 id="10-红黑树"><a href="#10-红黑树" class="headerlink" title="10. 红黑树"></a>10. 红黑树</h3><p>对于初学者来说，这一节课完全可以不看。</p><p>难易程度：Hard</p><p>是否重点：3 分</p><p>掌握程度：初学者不用把时间浪费在上面</p><h3 id="11-B-树"><a href="#11-B-树" class="headerlink" title="11. B+ 树"></a>11. B+ 树</h3><p>虽然 B+ 树也算是比较高级的一种数据结构了，但是对初学者来说，也不是重点。有时候面试的时候还是会问的，所以这一部分内容，你能看懂专栏里的讲解就可以了。</p><p>难易程度：Medium</p><p>是否重点：5 分</p><p>掌握程度：可看可不看</p><h3 id="12-堆与堆排序"><a href="#12-堆与堆排序" class="headerlink" title="12. 堆与堆排序"></a>12. 堆与堆排序</h3><p>这一部分内容不是很难，初学者也是要掌握的。</p><p>难易程度：Medium</p><p>是否重点：8 分</p><p>掌握程度：能代码实现堆、堆排序，并且掌握堆的三种应用（优先级队列、Top k、中位数）</p><h3 id="13-图的表示"><a href="#13-图的表示" class="headerlink" title="13. 图的表示"></a>13. 图的表示</h3><p>图的内容很多，但是初学者不需要掌握那么多。一般 BAT 等大厂面试，不怎么会面试有关图的内容，因为面试官可能也对这块不会很熟悉哈：）。但是，最基本图的概念、表示方法还是要掌握的。</p><p>难易程度：Easy</p><p>是否重点：8 分</p><p>掌握程度：理解图的三种表示方法（邻接矩阵、邻接表、逆邻接表），能自己代码实现</p><h3 id="14-深度广度优先搜索"><a href="#14-深度广度优先搜索" class="headerlink" title="14. 深度广度优先搜索"></a>14. 深度广度优先搜索</h3><p>这算是图上最基础的遍历或者说是搜索算法了，所以还是要掌握一下。这两种算法的原理都不难哈，但是代码实现并不简单，一个用到了队列，另一个用到了递归。对于初学者来说，看懂这两个代码实现就是一个挑战！可以等到其他更重要的内容都掌握之后，再来挑战，也是可以的。</p><p>难易程度：Hard</p><p>是否重点：8 分</p><p>掌握程度：能代码实现广度优先、深度优先搜索算法</p><h3 id="15-拓扑排序、最短路径、A-算法"><a href="#15-拓扑排序、最短路径、A-算法" class="headerlink" title="15. 拓扑排序、最短路径、A* 算法"></a>15. 拓扑排序、最短路径、A* 算法</h3><p>这几个算法稍微高级点。如果你能轻松实现深度、广度优先搜索，那看懂这三个算法不成问题。不过，这三种算法不是重点。面试不会考的。</p><p>难易程度：Hard</p><p>是否重点：5 分</p><p>掌握程度：有时间再看，暂时可以不看</p><h3 id="16-字符串匹配（BF、RK）"><a href="#16-字符串匹配（BF、RK）" class="headerlink" title="16. 字符串匹配（BF、RK）"></a>16. 字符串匹配（BF、RK）</h3><p>BF 非常简单，RK 稍微复杂点，但都不难。这个最好还是掌握下。</p><p>难易程度：Easy</p><p>是否重点：7 分</p><p>掌握程度：能实践 BF 算法，能看懂 RK 算法</p><h3 id="17-字符串匹配（BM、KMP、AC-自动机）"><a href="#17-字符串匹配（BM、KMP、AC-自动机）" class="headerlink" title="17. 字符串匹配（BM、KMP、AC 自动机）"></a>17. 字符串匹配（BM、KMP、AC 自动机）</h3><p>这三个算法都挺难的，对于算法有一定基础的人来说，看懂也不容易。所以，对于初学者来说，千万别浪费时间在这上面。即便有余力，看懂就好了，不用非得能自己实现。</p><p>难易程度：Hard</p><p>是否重点：3 分</p><p>掌握程度：初学者不用把时间浪费在上面</p><h3 id="18-字符串匹配（Trie）"><a href="#18-字符串匹配（Trie）" class="headerlink" title="18. 字符串匹配（Trie）"></a>18. 字符串匹配（Trie）</h3><p>这个还是要能看懂，不过不需要能代码实现。有些面试官喜欢考这个东西，主要是结合应用场景来考察，只是看你知不知道要用 Trie 树这个东西。</p><p>难易程度：Medium</p><p>是否重点：7 分</p><p>掌握程度：能看懂，知道特点、应用场景即可，不要求代码实现</p><h3 id="19-位图"><a href="#19-位图" class="headerlink" title="19. 位图"></a>19. 位图</h3><p>位图不是重点，如果有余力最好掌握一下。</p><p>难易程度：Easy</p><p>是否重点：6 分</p><p>掌握程度：看懂即可，能自己实现一个位图结构最好</p><h3 id="20-四种算法思想"><a href="#20-四种算法思想" class="headerlink" title="20. 四种算法思想"></a>20. 四种算法思想</h3><p>这个是重点，也是难点。贪心、分治、回溯、动态规划，每一个都不简单，其中动态规划又是最难、最烧脑的。要应付 FLAG 这样公司的面试，必须拿下这块内容。但是呢，学习要循序渐进，这块内容的学习可以放到最后，做个长时间的学习计划来攻克。</p><p>这块内容理论的东西不多，要想真的掌握，还是要大量刷题。</p><p>难易程度：Hard</p><p>是否重点：10 分</p><p>掌握程度：可以放到最后，但是一定要掌握！做到能实现 Leetcode 上 Medium 难度的题目</p><p>学而时习之，专栏虽然已经结束，但是学习的同学和留言依旧源源不断。希望这份学习指导手册对你有帮助，也欢迎你继续给我留言，和大家一起交流、学习、进步。</p><hr><h2 id="春节7天练-Day-1：数组和链表"><a href="#春节7天练-Day-1：数组和链表" class="headerlink" title="春节7天练 | Day 1：数组和链表"></a>春节7天练 | Day 1：数组和链表</h2><p>王争 2019-02-04</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp84cx7hn5j30vq0jywhr.jpg" alt="img"></p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADYAAAABCAYAAACVOl3IAAAAJUlEQVQYV2N89+7df0FBQQYQeP/+PZgGAUJilMpjs4dSM5H1AwBwSSrLZGasMwAAAABJRU5ErkJggg==" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAABCAYAAADeko4lAAAAHUlEQVQYV2N89+7dfwYoEBQUBLPev3/PgItNSC0ADtASy+rFJtUAAAAASUVORK5CYII=" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADoAAAABCAYAAACPBr1GAAAAJ0lEQVQYV2N89+7dfwYoEBQUBLPev3/PQAkbm3mE7KBUHpd7YeYCAE50MMsBeqQ5AAAAAElFTkSuQmCC" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAABCAYAAAAB3PQ6AAAAHUlEQVQYV2N89+7df0FBQQYQeP/+PQMxbLBiIAAAQE0Py6Kq0rkAAAAASUVORK5CYII=" alt="img"></p><p>讲述：冯永吉 大小：882.20K 时长：00:55</p><p>你好，我是王争。首先祝你新年快乐！</p><p>专栏的正文部分已经结束，相信这半年的时间，你学到了很多，究竟学习成果怎样呢？</p><p>我整理了数据结构和算法中必知必会的 30 个代码实现，从今天开始，分 7 天发布出来，供你复习巩固所用。你可以每天花一点时间，来完成测验。测验完成后，你可以根据结果，回到相应章节，有针对性地进行复习。</p><p>除此之外，@Smallfly 同学还整理了一份配套的 LeetCode 练习题，你也可以一起练习一下。在此，我谨代表我本人对 @Smallfly 表示感谢！</p><p>另外，我还为假期坚持学习的同学准备了丰厚的春节加油礼包。</p><p>2 月 5 日 -2 月 14 日，只要在专栏文章下的留言区写下你的答案，参与答题，并且留言被精选，即可获得极客时间 10 元无门槛优惠券。</p><p>7 篇中的所有题目，只要回答正确 3 道及以上，即可获得极客时间 99 元专栏通用阅码。</p><p>如果 7 天连续参与答题，并且每天的留言均被精选，还可额外获得极客时间价值 365 元的每日一课年度会员。</p><h3 id="关于数组和链表的几个必知必会的代码实现"><a href="#关于数组和链表的几个必知必会的代码实现" class="headerlink" title="关于数组和链表的几个必知必会的代码实现"></a>关于数组和链表的几个必知必会的代码实现</h3><ul><li><strong>数组</strong></li></ul><p>实现一个支持动态扩容的数组</p><p>实现一个大小固定的有序数组，支持动态增删改操作</p><p>实现两个有序数组合并为一个有序数组</p><ul><li><strong>链表</strong></li></ul><p>实现单链表、循环链表、双向链表，支持增删操作</p><p>实现单链表反转</p><p>实现两个有序的链表合并为一个有序链表</p><p>实现求链表的中间结点</p><h3 id="对应的-LeetCode-练习题（-Smallfly-整理）"><a href="#对应的-LeetCode-练习题（-Smallfly-整理）" class="headerlink" title="对应的 LeetCode 练习题（@Smallfly 整理）"></a>对应的 LeetCode 练习题（@Smallfly 整理）</h3><ul><li><strong>数组</strong></li></ul><p>Three Sum（求三数之和）</p><p>英文版：<a href="https://leetcode.com/problems/3sum/">https://leetcode.com/problems/3sum/</a></p><p>中文版：<a href="https://leetcode-cn.com/problems/3sum/">https://leetcode-cn.com/problems/3sum/</a></p><p>Majority Element（求众数）</p><p>英文版：<a href="https://leetcode.com/problems/majority-element/">https://leetcode.com/problems/majority-element/</a></p><p>中文版：<a href="https://leetcode-cn.com/problems/majority-element/">https://leetcode-cn.com/problems/majority-element/</a></p><p>Missing Positive（求缺失的第一个正数）</p><p>英文版：<a href="https://leetcode.com/problems/first-missing-positive/">https://leetcode.com/problems/first-missing-positive/</a></p><p>中文版：<a href="https://leetcode-cn.com/problems/first-missing-positive/">https://leetcode-cn.com/problems/first-missing-positive/</a></p><ul><li><strong>链表</strong></li></ul><p>Linked List Cycle I（环形链表）</p><p>英文版：<a href="https://leetcode.com/problems/linked-list-cycle/">https://leetcode.com/problems/linked-list-cycle/</a></p><p>中文版：<a href="https://leetcode-cn.com/problems/linked-list-cycle/">https://leetcode-cn.com/problems/linked-list-cycle/</a></p><p>Merge k Sorted Lists（合并 k 个排序链表）</p><p>英文版：<a href="https://leetcode.com/problems/merge-k-sorted-lists/">https://leetcode.com/problems/merge-k-sorted-lists/</a></p><p>中文版：<a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">https://leetcode-cn.com/problems/merge-k-sorted-lists/</a></p><p>做完题目之后，你可以点击“请朋友读”，把测试题分享给你的朋友，说不定就帮他解决了一个难题。</p><p>祝你取得好成绩！明天见！</p><h2 id="春节7天练-Day-2：栈、队列和递归"><a href="#春节7天练-Day-2：栈、队列和递归" class="headerlink" title="春节7天练 | Day 2：栈、队列和递归"></a>春节7天练 | Day 2：栈、队列和递归</h2><p>王争 2019-02-05</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp7wjor9n4j30vq0hsn0z.jpg" alt="img"></p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADYAAAABCAYAAACVOl3IAAAAJUlEQVQYV2N89+7df0FBQQYQeP/+PZgGAUJilMpjs4dSM5H1AwBwSSrLZGasMwAAAABJRU5ErkJggg==" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAABCAYAAADeko4lAAAAHUlEQVQYV2N89+7dfwYoEBQUBLPev3/PgItNSC0ADtASy+rFJtUAAAAASUVORK5CYII=" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADoAAAABCAYAAACPBr1GAAAAJ0lEQVQYV2N89+7dfwYoEBQUBLPev3/PQAkbm3mE7KBUHpd7YeYCAE50MMsBeqQ5AAAAAElFTkSuQmCC" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAABCAYAAAAB3PQ6AAAAHUlEQVQYV2N89+7df0FBQQYQeP/+PQMxbLBiIAAAQE0Py6Kq0rkAAAAASUVORK5CYII=" alt="img"></p><p>你好，我是王争。初二好！</p><p>为了帮你巩固所学，真正掌握数据结构和算法，我整理了数据结构和算法中，必知必会的 30 个代码实现，分 7 天发布出来，供你复习巩固所用。今天是第二篇。</p><p>和昨天一样，你可以花一点时间，来完成测验。测验完成后，你可以根据结果，回到相应章节，有针对性地进行复习。</p><h3 id="关于栈、队列和递归的几个必知必会的代码实现"><a href="#关于栈、队列和递归的几个必知必会的代码实现" class="headerlink" title="关于栈、队列和递归的几个必知必会的代码实现"></a>关于栈、队列和递归的几个必知必会的代码实现</h3><p><strong>栈</strong></p><p>用数组实现一个顺序栈</p><p>用链表实现一个链式栈</p><p>编程模拟实现一个浏览器的前进、后退功能</p><p><strong>队列</strong></p><p>用数组实现一个顺序队列</p><p>用链表实现一个链式队列</p><p>实现一个循环队列</p><p><strong>递归</strong></p><p>编程实现斐波那契数列求值 f(n)=f(n-1)+f(n-2)</p><p>编程实现求阶乘 n!</p><p>编程实现一组数据集合的全排列</p><h3 id="对应的-LeetCode-练习题（-Smallfly-整理）-1"><a href="#对应的-LeetCode-练习题（-Smallfly-整理）-1" class="headerlink" title="对应的 LeetCode 练习题（@Smallfly 整理）"></a>对应的 LeetCode 练习题（@Smallfly 整理）</h3><ul><li><strong>栈</strong></li></ul><p>Valid Parentheses（有效的括号）</p><p>英文版：<a href="https://leetcode.com/problems/valid-parentheses/">https://leetcode.com/problems/valid-parentheses/</a></p><p>中文版：<a href="https://leetcode-cn.com/problems/valid-parentheses/">https://leetcode-cn.com/problems/valid-parentheses/</a></p><p>Longest Valid Parentheses（最长有效的括号）</p><p>英文版：<a href="https://leetcode.com/problems/longest-valid-parentheses/">https://leetcode.com/problems/longest-valid-parentheses/</a></p><p>中文版：<a href="https://leetcode-cn.com/problems/longest-valid-parentheses/">https://leetcode-cn.com/problems/longest-valid-parentheses/</a></p><p>Evaluate Reverse Polish Notatio（逆波兰表达式求值）</p><p>英文版：<a href="https://leetcode.com/problems/evaluate-reverse-polish-notation/">https://leetcode.com/problems/evaluate-reverse-polish-notation/</a></p><p>中文版：<a href="https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/">https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/</a></p><ul><li><strong>队列</strong></li></ul><p>Design Circular Deque（设计一个双端队列）</p><p>英文版：<a href="https://leetcode.com/problems/design-circular-deque/">https://leetcode.com/problems/design-circular-deque/</a></p><p>中文版：<a href="https://leetcode-cn.com/problems/design-circular-deque/">https://leetcode-cn.com/problems/design-circular-deque/</a></p><p>Sliding Window Maximum（滑动窗口最大值）</p><p>英文版：<a href="https://leetcode.com/problems/sliding-window-maximum/">https://leetcode.com/problems/sliding-window-maximum/</a></p><p>中文版：<a href="https://leetcode-cn.com/problems/sliding-window-maximum/">https://leetcode-cn.com/problems/sliding-window-maximum/</a></p><ul><li><strong>递归</strong></li></ul><p>Climbing Stairs（爬楼梯）</p><p>英文版：<a href="https://leetcode.com/problems/climbing-stairs/">https://leetcode.com/problems/climbing-stairs/</a></p><p>中文版：<a href="https://leetcode-cn.com/problems/climbing-stairs/">https://leetcode-cn.com/problems/climbing-stairs/</a></p><p>昨天的第一篇，是关于数组和链表的，如果你错过了，点击文末的“上一篇”，即可进入测试。</p><p>祝你取得好成绩！明天见！</p><h2 id="春节7天练-Day-3：排序和二分查找"><a href="#春节7天练-Day-3：排序和二分查找" class="headerlink" title="春节7天练 | Day 3：排序和二分查找"></a>春节7天练 | Day 3：排序和二分查找</h2><p>王争 2019-02-06</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp84d35skyj30vq0hsq51.jpg" alt="img"></p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADYAAAABCAYAAACVOl3IAAAAJUlEQVQYV2N89+7df0FBQQYQeP/+PZgGAUJilMpjs4dSM5H1AwBwSSrLZGasMwAAAABJRU5ErkJggg==" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAABCAYAAADeko4lAAAAHUlEQVQYV2N89+7dfwYoEBQUBLPev3/PgItNSC0ADtASy+rFJtUAAAAASUVORK5CYII=" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADoAAAABCAYAAACPBr1GAAAAJ0lEQVQYV2N89+7dfwYoEBQUBLPev3/PQAkbm3mE7KBUHpd7YeYCAE50MMsBeqQ5AAAAAElFTkSuQmCC" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAABCAYAAAAB3PQ6AAAAHUlEQVQYV2N89+7df0FBQQYQeP/+PQMxbLBiIAAAQE0Py6Kq0rkAAAAASUVORK5CYII=" alt="img"></p><p>你好，我是王争。初三好！</p><p>为了帮你巩固所学，真正掌握数据结构和算法，我整理了数据结构和算法中，必知必会的 30 个代码实现，分 7 天发布出来，供你复习巩固所用。今天是第三篇。</p><p>和昨天一样，你可以花一点时间，来完成测验。测验完成后，你可以根据结果，回到相应章节，有针对性地进行复习。</p><p>前两天的内容，是关于数组和链表、排序和二分查找的。如果你错过了，点击文末的“上一篇”，即可进入测试。</p><h3 id="关于排序和二分查找的几个必知必会的代码实现"><a href="#关于排序和二分查找的几个必知必会的代码实现" class="headerlink" title="关于排序和二分查找的几个必知必会的代码实现"></a>关于排序和二分查找的几个必知必会的代码实现</h3><p><strong>排序</strong></p><p>实现归并排序、快速排序、插入排序、冒泡排序、选择排序</p><p>编程实现 O(n) 时间复杂度内找到一组数据的第 K 大元素</p><p><strong>二分查找</strong></p><p>实现一个有序数组的二分查找算法</p><p>实现模糊二分查找算法（比如大于等于给定值的第一个元素）</p><h3 id="对应的-LeetCode-练习题（-Smallfly-整理）-2"><a href="#对应的-LeetCode-练习题（-Smallfly-整理）-2" class="headerlink" title="对应的 LeetCode 练习题（@Smallfly 整理）"></a>对应的 LeetCode 练习题（@Smallfly 整理）</h3><p>Sqrt(x) （x 的平方根）</p><p>英文版：<a href="https://leetcode.com/problems/sqrtx/">https://leetcode.com/problems/sqrtx/</a></p><p>中文版：<a href="https://leetcode-cn.com/problems/sqrtx/">https://leetcode-cn.com/problems/sqrtx/</a></p><p>做完题目之后，你可以点击“请朋友读”，把测试题分享给你的朋友，说不定就帮他解决了一个难题。</p><p>祝你取得好成绩！明天见！</p><h2 id="春节7天练-Day-4：散列表和字符串"><a href="#春节7天练-Day-4：散列表和字符串" class="headerlink" title="春节7天练 | Day 4：散列表和字符串"></a>春节7天练 | Day 4：散列表和字符串</h2><p>王争 2019-02-08</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp7whpp32aj30vq0hsgpf.jpg" alt="img"></p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADYAAAABCAYAAACVOl3IAAAAJUlEQVQYV2N89+7df0FBQQYQeP/+PZgGAUJilMpjs4dSM5H1AwBwSSrLZGasMwAAAABJRU5ErkJggg==" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAABCAYAAADeko4lAAAAHUlEQVQYV2N89+7dfwYoEBQUBLPev3/PgItNSC0ADtASy+rFJtUAAAAASUVORK5CYII=" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADoAAAABCAYAAACPBr1GAAAAJ0lEQVQYV2N89+7dfwYoEBQUBLPev3/PQAkbm3mE7KBUHpd7YeYCAE50MMsBeqQ5AAAAAElFTkSuQmCC" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAABCAYAAAAB3PQ6AAAAHUlEQVQYV2N89+7df0FBQQYQeP/+PQMxbLBiIAAAQE0Py6Kq0rkAAAAASUVORK5CYII=" alt="img"></p><p>你好，我是王争。初四好！</p><p>为了帮你巩固所学，真正掌握数据结构和算法，我整理了数据结构和算法中，必知必会的 30 个代码实现，分 7 天发布出来，供你复习巩固所用。今天是第四篇。</p><p>和昨天一样，你可以花一点时间，来完成测验。测验完成后，你可以根据结果，回到相应章节，有针对性地进行复习。</p><p>前几天的内容。如果你错过了，点击文末的“上一篇”，即可进入测试。</p><h3 id="关于散列表和字符串的-4-个必知必会的代码实现"><a href="#关于散列表和字符串的-4-个必知必会的代码实现" class="headerlink" title="关于散列表和字符串的 4 个必知必会的代码实现"></a>关于散列表和字符串的 4 个必知必会的代码实现</h3><p><strong>散列表</strong></p><p>实现一个基于链表法解决冲突问题的散列表</p><p>实现一个 LRU 缓存淘汰算法</p><p><strong>字符串</strong></p><p>实现一个字符集，只包含 a～z 这 26 个英文字母的 Trie 树</p><p>实现朴素的字符串匹配算法</p><h3 id="对应的-LeetCode-练习题（-Smallfly-整理）-3"><a href="#对应的-LeetCode-练习题（-Smallfly-整理）-3" class="headerlink" title="对应的 LeetCode 练习题（@Smallfly 整理）"></a>对应的 LeetCode 练习题（@Smallfly 整理）</h3><p><strong>字符串</strong></p><p>Reverse String （反转字符串）</p><p>英文版：<a href="https://leetcode.com/problems/reverse-string/">https://leetcode.com/problems/reverse-string/</a></p><p>中文版：<a href="https://leetcode-cn.com/problems/reverse-string/">https://leetcode-cn.com/problems/reverse-string/</a></p><p>Reverse Words in a String（翻转字符串里的单词）</p><p>英文版：<a href="https://leetcode.com/problems/reverse-words-in-a-string/">https://leetcode.com/problems/reverse-words-in-a-string/</a></p><p>中文版：<a href="https://leetcode-cn.com/problems/reverse-words-in-a-string/">https://leetcode-cn.com/problems/reverse-words-in-a-string/</a></p><p>String to Integer (atoi)（字符串转换整数 (atoi)）</p><p>英文版：<a href="https://leetcode.com/problems/string-to-integer-atoi/">https://leetcode.com/problems/string-to-integer-atoi/</a></p><p>中文版：<a href="https://leetcode-cn.com/problems/string-to-integer-atoi/">https://leetcode-cn.com/problems/string-to-integer-atoi/</a></p><p>做完题目之后，你可以点击“请朋友读”，把测试题分享给你的朋友，说不定就帮他解决了一个难题。</p><p>祝你取得好成绩！明天见！</p><h2 id="春节7天练-Day-5：二叉树和堆"><a href="#春节7天练-Day-5：二叉树和堆" class="headerlink" title="春节7天练 | Day 5：二叉树和堆"></a>春节7天练 | Day 5：二叉树和堆</h2><p>王争 2019-02-09</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp84ddviq9j30vq0hs0uu.jpg" alt="img"></p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADYAAAABCAYAAACVOl3IAAAAJUlEQVQYV2N89+7df0FBQQYQeP/+PZgGAUJilMpjs4dSM5H1AwBwSSrLZGasMwAAAABJRU5ErkJggg==" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAABCAYAAADeko4lAAAAHUlEQVQYV2N89+7dfwYoEBQUBLPev3/PgItNSC0ADtASy+rFJtUAAAAASUVORK5CYII=" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADoAAAABCAYAAACPBr1GAAAAJ0lEQVQYV2N89+7dfwYoEBQUBLPev3/PQAkbm3mE7KBUHpd7YeYCAE50MMsBeqQ5AAAAAElFTkSuQmCC" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAABCAYAAAAB3PQ6AAAAHUlEQVQYV2N89+7df0FBQQYQeP/+PQMxbLBiIAAAQE0Py6Kq0rkAAAAASUVORK5CYII=" alt="img"></p><p>你好，我是王争。春节假期进入尾声了。你现在是否已经准备返回工作岗位了呢？今天更新的是测试题的第五篇，我们继续来复习。</p><h3 id="关于二叉树和堆的-7-个必知必会的代码实现"><a href="#关于二叉树和堆的-7-个必知必会的代码实现" class="headerlink" title="关于二叉树和堆的 7 个必知必会的代码实现"></a>关于二叉树和堆的 7 个必知必会的代码实现</h3><p><strong>二叉树</strong></p><p>实现一个二叉查找树，并且支持插入、删除、查找操作</p><p>实现查找二叉查找树中某个节点的后继、前驱节点</p><p>实现二叉树前、中、后序以及按层遍历</p><p><strong>堆</strong></p><p>实现一个小顶堆、大顶堆、优先级队列</p><p>实现堆排序</p><p>利用优先级队列合并 K 个有序数组</p><p>求一组动态数据集合的最大 Top K</p><h3 id="对应的-LeetCode-练习题（-Smallfly-整理）-4"><a href="#对应的-LeetCode-练习题（-Smallfly-整理）-4" class="headerlink" title="对应的 LeetCode 练习题（@Smallfly 整理）"></a>对应的 LeetCode 练习题（@Smallfly 整理）</h3><p>Invert Binary Tree（翻转二叉树）</p><p>英文版：<a href="https://leetcode.com/problems/invert-binary-tree/">https://leetcode.com/problems/invert-binary-tree/</a></p><p>中文版：<a href="https://leetcode-cn.com/problems/invert-binary-tree/">https://leetcode-cn.com/problems/invert-binary-tree/</a></p><p>Maximum Depth of Binary Tree（二叉树的最大深度）</p><p>英文版：<a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/">https://leetcode.com/problems/maximum-depth-of-binary-tree/</a></p><p>中文版：<a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/</a></p><p>Validate Binary Search Tree（验证二叉查找树）</p><p>英文版：<a href="https://leetcode.com/problems/validate-binary-search-tree/">https://leetcode.com/problems/validate-binary-search-tree/</a></p><p>中文版：<a href="https://leetcode-cn.com/problems/validate-binary-search-tree/">https://leetcode-cn.com/problems/validate-binary-search-tree/</a></p><p>Path Sum（路径总和）</p><p>英文版：<a href="https://leetcode.com/problems/path-sum/">https://leetcode.com/problems/path-sum/</a></p><p>中文版：<a href="https://leetcode-cn.com/problems/path-sum/">https://leetcode-cn.com/problems/path-sum/</a></p><p>做完题目之后，你可以点击“请朋友读”，把测试题分享给你的朋友。</p><p>祝你取得好成绩！明天见！</p><h2 id="春节7天练-Day-6：图"><a href="#春节7天练-Day-6：图" class="headerlink" title="春节7天练 | Day 6：图"></a>春节7天练 | Day 6：图</h2><p>王争 2019-02-10</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp84dbzsjgj30vq0hs40m.jpg" alt="img"></p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADYAAAABCAYAAACVOl3IAAAAJUlEQVQYV2N89+7df0FBQQYQeP/+PZgGAUJilMpjs4dSM5H1AwBwSSrLZGasMwAAAABJRU5ErkJggg==" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAABCAYAAADeko4lAAAAHUlEQVQYV2N89+7dfwYoEBQUBLPev3/PgItNSC0ADtASy+rFJtUAAAAASUVORK5CYII=" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADoAAAABCAYAAACPBr1GAAAAJ0lEQVQYV2N89+7dfwYoEBQUBLPev3/PQAkbm3mE7KBUHpd7YeYCAE50MMsBeqQ5AAAAAElFTkSuQmCC" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAABCAYAAAAB3PQ6AAAAHUlEQVQYV2N89+7df0FBQQYQeP/+PQMxbLBiIAAAQE0Py6Kq0rkAAAAASUVORK5CYII=" alt="img"></p><p>你好，我是王争。初六好！</p><p>为了帮你巩固所学，真正掌握数据结构和算法，我整理了数据结构和算法中，必知必会的 30 个代码实现，分 7 天发布出来，供你复习巩固所用。今天是第六篇。</p><p>和之前一样，你可以花一点时间，来手写这些必知必会的代码。写完之后，你可以根据结果，回到相应章节，有针对性地进行复习。做到这些，相信你会有不一样的收获。</p><h3 id="关于图的几个必知必会的代码实现"><a href="#关于图的几个必知必会的代码实现" class="headerlink" title="关于图的几个必知必会的代码实现"></a>关于图的几个必知必会的代码实现</h3><p><strong>图</strong></p><p>实现有向图、无向图、有权图、无权图的邻接矩阵和邻接表表示方法</p><p>实现图的深度优先搜索、广度优先搜索</p><p>实现 Dijkstra 算法、A* 算法</p><p>实现拓扑排序的 Kahn 算法、DFS 算法</p><h3 id="对应的-LeetCode-练习题（-Smallfly-整理）-5"><a href="#对应的-LeetCode-练习题（-Smallfly-整理）-5" class="headerlink" title="对应的 LeetCode 练习题（@Smallfly 整理）"></a>对应的 LeetCode 练习题（@Smallfly 整理）</h3><p>Number of Islands（岛屿的个数）</p><p>英文版：<a href="https://leetcode.com/problems/number-of-islands/description/">https://leetcode.com/problems/number-of-islands/description/</a></p><p>中文版：<a href="https://leetcode-cn.com/problems/number-of-islands/description/">https://leetcode-cn.com/problems/number-of-islands/description/</a></p><p>Valid Sudoku（有效的数独）</p><p>英文版：<a href="https://leetcode.com/problems/valid-sudoku/">https://leetcode.com/problems/valid-sudoku/</a></p><p>中文版：<a href="https://leetcode-cn.com/problems/valid-sudoku/">https://leetcode-cn.com/problems/valid-sudoku/</a></p><p>做完题目之后，你可以点击“请朋友读”，把测试题分享给你的朋友，说不定就帮他解决了一个难题。</p><p>祝你取得好成绩！明天见！</p><h2 id="春节7天练-Day-7：贪心、分治、回溯和动态规划"><a href="#春节7天练-Day-7：贪心、分治、回溯和动态规划" class="headerlink" title="春节7天练 | Day 7：贪心、分治、回溯和动态规划"></a>春节7天练 | Day 7：贪心、分治、回溯和动态规划</h2><p>王争 2019-02-10</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp7waufhjqj30vq0hsgpe.jpg" alt="img"></p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADYAAAABCAYAAACVOl3IAAAAJUlEQVQYV2N89+7df0FBQQYQeP/+PZgGAUJilMpjs4dSM5H1AwBwSSrLZGasMwAAAABJRU5ErkJggg==" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAABCAYAAADeko4lAAAAHUlEQVQYV2N89+7dfwYoEBQUBLPev3/PgItNSC0ADtASy+rFJtUAAAAASUVORK5CYII=" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADoAAAABCAYAAACPBr1GAAAAJ0lEQVQYV2N89+7dfwYoEBQUBLPev3/PQAkbm3mE7KBUHpd7YeYCAE50MMsBeqQ5AAAAAElFTkSuQmCC" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAABCAYAAAAB3PQ6AAAAHUlEQVQYV2N89+7df0FBQQYQeP/+PQMxbLBiIAAAQE0Py6Kq0rkAAAAASUVORK5CYII=" alt="img"></p><p>你好，我是王争。今天是节后的第一个工作日，也是我们“春节七天练”的最后一篇。</p><h3 id="几种算法思想必知必会的代码实现"><a href="#几种算法思想必知必会的代码实现" class="headerlink" title="几种算法思想必知必会的代码实现"></a>几种算法思想必知必会的代码实现</h3><p><strong>回溯</strong></p><p>利用回溯算法求解八皇后问题</p><p>利用回溯算法求解 0-1 背包问题</p><p><strong>分治</strong></p><p>利用分治算法求一组数据的逆序对个数</p><p><strong>动态规划</strong></p><p>0-1 背包问题</p><p>最小路径和（详细可看 @Smallfly 整理的 Minimum Path Sum）</p><p>编程实现莱文斯坦最短编辑距离</p><p>编程实现查找两个字符串的最长公共子序列</p><p>编程实现一个数据序列的最长递增子序列</p><h3 id="对应的-LeetCode-练习题（-Smallfly-整理）-6"><a href="#对应的-LeetCode-练习题（-Smallfly-整理）-6" class="headerlink" title="对应的 LeetCode 练习题（@Smallfly 整理）"></a>对应的 LeetCode 练习题（@Smallfly 整理）</h3><p>Regular Expression Matching（正则表达式匹配）</p><p>英文版：<a href="https://leetcode.com/problems/regular-expression-matching/">https://leetcode.com/problems/regular-expression-matching/</a></p><p>中文版：<a href="https://leetcode-cn.com/problems/regular-expression-matching/">https://leetcode-cn.com/problems/regular-expression-matching/</a></p><p>Minimum Path Sum（最小路径和）</p><p>英文版：<a href="https://leetcode.com/problems/minimum-path-sum/">https://leetcode.com/problems/minimum-path-sum/</a></p><p>中文版：<a href="https://leetcode-cn.com/problems/minimum-path-sum/">https://leetcode-cn.com/problems/minimum-path-sum/</a></p><p>Coin Change （零钱兑换）</p><p>英文版：<a href="https://leetcode.com/problems/coin-change/">https://leetcode.com/problems/coin-change/</a></p><p>中文版：<a href="https://leetcode-cn.com/problems/coin-change/">https://leetcode-cn.com/problems/coin-change/</a></p><p>Best Time to Buy and Sell Stock（买卖股票的最佳时机）</p><p>英文版：<a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/">https://leetcode.com/problems/best-time-to-buy-and-sell-stock/</a></p><p>中文版：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/</a></p><p>Maximum Product Subarray（乘积最大子序列）</p><p>英文版：<a href="https://leetcode.com/problems/maximum-product-subarray/">https://leetcode.com/problems/maximum-product-subarray/</a></p><p>中文版：<a href="https://leetcode-cn.com/problems/maximum-product-subarray/">https://leetcode-cn.com/problems/maximum-product-subarray/</a></p><p>Triangle（三角形最小路径和）</p><p>英文版：<a href="https://leetcode.com/problems/triangle/">https://leetcode.com/problems/triangle/</a></p><p>中文版：<a href="https://leetcode-cn.com/problems/triangle/">https://leetcode-cn.com/problems/triangle/</a></p><p>到此为止，七天的练习就结束了。这些题目都是我精选出来的，是基础数据结构和算法中最核心的内容。建议你一定要全部手写练习。如果一遍搞不定，你可以结合前面的章节，多看几遍，反复练习，直到能够全部搞定为止。</p><p>学习数据结构和算法，最好的方法就是练习和实践。我相信这在任何知识的学习过程中都适用。</p><p>最后，祝你工作顺利！学业进步！</p><h2 id="【用户故事】-Jerry银银：这一年我的脑海里只有算法"><a href="#【用户故事】-Jerry银银：这一年我的脑海里只有算法" class="headerlink" title="【用户故事】 | Jerry银银：这一年我的脑海里只有算法"></a>【用户故事】 | Jerry银银：这一年我的脑海里只有算法</h2><p>Jerry银银 2019-02-13</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp84d54x8uj30vq0hs0vk.jpg" alt="img"></p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADYAAAABCAYAAACVOl3IAAAAJUlEQVQYV2N89+7df0FBQQYQeP/+PZgGAUJilMpjs4dSM5H1AwBwSSrLZGasMwAAAABJRU5ErkJggg==" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAABCAYAAADeko4lAAAAHUlEQVQYV2N89+7dfwYoEBQUBLPev3/PgItNSC0ADtASy+rFJtUAAAAASUVORK5CYII=" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADoAAAABCAYAAACPBr1GAAAAJ0lEQVQYV2N89+7dfwYoEBQUBLPev3/PQAkbm3mE7KBUHpd7YeYCAE50MMsBeqQ5AAAAAElFTkSuQmCC" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAABCAYAAAAB3PQ6AAAAHUlEQVQYV2N89+7df0FBQQYQeP/+PQMxbLBiIAAAQE0Py6Kq0rkAAAAASUVORK5CYII=" alt="img"></p><p>比尔·盖茨曾说过：“如果你自以为是一个很好的程序员，请去读读 Donald E. Knuth 的《计算机程序设计艺术》吧……要是你真把它读下来了，就毫无疑问可以给我递简历了。”虽然比尔·盖茨推荐的是《计算机程序设计艺术》这本书，但是本质却折射出了算法的重要性。</p><p>大家好，我是 Jerry 银银，购买过算法专栏的同学应该时不时会看到我的留言！目前我是一名 Android 应用开发工程师，主要从事移动互联网教育软件的研发，坐标上海。</p><h3 id="我为何要学算法？"><a href="#我为何要学算法？" class="headerlink" title="我为何要学算法？"></a>我为何要学算法？</h3><p>细细想来，从毕业到现在，7 年多的时间，我的脑海里一直没有停止过思考这样一个问题：<strong>技术人究竟能够走多远，技术人的路究竟该如何走下去</strong>？相信很多技术人应该有同样的感受，因为技术的更新迭代实在是太快了，但是我心里明白：<strong>我得为长远做打算，否则，就算换公司、换工作，可能本质也不会有什么改变</strong>。</p><p>但是，我其实不太清楚自己到底应该往什么地方努力。于是，我翻阅了好多书籍，搜寻 IT 领域各种牛人的观点。多方比较之后，我终于决定，从基础开始，从计算机领域最基础、最重要的一门课开始。毫无疑问，这门课就是数据结构和算法。</p><h3 id="我是如何遇见极客时间的？"><a href="#我是如何遇见极客时间的？" class="headerlink" title="我是如何遇见极客时间的？"></a>我是如何遇见极客时间的？</h3><p>既然找到了方向，那就开始吧。可是问题来了，从哪儿开始呢？大方向虽然有了，可是具体的实现细节还是得慢慢摸索。大学没怎么学，工作这么多年也没有刻意练习，起初我还真不知道从哪儿开始，只是买了本书，慢慢地啃，也找了一些简单的题目开始做。有过自学经历的同学，应该有同感吧？刚开始连单链表翻转这样简单的题都要折腾半天，真心觉得“痛苦”。</p><p>之前我在极客时间上订阅过“Java 核心技术 36 讲”，体会到了专栏和书本的不同。极客时间的专栏作者都是有着丰富的一线开发经验，能很好地把知识和实战结合在一起的大牛。这些课听起来非常爽。估计你应该经常跟我一样感叹：“哦！原来这些知识还可以这么使用！”当时我就在想，极客时间啥时候有一门算法课就好了。</p><p>说来真是巧，没多久，极客时间就推出了“数据结构与算法之美”。我试读了《为什么要学习数据结构和算法》和《数组：为什么很多编程语言中数组都从 0 开始编号？》这两篇之后，立即购买了。</p><p>到现在，专栏学完了，但是我依然记得，王争老师在《为什么要学习数据结构和算法》这篇文章里面提到的三句话，因为这每一句话都刺痛了我的小心脏！</p><p>第一句：业务开发工程师，你真的愿意做一辈子 CRUD Boy 吗？</p><p>第二句：基础架构研发工程师，写出达到开源水平的框架才是你的目标！</p><p>第三句：对编程还有追求？不想被行业淘汰？那就不要只会写凑合能用的代码！</p><h3 id="我每天是怎么学专栏的？"><a href="#我每天是怎么学专栏的？" class="headerlink" title="我每天是怎么学专栏的？"></a>我每天是怎么学专栏的？</h3><p>于是，每天早上醒来，我的第一件事就是听专栏！专栏在每周的一、三、五更新，每周的这三天早上，我会听更新的文章。其它时间，我就听老的文章，当作复习。</p><p>听的过程，我一般会分这么几种情况。</p><p><strong>第一种情况，更新的内容是我之前就已经学过的，基本已经掌握了的</strong>。这种情况下，听起来相对轻松点，基本上听一遍就够了。起床之后，再做一下老师给的思考题。这种情况在专栏的基础部分出现得比较多，像数组、链表、栈、队列、哈希表这些章节，我基本上都是这么过来的。</p><p><strong>第二种情况，更新的内容是我学过的，但是还不太精通的</strong>。这种情况下，王争老师讲的内容都会将我的认知往前“推进”一步。顺利的话，我会在上班之前就搞懂今天更新的内容。这种情况是曾经没有接触过的内容，但是整体来说不难的理解的，比如跳表、递归等。</p><p><strong>还有一种情况，就是听一遍不够，听完再看一遍也不行，上午上班之前也搞不定的</strong>。不过，我也不会急躁。我心里知道，我可能需要换换脑子，说不定，在上午工作期间，灵感会突然冒出来。这种情况一般出现在红黑树、字符串查找算法、动态规划这些章节。</p><p>到了中午休息时间，我会一个人在公司楼下转一圈，同样，还是听专栏、看专栏。</p><p>如果今天的文章，早上已经搞定了，我会重新看下其他同学的留言，看看其他同学是如何思考文章的课后思考题的，还有就是，我会看看其他同学学习过程中，会有哪些疑问，这些疑问自己曾经是否遇到过，现在是否已经完全解决了。</p><p>如果今天的文章，早上没有彻底搞懂，这种情况下，我会极力利用中午的时间去思考。</p><p>晚上的时间通常无法确定，我有时候会加班到很晚，回到家，再去啃算法，效率也不高。所以，我一般会在晚上“看”算法。为什么我会用双引号呢？是因为我真得只是“看”，目的就是加深印象。</p><p>以上基本是我工作日学专栏的“套路”。</p><p>等到了周末或者其它节假日，就是“打攻坚战”的时候了。估计很多上班族和我一样，只有周末才有大量集中思考的时间。这时候，我一般会通过做题来反向推动自己的算法学习。</p><p>像红黑树、Trie 树、递归、动态规划这些内容，我都是在周末和节假日搞懂的。虽然到现在对其中一些知识还不能达到游刃有余的地步，但是对一般的问题，大体上我都知道该如何抽象、如何拆解了。</p><p><img src="https://static001.geekbang.org/resource/image/0c/72/0c441ee9376e974f5112eab4dd7b2672.jpg" alt="img"></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp84d9qp68j315e0u0e81.jpg" alt="img"></p><p>我在学习算法时记的笔记</p><h3 id="通过学习专栏，我有什么不一样的收获？"><a href="#通过学习专栏，我有什么不一样的收获？" class="headerlink" title="通过学习专栏，我有什么不一样的收获？"></a>通过学习专栏，我有什么不一样的收获？</h3><p><strong>首先，专栏学习拓宽了我的知识面。</strong>例如，很多书本不讲的跳表，王争老师用了一篇文章来讲解。犹记得当我看完跳表时，心想，这么简单、易懂、高效的数据结构，为什么很多书籍都没有呢？这个专栏真的买值了！</p><p><strong>其次，专栏的理论和实践结合很强。</strong>书籍是通用性很强的教材，一般很少会涉及软件系统是如何使用具体的数据结构和算法的。在专栏中，老师把对应的知识和实践相互结合，听起来特别过瘾！比如堆这种数据结构，理解起来不难，但是要用好它，还得下点功夫，经过老师一讲解，搭配音频，我的理解也变得更加深入了。</p><p><strong>最后，专栏留言这个功能真的太好了，为自学带来了诸多便利，也让我获得了很多正向反馈。</strong>很多时候，经过相当长的一段时间思考，还是不能打通任督二脉，其实后来回想，当时就差那一层窗户纸了。于是，我在文末留下了自己的疑问，结果王争老师轻描淡写一句话我就明白了。</p><p>留言功能还有个非常大的好处。如果你用心学习，用心思考，用心留言，你的留言很大概率会被同伴点赞，很多时候还能被置顶。这本身就是一种正向反馈，也会更加促进自己的学习动力。还有一种更爽的体验，突然有一天早上，我照例醒来听专栏，突然听到了自己的名字。这个专栏 4 万多人订阅，老师居然记得我！可见王争老师真的认真看了每一条留言。</p><p>最后，我总结下自己学这个专栏的收获。尽管很多，但是我想用三句话来概括。</p><p>第一，写代码的时候，我会很自然地从时间和空间角度去衡量代码的优劣，时间、空间意识被加强了很多。</p><p>第二，学习算法的过程，有很多的“痛苦”，也正是因为这些“痛苦”，我学到了很多知识以外的东西。</p><p>第三，过程可能比知识更重要。要从过程中体会成长和精进的乐趣，而知识是附加产品！</p><p>专栏虽然结束，但是学习并没有结束。同学们，我们开头见！</p><h2 id="【用户故事-】-zixuan：站在思维的高处，才有足够的视野和能力欣赏“美”"><a href="#【用户故事-】-zixuan：站在思维的高处，才有足够的视野和能力欣赏“美”" class="headerlink" title="【用户故事 】| zixuan：站在思维的高处，才有足够的视野和能力欣赏“美”"></a>【用户故事 】| zixuan：站在思维的高处，才有足够的视野和能力欣赏“美”</h2><p>zixuan 2019-02-15</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp84d61adij30vq0hstcy.jpg" alt="img"></p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADYAAAABCAYAAACVOl3IAAAAJUlEQVQYV2N89+7df0FBQQYQeP/+PZgGAUJilMpjs4dSM5H1AwBwSSrLZGasMwAAAABJRU5ErkJggg==" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAABCAYAAADeko4lAAAAHUlEQVQYV2N89+7dfwYoEBQUBLPev3/PgItNSC0ADtASy+rFJtUAAAAASUVORK5CYII=" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADoAAAABCAYAAACPBr1GAAAAJ0lEQVQYV2N89+7dfwYoEBQUBLPev3/PQAkbm3mE7KBUHpd7YeYCAE50MMsBeqQ5AAAAAElFTkSuQmCC" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAABCAYAAAAB3PQ6AAAAHUlEQVQYV2N89+7df0FBQQYQeP/+PQMxbLBiIAAAQE0Py6Kq0rkAAAAASUVORK5CYII=" alt="img"></p><p></p><p>00:12</p><p><a href="javascript:;">1.25x<em></em></a></p><p>讲述：修阳 大小：11.53M 时长：12:35</p><p>大家好，我是 zixuan，在一家国内大型互联网公司做后端开发，坐标深圳，工作 5 年多了。今天和大家分享一下，我学习专栏的一些心得体会。</p><p>随着年龄的增长，我经历了不少业务、技术平台、中间件等多种环境和编程工具的迭代变更。与此同时，我越来越意识到，要做一名优秀的程序员，或者说，能够抵御年龄增长并且增值的程序员，有两样内功是必须持续积累的，那就是<strong>软件工程经验方法</strong>和<strong>算法应用能力</strong>。</p><p>通俗地讲，就是不论在什么系统或业务环境下、用什么编程工具，都能写出高质量、可维护、接口化代码的能力，以及分解并给出一个实际问题有效解决方案的能力。</p><h3 id="我为什么会订阅这个专栏？"><a href="#我为什么会订阅这个专栏？" class="headerlink" title="我为什么会订阅这个专栏？"></a>我为什么会订阅这个专栏？</h3><p>这也是为什么我在极客时间上看到王争老师的“数据结构与算法之美”的开篇词之后，果断地加入学习行列。同时，我也抱有以下两点期望。</p><p>第一，这个专栏是从工程应用，也就是解决实际问题的角度出发来讲算法的，原理和实践相辅相成，现学现用，并且重视思考过程。从我个人经验来看，这的确是比较科学的学习方法。我相信很多人和我一样，以前在学校里都学过算法，不过一旦不碰书了，又没有了应用场景后，很快就把学过的东西丢了，重新拾起来非常困难。</p><p>第二，从专栏的标题看出，王争老师试图带我们感受算法的“美”，那必将要先引导我们站在思维的高处，这样才有足够的视野和能力去欣赏这种“美”。我很好奇他会怎么做，也好奇我能否真正地改变以前的认知，切身地感受到“美”。</p><h3 id="我是如何学习这个专栏的？"><a href="#我是如何学习这个专栏的？" class="headerlink" title="我是如何学习这个专栏的？"></a>我是如何学习这个专栏的？</h3><p>就这样，同时带着笃定和疑问，我上路了。经过几个月的认真学习，“数据结构与算法之美”成了我在极客时间打开次数最多，花费时间最多，完成度也最高的一门课。<strong>尽管如此，我觉得今后我很可能还会再二刷、多刷<strong><strong>这门课</strong></strong>，把它作为一个深入学习的索引入口。</strong> 接下来，我就从几个方面，跟你分享下，这半年我学习这个专栏的一些感受和收获。</p><h3 id="1-原理和实用并重：从实践中总结，应用到实践中去"><a href="#1-原理和实用并重：从实践中总结，应用到实践中去" class="headerlink" title="1. 原理和实用并重：从实践中总结，应用到实践中去"></a>1. 原理和实用并重：从实践中总结，应用到实践中去</h3><p>学习的最终目的是为了解决实际问题，专栏里讲的很多方法甚至代码，都能够直接应用到大型项目中去，而不仅仅是简单的原理示例。</p><p>比如王争老师在讲散列表的时候，讲了实现一个工业级强度的散列表有哪些需要注意的点。基本上面面俱到，我在很多标准库里都找到了印证。再比如，老师讲的 LRU Cache、Bloom Filter、范围索引上的二分查找等等，也基本和我之前阅读 LevelDB 源代码时，看到的实现细节如出一辙，无非是编程语言的差别。</p><p>所以，看这几部分的时候，我觉得十分惊喜，因为我经历过相关的实际应用场景。反过来，专栏这种原理和实用并重的风格，也能帮助我今后在阅读开源代码时提升效率、增进理解。</p><p>另外，我觉察到，文章的组织结构，应该也是老师试图传达给我们的“他自己的学习方法”：从开篇介绍一个经典的实际问题开始（需求），到一步步思考引导（分析），再到正式引出相关的数据结构和算法（有效解决方案），再将其应用于开篇问题的解决（实现、测试），最后提出一个课后思考题（泛化、抽象、交流、提升）。</p><p>这个形式其实和解决实际工程问题的过程非常类似。我想，大部分工程师就是在一个个这样的过程中不断积累和提升自己的，所以我觉得这个专栏，不论是内容还是形式真的都很赞。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp84d1lnl5j30vq0frq5i.jpg" alt="img"></p><h3 id="2-学习新知识的角度：体系、全面、严谨、精炼，可视化配图易于理解"><a href="#2-学习新知识的角度：体系、全面、严谨、精炼，可视化配图易于理解" class="headerlink" title="2. 学习新知识的角度：体系、全面、严谨、精炼，可视化配图易于理解"></a>2. 学习新知识的角度：体系、全面、严谨、精炼，可视化配图易于理解</h3><p>“全面”并不是指所有细节面面俱到。事实上，由于算法这门学科本身庞大的体量，这类专栏一般只能看作一个丰富的综述目录，或者深入学习的入口。尽管如此，王争老师依然用简洁精炼的语言 Cover 到了几乎所有最主要的数据结构和算法，以及它们背后的本质思想、原理和应用场景，知识体系结构全面完整并自成一体。</p><p>我发现只要能紧跟老师的思路，把每一节的内容理解透彻，到了语言实现部分，往往变成了一种自然的总结描述，所以代码本身并不是重点，重点是背后的思路。</p><p>例如，KMP 单模式串匹配和 AC 自动机多模式串匹配算法是我的知识盲区。以前读过几次 KMP 的代码，都没完全搞懂，于是就放弃了。至于 AC 自动机，惭愧地说，我压根儿就没怎么听说过。</p><p>但是，在专栏里，王争老师从 BruteForce 方法讲起，经过系统的优化思路铺垫，通俗的举例，再结合恰到好处的配图，最后给出精简的代码。我跟随着老师一路坚持下来，当我看到第二遍时突然就豁然开朗了。而当我真正理解了 AC 自动机的构建和工作原理之后，在某一瞬间，我的内心的确生出了一种美的感觉（或者更多的是“妙”吧？）。</p><p>AC 自动机构建的代码，让我不自觉地想到“编织”这个词。之前还觉得凌乱的、四处喷洒的指针，在这里一下子变成了一张有意义的网，编织的过程和成品都体现出了算法的巧妙。这类联想无疑加深了我对这类算法的理解，也许这也意味着，我可以把它正式加入到自己的算法工具箱里了。</p><p>另外一个例子是动态规划。以前应用 DP 的时候，我常常比较盲目，不知道怎么确定状态的表示，甚至需要几维的状态都不清楚，可以说是在瞎猜碰运气。经过老师从原理到实例的系统讲解后，我现在明白，原来 DP 本质上就是在压缩重复子问题，状态的定义可以通过最直接的回溯搜索来启发确定。明白这些之后，动态规划也被我轻松拿下了。</p><h3 id="3-已有知识加深的角度：促进思考，连点成线"><a href="#3-已有知识加深的角度：促进思考，连点成线" class="headerlink" title="3. 已有知识加深的角度：促进思考，连点成线"></a>3. 已有知识加深的角度：促进思考，连点成线</h3><p>之前看目录的时候，我发现专栏里包含了不少我已经知道的知识。但真正学习了之后，我发现，以前头脑中的不少概念知识点，是相对独立存在的，基本上一个点就对应固定的那几个场景，而在专栏里，王争老师比较注重概念之间的相互关联。对于这些知识，经过王争老师的讲解，基本可以达到交叉强化理解，甚至温故知新的效果。</p><p>比如老师会问你，在链表上怎么做二分查找？哈希和链表为什么经常在一起出现？这些问题我之前很少会考虑到，但是当我看到的时候，却启发出很多新的要点和场景（比如 SkipList、LRUCache）。</p><p>更重要的是，跟着专栏学习一段时间之后，我脑中原本的一些旧概念，也开始自发地建立起新的连接，连点成线，最后产生了一些我之前从未注意到的想法。</p><p>举个感触最深的例子。在跟随专栏做了大量递归状态跟进推演，以及递归树分析后，我现在深刻地认识到，递归这种编程技巧背后，其实是树和堆栈这两种看似关联不大的数据结构。为什么这么说呢？</p><p>堆栈和树在某个层面上，其实有着强烈的对应关系。我刚接触递归的时候，和大多数初学者一样，脑子很容易跟着机器执行的顺序往深里绕，就像 Debug 一个很深的函数调用链一样，每遇到一个函数就 step into，也就是递归函数展开 -&gt; 下一层 -&gt; 递归函数展开 -&gt; 下一层 -&gt;…，结果就是只有“递”，没有“归”，大脑连一次完整调用的一半都跑不完（或者跑完一次很辛苦），自然就会觉得无法分析。如下图，每个圈代表在某一层执行的递归函数，向下的箭头代表调用并进入下一层。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp84d5f8lfj30vq0kognm.jpg" alt="img"></p><p>我初学递归时遇到的问题：有去无回，陷得太深</p><p>随着我处理了越来越多的递归，我慢慢意识到，为什么人的思考一定要 follow 机器的执行呢？在递归函数体中，我完全可以不用每遇到递归调用都展开并进入下一层（step into），而是可以直接假定下一层调用能够正确返回，然后我该干嘛就继续干嘛（step over），这样的话，我只需要保证最深一层的逻辑，也就是递归的终止条件正确即可。</p><p>原因也很简单，不管在哪一层，都是在执行递归函数这同一份代码，不同的层只有一些状态数据不同而已，所以我只需要保证递归函数代码逻辑的正确性，就确保了运行时任意一层的结果正确性。像这样说服自己可以随时 step over 后，我的大脑终于有“递”也有“归”了，后续事务也就能够推动了。</p><p><img src="https://static001.geekbang.org/resource/image/5d/f8/5d42370f6823b1ed97d5d86d773ac0f8.jpg" alt="img"></p><p>有一定经验后我如何思考递归：有去有回，自由把握</p><p>最近在学习这门课程的过程中，我进一步认识到，其实上面两个理解递归的方式，分别对应递归树的深度遍历和广度遍历。尽管机器只能按照深度优先的方式执行递归代码，但人写递归代码的时候更适合用广度的思考方式。当我在实现一个递归函数的时候，其实就是在确定这棵树的整体形状：什么时候终止，什么条件下生出子树，也就是说我实际上是在编程实现一棵树。</p><p>那递归树和堆栈又有什么关系呢？递归树中从根节点到树中任意节点的路径，都对应着某个时刻的函数调用链组成的堆栈。递归越深的节点越靠近栈顶，也越早返回。因而我们可以说，递归的背后是一棵树，递归的执行过程，就是在这棵树上做深度遍历的过程，每次进入下一层（“递”）就是压栈，每次退出当前层（“归”）就是出栈。所有的入栈、出栈形成的脉络就组成了递归树的形态。递归树是静态逻辑背景，而当前活跃堆栈是当前动态运行前景。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp84dcjj0ej30vq0fywg7.jpg" alt="img"></p><p>学完专栏后我怎么看待递归：胸有成“树”，化动为静</p><p>这样理解之后，编写或阅读递归代码的时候，我真的能够站得更高，看得更全面，也更不容易掉入一些细节陷阱里去了。</p><p>说到这里，我想起之前在不同时间做过的两道题，一道是计算某个长度为 n 的入栈序列可以有多少种出栈序列，另一道是计算包含 n 个节点的二叉树有多少种形状。我惊讶地发现，这两个量竟然是相等的（其实就是卡特兰数）。当时我并不理解为什么栈和树会存在这种关联，现在通过类似递归树的思路我觉得我能够理解了，那就是每种二叉树形状的中序遍历都能够对应上一种出栈顺序。</p><p>类似这样“旧知识新理解”还有很多，尽管专栏里并没有直接提到，但是这都是我跟随专栏，坚持边学边思考，逐步感受和收获的。</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>基于以上谈的几点收获和感受，我再总结下我认为比较有用的、学习这个专栏的方法。</p><p><strong>1. 紧跟老师思路走，尽量理解每一句话、每一幅配图，亲手推演每一个例子。</strong></p><p>王争老师语言精炼。有些文字段落虽短，但背后的信息量却很大。为了方便我们理解，老师用了大量的例子和配图来讲解。即便是非常复杂、枯燥的理论知识，我们理解起来也不会太吃力。</p><p>当然有些地方确实有点儿难，这时我们可以退而求其次，“先保接口，再求实现”。例如，红黑树保持平衡的具体策略实现，我跟不下来，就暂时跳过去了，但是我只要知道，它是一种动态数据的高效平衡树，就不妨碍我先使用这个工具，之后再慢慢理解。</p><p><strong>2. 在学的过程中回顾和刷新老知识点，并往工程实践上靠。学以致用是最高效的方法</strong>。</p><p><strong>3. 多思考，思考比结果重要；多交流，亲身感受和其他同学一起交流帮助很大。</strong></p><p>最后，感谢王争老师和极客时间，让我在这个专栏里有了不少新收获。祝王争老师事业蒸蒸日上，继续开创新品，也希望极客时间能够联合更多的大牛老师，开发出更多严谨又实用的精品课程！</p><h2 id="结束语-送君千里，终须一别"><a href="#结束语-送君千里，终须一别" class="headerlink" title="结束语 | 送君千里，终须一别"></a>结束语 | 送君千里，终须一别</h2><p>王争 2019-02-20</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp84dfe15cj30vq0hstcw.jpg" alt="img"></p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADYAAAABCAYAAACVOl3IAAAAJUlEQVQYV2N89+7df0FBQQYQeP/+PZgGAUJilMpjs4dSM5H1AwBwSSrLZGasMwAAAABJRU5ErkJggg==" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAABCAYAAADeko4lAAAAHUlEQVQYV2N89+7dfwYoEBQUBLPev3/PgItNSC0ADtASy+rFJtUAAAAASUVORK5CYII=" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADoAAAABCAYAAACPBr1GAAAAJ0lEQVQYV2N89+7dfwYoEBQUBLPev3/PQAkbm3mE7KBUHpd7YeYCAE50MMsBeqQ5AAAAAElFTkSuQmCC" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAABCAYAAAAB3PQ6AAAAHUlEQVQYV2N89+7df0FBQQYQeP/+PQMxbLBiIAAAQE0Py6Kq0rkAAAAASUVORK5CYII=" alt="img"></p><p>专栏到今天真的要结束了。在写这篇结束语的时候，我的心情还是蛮复杂的，既有点如释重负，又有点不舍。如释重负，是因为我自己对专栏的整体质量非常满意；不舍，是因为我还想分享更多“压箱底”的东西给你。</p><p>专栏是在 2018 年 9 月发布的。在发布后的两三天时间里，就有 2 万多人订阅，同时也引来了很多争议。有人说，我就是随便拿个目录就来“割韭菜”。也有人说，数据结构和算法的书籍那么多，国外还有那么多动画、视频教程，为什么要来学我的专栏？</p><p>这些质疑我都非常理解，毕竟大部分基础学科的教材，的确是国外的更全面。实际上，在专栏构思初期，我就意识到了这一点。不夸张地讲，我几乎读过市面上所有有关数据结构和算法的书籍，所以，我也深知市面上的数据结构和算法书籍存在的问题。</p><p>尽管有很多书籍讲得通俗易懂，也有很多书籍全面、经典，但是大部分都偏理论，书中的例子也大多脱离真实的软件开发。这些书籍毫无疑问是有用的，但是看完书之后，很多人只是死记硬背了一些知识点而已。这样填鸭式的学习，对于锻炼思维、开拓眼界并没有太多作用。而且，从基础理论到应用实践，有一个非常大的鸿沟要跨越，这是大学教育的普遍不足之处，这也是为什么我们常常觉得大学里学过的很多知识都没用。</p><p>我本人是一个追求完美、极致的人，凡事都想做到最好，都想争第一。所以，就我个人而言，我也不允许自己写一个“太普通”“烂大街”的专栏。那时我就给自己立了一个 flag：我一定要写一个跟所有国内、国外经典书籍都不一样的专栏，写出一个可以长期影响一些人的专栏。</p><p>所以，在这个专栏写作过程中，我力争并非只是单纯地把某个知识点讲清楚，而是结合自己的理解、实践和经验来讲解。我写每篇文章的时候，几乎都是从由来讲起，做到让你知其然、知其所以然，并且列举大量的实际软件开发中的场景，给你展示如何利用数据结构和算法解决真实的问题。</p><p>除此之外，课后思考题我也不拿一些现成的 LeetCode 的题目来应付。这些题目都是我精心设计的、贴合具体实践、非常考验逻辑思维的问题。毫不夸张地讲，只把这些课后思考题做个解答，就可以写成一个有价值、有干货的专栏！</p><p>专栏到今天就要结束了。尽管有些内容稍有瑕疵，但我觉得我实现了最初给自己立下的 flag。那你又学得怎么样呢？</p><p>如果这是你第一次接触数据结构和算法，只是跟着学一遍，你可能不会完全理解所有的内容。关于这个专栏，我从来也不想标榜，我的专栏是易懂到地铁里听听就可以的。因为你要知道，没有难度的学习，也就没有收获。所以，作为初学者，你要想真的拿下数据结构和算法，时间允许的话，建议你再二刷、三刷。</p><p>如果你是有一定基础的小伙伴，希望你能够真的做到学以致用。在开发项目、阅读开源代码、理解中间件架构设计方面，多结合数据结构和算法，从本质上理解原理，掌握创新的源头。</p><p>如果你是数据结构和算法高手，那我的专栏应该也没有让你失望吧？我个人觉得，专栏里还是有很多可以给你惊喜的地方。对于你来说，哪怕只学到了一个之前没有接触的知识点，我觉得其实已经值得了。</p><p>送君千里终须一别。数据结构和算法的学习，我暂时只能陪你到这里了。感谢你订阅我的专栏，感谢这 5 个月的同行，真心希望我的专栏能对你有所帮助。</p><p>我知道，很多小伙伴都是“潜水党”，喜欢默默地学习，在专栏要结束的今天，我希望能听到你的声音，希望听听你学习这个专栏的感受和收获。最后，再次感谢！</p><p><a href="http://bbn7rz69sba2z1ns.mikecrm.com/vphthhO"><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp84d2sa48j30vq0m9q8x.jpg" alt="img"></a></p><h2 id="第2季回归-这一次，我们一起拿下设计模式！"><a href="#第2季回归-这一次，我们一起拿下设计模式！" class="headerlink" title="第2季回归 | 这一次，我们一起拿下设计模式！"></a>第2季回归 | 这一次，我们一起拿下设计模式！</h2><p>王争 2019-11-04</p><p><img src="https://static001.geekbang.org/resource/image/26/89/26846808b35a081f985418258200b489.jpg" alt="img"></p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADYAAAABCAYAAACVOl3IAAAAJUlEQVQYV2N89+7df0FBQQYQeP/+PZgGAUJilMpjs4dSM5H1AwBwSSrLZGasMwAAAABJRU5ErkJggg==" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAABCAYAAADeko4lAAAAHUlEQVQYV2N89+7dfwYoEBQUBLPev3/PgItNSC0ADtASy+rFJtUAAAAASUVORK5CYII=" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADoAAAABCAYAAACPBr1GAAAAJ0lEQVQYV2N89+7dfwYoEBQUBLPev3/PQAkbm3mE7KBUHpd7YeYCAE50MMsBeqQ5AAAAAElFTkSuQmCC" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAABCAYAAAAB3PQ6AAAAHUlEQVQYV2N89+7df0FBQQYQeP/+PQMxbLBiIAAAQE0Py6Kq0rkAAAAASUVORK5CYII=" alt="img"></p><p>你好，我是王争。“数据结构与算法之美”在今年 2 月底全部更新完毕。时隔 8 个月，我又为你带来了一个新的专栏“设计模式之美”。如果说“数据结构与算法之美”是教你如何写出高效的代码，那“设计模式之美”就是教你如何写出高质量的代码。</p><p>在设计“设计模式之美”专栏的时候，我仍然延续“数据结构与算法之美”的讲述方式。在专栏的整体设计上，我希望尽量还原一对一、手把手 code review 的场景，通过 100 篇正文和 10 篇不定期加餐，200 多个真实的项目实战代码案例剖析，100 多个有深度的课堂讨论、头脑风暴，来为你交付这个“设计模式之美”专栏。</p><p>我希望通过这个专栏，一次性把跟编写高质量代码相关的所有知识，都系统、全面地讲清楚，一次性给你讲透彻。让你看完这个专栏，就能搞清楚所有跟写高质量代码相关的知识点。</p><p>专栏共 100 期正文和 10 期不定期加餐，分为 5 个模块。下面是专栏的目录：</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp84d8z52rj30ku5aae82.jpg" alt="img"></p><p>为了感谢老同学，我为你准备了一个专属福利：</p><p>11 月 4 日，专栏上新时，我会送你一张 30 元专属优惠券，可与限时优惠同享，有效期 48 小时，建议尽早使用。点击下方图片，立即免费试读新专栏。</p><p>一段新的征程，期待与你一起见证成长！</p><h2 id="打卡召集令-60-天攻克数据结构与算法"><a href="#打卡召集令-60-天攻克数据结构与算法" class="headerlink" title="打卡召集令 | 60 天攻克数据结构与算法"></a>打卡召集令 | 60 天攻克数据结构与算法</h2><p>王争 2019-11-22</p><p>今年 4 月，专栏更新结束之后，我在专栏发布了一篇《数据结构与算法之美》学习指导手册》，在这篇文章里，我对专栏内容重新做了一次梳理，将整个专栏拆分成四个阶段，列出了每个阶段的核心知识点、标注了每个知识点的难易程度（E-Easy，M-Medium，H-Hard），并用 1-10 分说明其重要性。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp84dbphijj310s0u04qp.jpg" alt="img"></p><p>但是，我发现，很多同学还是没能坚持下来，久而久之对学习算法失去了信心。</p><p>回想起来，写专栏之初，我就立下 Flag，要做一个跟国内外经典书籍不一样、可以长期影响一些人的专栏。所以，在专栏完结 9 个月后，我想再做一些事情。</p><p>为了带你彻底拿下“数据结构与算法”这座大山，我发起了<strong>“60 天攻克数据结构与算法”打卡行动</strong>，一起登顶！</p><p>下面是我为你精心规划的学习计划表：</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp84d807caj30ku696npd.jpg" alt="img"></p><p><strong>活动时间</strong>：2019.11.25-2020.1.19</p><p><strong>你将获得</strong>：</p><p>\1. 坚持 60 天，与 2000 位优秀的工程师一起，彼此激励，相互学习；</p><p>\2. 整个学习周期内，我会进行 2 次高质量的社群分享；</p><p>\3. 我会精心整理 4 张知识脑图，为你梳理每个阶段的学习重点，发布在专栏里；</p><p>\4. 我和极客时间准备了 20 万奖学金，给坚持下来的同学。</p><p><strong>活动规则</strong>：</p><p>在下方申请进入活动打卡群，根据课表打卡，完成学习。</p><p><a href="https://jinshuju.net/f/DYtafE"><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp84cyfiwvj30ku04mq3n.jpg" alt="img"></a></p><p><strong>打卡要求</strong>：</p><p>\1. 每个阶段持续 2 周，每周仅需打卡 3 次，即视为完成该阶段的学习。</p><p>2.4 个阶段（8 周）的学习，打卡总数仅需 30 次，即视为完成“60 天攻克数据结构与算法行动”。</p><p>\3. 为了让大家养成习惯，每日只计 1 次打卡，单日内多次打卡视为 1 次。</p><p><strong>进入打卡群后，完成学习还有如下奖励</strong>：</p><p>第一阶段（第 1-2 周）：¥15 奖励金</p><p>第二阶段（第 3-4 周）：¥25 奖励金</p><p>第三阶段（第 5-6 周）：¥35 奖励金</p><p>四个阶段（第 7-8 周）：¥50 奖励金</p><p>（注：奖励金会以无门槛优惠券形式、分阶段进行发放，发放时间为每阶段结束后的 7 个工作日内。）</p><p>当然，优惠券只是对你的小小奖励。坚持 60 天，与 2000 位优秀的工程师一起，互相学习，彼此激励，彻底拿下数据结构与算法，我奉陪到底。</p><h2 id="打卡召集令-第一阶段知识总结"><a href="#打卡召集令-第一阶段知识总结" class="headerlink" title="打卡召集令 | 第一阶段知识总结"></a>打卡召集令 | 第一阶段知识总结</h2><p>王争、阿锦 2019-12-09</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADYAAAABCAYAAACVOl3IAAAAJUlEQVQYV2N89+7df0FBQQYQeP/+PZgGAUJilMpjs4dSM5H1AwBwSSrLZGasMwAAAABJRU5ErkJggg==" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAABCAYAAADeko4lAAAAHUlEQVQYV2N89+7dfwYoEBQUBLPev3/PgItNSC0ADtASy+rFJtUAAAAASUVORK5CYII=" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADoAAAABCAYAAACPBr1GAAAAJ0lEQVQYV2N89+7dfwYoEBQUBLPev3/PQAkbm3mE7KBUHpd7YeYCAE50MMsBeqQ5AAAAAElFTkSuQmCC" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAABCAYAAAAB3PQ6AAAAHUlEQVQYV2N89+7df0FBQQYQeP/+PQMxbLBiIAAAQE0Py6Kq0rkAAAAASUVORK5CYII=" alt="img"></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp84daf8smj30u05st1kz.jpg" alt="img"></p><h2 id="打卡召集令-第二阶段知识总结"><a href="#打卡召集令-第二阶段知识总结" class="headerlink" title="打卡召集令 | 第二阶段知识总结"></a>打卡召集令 | 第二阶段知识总结</h2><p>王争、阿锦 2019-12-23</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADYAAAABCAYAAACVOl3IAAAAJUlEQVQYV2N89+7df0FBQQYQeP/+PZgGAUJilMpjs4dSM5H1AwBwSSrLZGasMwAAAABJRU5ErkJggg==" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAABCAYAAADeko4lAAAAHUlEQVQYV2N89+7dfwYoEBQUBLPev3/PgItNSC0ADtASy+rFJtUAAAAASUVORK5CYII=" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADoAAAABCAYAAACPBr1GAAAAJ0lEQVQYV2N89+7dfwYoEBQUBLPev3/PQAkbm3mE7KBUHpd7YeYCAE50MMsBeqQ5AAAAAElFTkSuQmCC" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAABCAYAAAAB3PQ6AAAAHUlEQVQYV2N89+7df0FBQQYQeP/+PQMxbLBiIAAAQE0Py6Kq0rkAAAAASUVORK5CYII=" alt="img"></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp84dd3xh3j30u04nchdt.jpg" alt="img"></p><h2 id="打卡召集令-第三阶段知识总结"><a href="#打卡召集令-第三阶段知识总结" class="headerlink" title="打卡召集令 | 第三阶段知识总结"></a>打卡召集令 | 第三阶段知识总结</h2><p>王争、阿锦 2020-01-06</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADYAAAABCAYAAACVOl3IAAAAJUlEQVQYV2N89+7df0FBQQYQeP/+PZgGAUJilMpjs4dSM5H1AwBwSSrLZGasMwAAAABJRU5ErkJggg==" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAABCAYAAADeko4lAAAAHUlEQVQYV2N89+7dfwYoEBQUBLPev3/PgItNSC0ADtASy+rFJtUAAAAASUVORK5CYII=" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADoAAAABCAYAAACPBr1GAAAAJ0lEQVQYV2N89+7dfwYoEBQUBLPev3/PQAkbm3mE7KBUHpd7YeYCAE50MMsBeqQ5AAAAAElFTkSuQmCC" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAABCAYAAAAB3PQ6AAAAHUlEQVQYV2N89+7df0FBQQYQeP/+PQMxbLBiIAAAQE0Py6Kq0rkAAAAASUVORK5CYII=" alt="img"></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp84d0pubvj30u02aykjn.jpg" alt="img"></p><h2 id="打卡召集令-第四阶段知识总结"><a href="#打卡召集令-第四阶段知识总结" class="headerlink" title="打卡召集令 | 第四阶段知识总结"></a>打卡召集令 | 第四阶段知识总结</h2><p>王争、阿锦 2020-01-20</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADYAAAABCAYAAACVOl3IAAAAJUlEQVQYV2N89+7df0FBQQYQeP/+PZgGAUJilMpjs4dSM5H1AwBwSSrLZGasMwAAAABJRU5ErkJggg==" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAABCAYAAADeko4lAAAAHUlEQVQYV2N89+7dfwYoEBQUBLPev3/PgItNSC0ADtASy+rFJtUAAAAASUVORK5CYII=" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADoAAAABCAYAAACPBr1GAAAAJ0lEQVQYV2N89+7dfwYoEBQUBLPev3/PQAkbm3mE7KBUHpd7YeYCAE50MMsBeqQ5AAAAAElFTkSuQmCC" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAABCAYAAAAB3PQ6AAAAHUlEQVQYV2N89+7df0FBQQYQeP/+PQMxbLBiIAAAQE0Py6Kq0rkAAAAASUVORK5CYII=" alt="img"></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp84cz41t3j30u01qou0y.jpg" alt="img"></p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp9afl3z98j30tc0gugxh.jpg" alt="image-20210405233140116"></p><p>答案：C</p><h6 id="题目解析-6"><a href="#题目解析-6" class="headerlink" title="题目解析"></a>题目解析</h6><p>基础概念，单向循环链表且带有头节点，判断为空，即循环链表只有头节点，自己指向自己，head-&gt;next = head，因此选 C。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp9aqmkt94j30w40luavt.jpg" alt="image-20210405234217284"></p><p>答案：D</p><h6 id="题目解析-7"><a href="#题目解析-7" class="headerlink" title="题目解析"></a>题目解析</h6><p>递归次数，取决于递归树，而递归树取决于轴枢的选择。树越平衡，递归次数越少。</p><p>而对分区的长短处理顺序，影响的是递归时对栈的使用内存，而不是递归次数。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp9arg087wj30u60jak52.jpg" alt="image-20210405234304622"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">答案：A</span><br><span class="line">题目解析</span><br><span class="line">尾递归是指，在函数返回的时候，调用自身本身，并且 return 语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。 尾递归调用时，如果做了优化，栈不会增长，因此，无论多少次调用也不会导致栈溢出。</span><br><span class="line"></span><br><span class="line">以斐波那契数列为例子，普通的递归版本如下：</span><br><span class="line"></span><br><span class="line">`int fab(int n)&#123;</span><br><span class="line"></span><br><span class="line">if(n&lt;3)</span><br><span class="line"></span><br><span class="line">return 1;</span><br><span class="line"></span><br><span class="line">else</span><br><span class="line"></span><br><span class="line">return fab(n-1)+fab(n-2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">具有 &quot; 线性迭代过程 &quot; 特性的递归—尾递归过程</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int fab(int n,int b1=1,int b2=1,int c=3)&#123;</span><br><span class="line"></span><br><span class="line">if(n&lt;3)</span><br><span class="line"></span><br><span class="line">return 1;</span><br><span class="line"></span><br><span class="line">else &#123;</span><br><span class="line"></span><br><span class="line">if(n==c)</span><br><span class="line"></span><br><span class="line">return b1+b2;</span><br><span class="line"></span><br><span class="line">else</span><br><span class="line"></span><br><span class="line">return fab1(n,b2,b1+b2,c+1);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; `</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">以 fab(4) 为例子</span><br><span class="line"></span><br><span class="line">普通递归 fab(4)=fab(3)+fab(2)=fab(2)+fab(1)+fab(2)=3 6 次调用</span><br><span class="line"></span><br><span class="line">尾递归 fab(4,1,1,3)=fab(4,1,2,4)=1+2=3</span><br><span class="line"></span><br><span class="line">2 次调用</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp9atgzqszj30q80hm48d.jpg" alt="image-20210405234501814"></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp9au42g2qj30s00h2dqa.jpg" alt="image-20210405234537327"></p><p>答案：A</p><h6 id="题目解析-8"><a href="#题目解析-8" class="headerlink" title="题目解析"></a>题目解析</h6><p>BFS 是广度优先遍历，DFS 是深度优先遍历。</p><p>对于一些特殊的图，比如只有一个顶点的图，其 BFS 生成树的树高和 DFS 生成树的树高相等。 一般的图，根据图的 BFS 生成树和 DFS 树的算法思想，BFS 生成树的树高比 DFS 生成树的树高小。</p><h2 id="菜鸟面试"><a href="#菜鸟面试" class="headerlink" title="菜鸟面试"></a>菜鸟面试</h2><p>菜鸟4.6一面面经</p><p>\1. 自我介绍</p><p>\2. 介绍一下项目中的作用以及学到了什么 3. 数据库</p><p>\1. 数据库中的锁</p><p>\2. 具体场景题，一个update 语句跟一个select语句之间的可读性问题 3. 幻读问题</p><p>\4. 有用过哪些数据结构</p><p>\1. ArrayList</p><p>\2. LinkedList</p><p>\3. 红黑树的查找效率，为什么数据库索引不使用红黑树 4. 为什么HashMap不使用B+树</p><p>\5. HashMap查找时间复杂度</p><p>\5. 计算机网络</p><p>\1. 有三十个http请求能不能一次连接发完</p><p>\2. 四次挥手的Close_wait要怎么解决过多的问题</p><p>\3. 好多不记得了</p><p>\6. 算法</p><p>\1. 找出100个数中的前三个，用哪个方法比较次数最少，比较多少次</p><p>\2. 最大堆要比较多少次</p><p>\3. 快排多少次</p><p>\4. 分治能不能保证第二名一定是排第二的</p><p>\5. 二叉树的树高怎么求，公式是怎么推导的</p><p>\7. java语言</p><p>\1. String s = “中国人”，char数组存，byte存，分别占几个字节 2. String怎么转换成Byte</p><p>\3. 这三者1.8种怎么转换的</p><p>出自【1】<a name='toc1'></a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="">参考1</a><a href="#toc1">🔼</a></li><li></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;不定期福利第一期-数据结构与算法学习书单&quot;&gt;&lt;a href=&quot;#不定期福利第一期-数据结构与算法学习书单&quot; class=&quot;headerlink&quot; title=&quot;不定期福利第一期 | 数据结构与算法学习书单&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="编程" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>⭐️数据结构与算法之美（高级篇 &amp; 实战篇）</title>
    <link href="http://example.com/2021/04/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%EF%BC%88%E9%AB%98%E7%BA%A7%E7%AF%87%EF%BC%89/"/>
    <id>http://example.com/2021/04/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%EF%BC%88%E9%AB%98%E7%BA%A7%E7%AF%87%EF%BC%89/</id>
    <published>2021-04-01T16:00:00.000Z</published>
    <updated>2022-01-15T15:41:53.289Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><span id="more"></span><h1 id=""><a href="#" class="headerlink" title="======================================="></a>=======================================</h1><h1 id="高级篇-43-51（9讲）"><a href="#高级篇-43-51（9讲）" class="headerlink" title="高级篇 43-51（9讲）"></a>高级篇 43-51（9讲）</h1><h1 id="43-拓扑排序：如何确定代码源文件的编译依赖关系？"><a href="#43-拓扑排序：如何确定代码源文件的编译依赖关系？" class="headerlink" title="43 | 拓扑排序：如何确定代码源文件的编译依赖关系？"></a>43 | 拓扑排序：如何确定代码源文件的编译依赖关系？</h1><p>王争 2019-01-04</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp83dzmq8wj30vq0hsjsw.jpg" alt="img"></p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADYAAAABCAYAAACVOl3IAAAAJUlEQVQYV2N89+7df0FBQQYQeP/+PZgGAUJilMpjs4dSM5H1AwBwSSrLZGasMwAAAABJRU5ErkJggg==" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAABCAYAAADeko4lAAAAHUlEQVQYV2N89+7dfwYoEBQUBLPev3/PgItNSC0ADtASy+rFJtUAAAAASUVORK5CYII=" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADoAAAABCAYAAACPBr1GAAAAJ0lEQVQYV2N89+7dfwYoEBQUBLPev3/PQAkbm3mE7KBUHpd7YeYCAE50MMsBeqQ5AAAAAElFTkSuQmCC" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAABCAYAAAAB3PQ6AAAAHUlEQVQYV2N89+7df0FBQQYQeP/+PQMxbLBiIAAAQE0Py6Kq0rkAAAAASUVORK5CYII=" alt="img"></p><p></p><p>07:12</p><p><a href="javascript:;">1.25x<em></em></a></p><p>讲述：冯永吉 大小：8.80M 时长：09:36</p><p>从今天开始，我们就进入了专栏的高级篇。相对基础篇，高级篇涉及的知识点，都比较零散，不是太系统。所以，我会围绕一个实际软件开发的问题，在阐述具体解决方法的过程中，将涉及的知识点给你详细讲解出来。</p><p>所以，相较于基础篇“<strong>开篇问题 - 知识讲解 - 回答开篇 - 总结 - 课后思考</strong>”这样的文章结构，高级篇我稍作了些改变，大致分为这样几个部分：“<strong>问题阐述 - 算法解析 - 总结引申 - 课后思考</strong>”。</p><p>好了，现在，我们就进入高级篇的第一节，如何确定代码源文件的编译依赖关系？</p><p>我们知道，一个完整的项目往往会包含很多代码源文件。编译器在编译整个项目的时候，需要按照依赖关系，依次编译每个源文件。比如，A.cpp 依赖 B.cpp，那在编译的时候，编译器需要先编译 B.cpp，才能编译 A.cpp。</p><p>编译器通过分析源文件或者程序员事先写好的编译配置文件（比如 Makefile 文件），来获取这种局部的依赖关系。<strong>那编译器又该如何通过源文件两两之间的局部依赖关系，确定一个全局的编译顺序呢？</strong></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp83e0g84kj30vq0bhgmx.jpg" alt="img"></p><h2 id="算法解析"><a href="#算法解析" class="headerlink" title="算法解析"></a>算法解析</h2><p>这个问题的解决思路与“图”这种数据结构的一个经典算法“拓扑排序算法”有关。那什么是拓扑排序呢？这个概念很好理解，我们先来看一个生活中的拓扑排序的例子。</p><p>我们在穿衣服的时候都有一定的顺序，我们可以把这种顺序想成，衣服与衣服之间有一定的依赖关系。比如说，你必须先穿袜子才能穿鞋，先穿内裤才能穿秋裤。假设我们现在有八件衣服要穿，它们之间的两两依赖关系我们已经很清楚了，那如何安排一个穿衣序列，能够满足所有的两两之间的依赖关系？</p><p>这就是个拓扑排序问题。从这个例子中，你应该能想到，在很多时候，拓扑排序的序列并不是唯一的。你可以看我画的这幅图，我找到了好几种满足这些局部先后关系的穿衣序列。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp83e0rrjaj30vq0hu0v3.jpg" alt="img"></p><p>弄懂了这个生活中的例子，开篇的关于编译顺序的问题，你应该也有思路了。开篇问题跟这个问题的模型是一样的，也可以抽象成一个拓扑排序问题。</p><p>拓扑排序的原理非常简单，我们的重点应该放到拓扑排序的实现上面。</p><p>我前面多次讲过，算法是构建在具体的数据结构之上的。针对这个问题，我们先来看下，如何将问题背景抽象成具体的数据结构？</p><p>我们可以把源文件与源文件之间的依赖关系，抽象成一个有向图。每个源文件对应图中的一个顶点，源文件之间的依赖关系就是顶点之间的边。</p><p>如果 a 先于 b 执行，也就是说 b 依赖于 a，那么就在顶点 a 和顶点 b 之间，构建一条从 a 指向 b 的边。而且，这个图不仅要是有向图，还要是一个有向无环图，也就是不能存在像 a-&gt;b-&gt;c-&gt;a 这样的循环依赖关系。因为图中一旦出现环，拓扑排序就无法工作了。实际上，拓扑排序本身就是基于有向无环图的一个算法。</p><p>public class Graph {</p><p>  private int v; // 顶点的个数</p><p>  private LinkedList<Integer> adj[]; // 邻接表</p><p>  public Graph(int v) {</p><p>​    this.v = v;</p><p>​    adj = new LinkedList[v];</p><p>​    for (int i=0; i&lt;v; ++i) {</p><p>​      adj[i] = new LinkedList&lt;&gt;();</p><p>​    }</p><p>  }</p><p>  public void addEdge(int s, int t) { // s先于t，边s-&gt;t</p><p>​    adj[s].add(t);</p><p>  }</p><p>}</p><p>数据结构定义好了，现在，我们来看，<strong>如何在这个有向无环图上，实现拓扑排序</strong>？</p><p>拓扑排序有两种实现方法，都不难理解。它们分别是 <strong>Kahn 算法</strong>和 <strong>DFS 深度优先搜索算法</strong>。我们依次来看下它们都是怎么工作的。</p><h3 id="1-Kahn-算法"><a href="#1-Kahn-算法" class="headerlink" title="1.Kahn 算法"></a>1.Kahn 算法</h3><p>Kahn 算法实际上用的是贪心算法思想，思路非常简单、好懂。</p><p>定义数据结构的时候，如果 s 需要先于 t 执行，那就添加一条 s 指向 t 的边。所以，如果某个顶点入度为 0， 也就表示，没有任何顶点必须先于这个顶点执行，那么这个顶点就可以执行了。</p><p>我们先从图中，找出一个入度为 0 的顶点，将其输出到拓扑排序的结果序列中（对应代码中就是把它打印出来），并且把这个顶点从图中删除（也就是把这个顶点可达的顶点的入度都减 1）。我们循环执行上面的过程，直到所有的顶点都被输出。最后输出的序列，就是满足局部依赖关系的拓扑排序。</p><p>我把 Kahn 算法用代码实现了一下，你可以结合着文字描述一块看下。不过，你应该能发现，这段代码实现更有技巧一些，并没有真正删除顶点的操作。代码中有详细的注释，你自己来看，我就不多解释了。</p><p>public void topoSortByKahn() {</p><p>  int[] inDegree = new int[v]; // 统计每个顶点的入度</p><p>  for (int i = 0; i &lt; v; ++i) {</p><p>​    for (int j = 0; j &lt; adj[i].size(); ++j) {</p><p>​      int w = adj[i].get(j); // i-&gt;w</p><p>​      inDegree[w]++;</p><p>​    }</p><p>  }</p><p>  LinkedList<Integer> queue = new LinkedList&lt;&gt;();</p><p>  for (int i = 0; i &lt; v; ++i) {</p><p>​    if (inDegree[i] == 0) queue.add(i);</p><p>  }</p><p>  while (!queue.isEmpty()) {</p><p>​    int i = queue.remove();</p><p>​    System.out.print(“-&gt;” + i);</p><p>​    for (int j = 0; j &lt; adj[i].size(); ++j) {</p><p>​      int k = adj[i].get(j);</p><p>​      inDegree[k]–;</p><p>​      if (inDegree[k] == 0) queue.add(k);</p><p>​    }</p><p>  }</p><p>}</p><h3 id="2-DFS-算法"><a href="#2-DFS-算法" class="headerlink" title="2.DFS 算法"></a>2.DFS 算法</h3><p>图上的深度优先搜索我们前面已经讲过了，实际上，拓扑排序也可以用深度优先搜索来实现。不过这里的名字要稍微改下，更加确切的说法应该是深度优先遍历，遍历图中的所有顶点，而非只是搜索一个顶点到另一个顶点的路径。</p><p>关于这个算法的实现原理，我先把代码贴在下面，下面给你具体解释。</p><p>public void topoSortByDFS() {</p><p>  // 先构建逆邻接表，边s-&gt;t表示，s依赖于t，t先于s</p><p>  LinkedList<Integer> inverseAdj[] = new LinkedList[v];</p><p>  for (int i = 0; i &lt; v; ++i) { // 申请空间</p><p>​    inverseAdj[i] = new LinkedList&lt;&gt;();</p><p>  }</p><p>  for (int i = 0; i &lt; v; ++i) { // 通过邻接表生成逆邻接表</p><p>​    for (int j = 0; j &lt; adj[i].size(); ++j) {</p><p>​      int w = adj[i].get(j); // i-&gt;w</p><p>​      inverseAdj[w].add(i); // w-&gt;i</p><p>​    }</p><p>  }</p><p>  boolean[] visited = new boolean[v];</p><p>  for (int i = 0; i &lt; v; ++i) { // 深度优先遍历图</p><p>​    if (visited[i] == false) {</p><p>​      visited[i] = true;</p><p>​      dfs(i, inverseAdj, visited);</p><p>​    }</p><p>  }</p><p>}</p><p>private void dfs(</p><p>​    int vertex, LinkedList<Integer> inverseAdj[], boolean[] visited) {</p><p>  for (int i = 0; i &lt; inverseAdj[vertex].size(); ++i) {</p><p>​    int w = inverseAdj[vertex].get(i);</p><p>​    if (visited[w] == true) continue;</p><p>​    visited[w] = true;</p><p>​    dfs(w, inverseAdj, visited);</p><p>  } // 先把vertex这个顶点可达的所有顶点都打印出来之后，再打印它自己</p><p>  System.out.print(“-&gt;” + vertex);</p><p>}</p><p>这个算法包含两个关键部分。</p><p>第一部分是<strong>通过邻接表构造逆邻接表</strong>。邻接表中，边 s-&gt;t 表示 s 先于 t 执行，也就是 t 要依赖 s。在逆邻接表中，边 s-&gt;t 表示 s 依赖于 t，s 后于 t 执行。为什么这么转化呢？这个跟我们这个算法的实现思想有关。</p><p>第二部分是这个算法的核心，也就是<strong>递归处理每个顶点</strong>。对于顶点 vertex 来说，我们先输出它可达的所有顶点，也就是说，先把它依赖的所有的顶点输出了，然后再输出自己。</p><p>到这里，用 Kahn 算法和 DFS 算法求拓扑排序的原理和代码实现都讲完了。我们来看下，<strong>这两个算法的时间复杂度分别是多少呢？</strong></p><p>从 Kahn 代码中可以看出来，每个顶点被访问了一次，每个边也都被访问了一次，所以，Kahn 算法的时间复杂度就是 O(V+E)（V 表示顶点个数，E 表示边的个数）。</p><p>DFS 算法的时间复杂度我们之前分析过。每个顶点被访问两次，每条边都被访问一次，所以时间复杂度也是 O(V+E)。</p><p>注意，这里的图可能不是连通的，有可能是有好几个不连通的子图构成，所以，E 并不一定大于 V，两者的大小关系不确定。所以，在表示时间复杂度的时候，V、E 都要考虑在内。</p><h2 id="总结引申"><a href="#总结引申" class="headerlink" title="总结引申"></a>总结引申</h2><p>在基础篇中，关于“图”，我们讲了图的定义和存储、图的广度和深度优先搜索。今天，我们又讲了一个关于图的算法，拓扑排序。</p><p>拓扑排序应用非常广泛，解决的问题的模型也非常一致。凡是需要通过局部顺序来推导全局顺序的，一般都能用拓扑排序来解决。除此之外，拓扑排序还能检测图中环的存在。对于 Kahn 算法来说，如果最后输出出来的顶点个数，少于图中顶点个数，图中还有入度不是 0 的顶点，那就说明，图中存在环。</p><p>关于图中环的检测，我们在递归那一节讲过一个例子，在查找最终推荐人的时候，可能会因为脏数据，造成存在循环推荐，比如，用户 A 推荐了用户 B，用户 B 推荐了用户 C，用户 C 又推荐了用户 A。如何避免这种脏数据导致的无限递归？这个问题，我当时留给你思考了，现在是时候解答了。</p><p>实际上，这就是环的检测问题。因为我们每次都只是查找一个用户的最终推荐人，所以，我们并不需要动用复杂的拓扑排序算法，而只需要记录已经访问过的用户 ID，当用户 ID 第二次被访问的时候，就说明存在环，也就说明存在脏数据。</p><p>HashSet<Integer> hashTable = new HashSet&lt;&gt;(); // 保存已经访问过的actorId</p><p>long findRootReferrerId(long actorId) {</p><p>  if (hashTable.contains(actorId)) { // 存在环</p><p>​    return;</p><p>  }</p><p>  hashTable.add(actorId);</p><p>  Long referrerId = </p><p>​       select referrer_id from [table] where actor_id = actorId;</p><p>  if (referrerId == null) return actorId;</p><p>  return findRootReferrerId(referrerId);</p><p>}</p><p>如果把这个问题改一下，我们想要知道，数据库中的所有用户之间的推荐关系了，有没有存在环的情况。这个问题，就需要用到拓扑排序算法了。我们把用户之间的推荐关系，从数据库中加载到内存中，然后构建成今天讲的这种有向图数据结构，再利用拓扑排序，就可以快速检测出是否存在环了。</p><h2 id="课后思考"><a href="#课后思考" class="headerlink" title="课后思考"></a>课后思考</h2><p>在今天的讲解中，我们用图表示依赖关系的时候，如果 a 先于 b 执行，我们就画一条从 a 到 b 的有向边；反过来，如果 a 先于 b，我们画一条从 b 到 a 的有向边，表示 b 依赖 a，那今天讲的 Kahn 算法和 DFS 算法还能否正确工作呢？如果不能，应该如何改造一下呢？</p><p>我们今天讲了两种拓扑排序算法的实现思路，Kahn 算法和 DFS 深度优先搜索算法，如果换做 BFS 广度优先搜索算法，还可以实现吗？</p><p>欢迎留言和我分享，也欢迎点击“请朋友读”，把今天的内容分享给你的好友，和他一起讨论、学习。</p><h1 id="44-最短路径：地图软件是如何计算出最优出行路径的？"><a href="#44-最短路径：地图软件是如何计算出最优出行路径的？" class="headerlink" title="44 | 最短路径：地图软件是如何计算出最优出行路径的？"></a>44 | 最短路径：地图软件是如何计算出最优出行路径的？</h1><p>王争 2019-01-07</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp83f8bkd1j30vq0hsq4u.jpg" alt="img"></p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADYAAAABCAYAAACVOl3IAAAAJUlEQVQYV2N89+7df0FBQQYQeP/+PZgGAUJilMpjs4dSM5H1AwBwSSrLZGasMwAAAABJRU5ErkJggg==" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAABCAYAAADeko4lAAAAHUlEQVQYV2N89+7dfwYoEBQUBLPev3/PgItNSC0ADtASy+rFJtUAAAAASUVORK5CYII=" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADoAAAABCAYAAACPBr1GAAAAJ0lEQVQYV2N89+7dfwYoEBQUBLPev3/PQAkbm3mE7KBUHpd7YeYCAE50MMsBeqQ5AAAAAElFTkSuQmCC" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAABCAYAAAAB3PQ6AAAAHUlEQVQYV2N89+7df0FBQQYQeP/+PQMxbLBiIAAAQE0Py6Kq0rkAAAAASUVORK5CYII=" alt="img"></p><p></p><p>00:13</p><p><a href="javascript:;">1.25x<em></em></a></p><p>讲述：冯永吉 大小：13.30M 时长：14:31</p><p>基础篇的时候，我们学习了图的两种搜索算法，深度优先搜索和广度优先搜索。这两种算法主要是针对无权图的搜索算法。针对有权图，也就是图中的每条边都有一个权重，我们该如何计算两点之间的最短路径（经过的边的权重和最小）呢？今天，我就从地图软件的路线规划问题讲起，带你看看常用的<strong>最短路径算法</strong>（Shortest Path Algorithm）。</p><p>像 Google 地图、百度地图、高德地图这样的地图软件，我想你应该经常使用吧？如果想从家开车到公司，你只需要输入起始、结束地址，地图就会给你规划一条最优出行路线。这里的最优，有很多种定义，比如最短路线、最少用时路线、最少红绿灯路线等等。<strong>作为一名软件开发工程师，你是否思考过，地图软件的最优路线是如何计算出来的吗？底层依赖了什么算法呢？</strong></p><h2 id="算法解析-1"><a href="#算法解析-1" class="headerlink" title="算法解析"></a>算法解析</h2><p>我们刚提到的最优问题包含三个：最短路线、最少用时和最少红绿灯。我们先解决最简单的，最短路线。</p><p>解决软件开发中的实际问题，最重要的一点就是<strong>建模</strong>，也就是将复杂的场景抽象成具体的数据结构。针对这个问题，我们该如何抽象成数据结构呢？</p><p>我们之前也提到过，图这种数据结构的表达能力很强，显然，把地图抽象成图最合适不过了。我们把每个岔路口看作一个顶点，岔路口与岔路口之间的路看作一条边，路的长度就是边的权重。如果路是单行道，我们就在两个顶点之间画一条有向边；如果路是双行道，我们就在两个顶点之间画两条方向不同的边。这样，整个地图就被抽象成一个有向有权图。</p><p>具体的代码实现，我放在下面了。于是，我们要求解的问题就转化为，在一个有向有权图中，求两个顶点间的最短路径。</p><p>public class Graph { // 有向有权图的邻接表表示</p><p>  private LinkedList<Edge> adj[]; // 邻接表</p><p>  private int v; // 顶点个数</p><p>  public Graph(int v) {</p><p>​    this.v = v;</p><p>​    this.adj = new LinkedList[v];</p><p>​    for (int i = 0; i &lt; v; ++i) {</p><p>​      this.adj[i] = new LinkedList&lt;&gt;();</p><p>​    }</p><p>  }</p><p>  public void addEdge(int s, int t, int w) { // 添加一条边</p><p>​    this.adj[s].add(new Edge(s, t, w));</p><p>  }</p><p>  private class Edge {</p><p>​    public int sid; // 边的起始顶点编号</p><p>​    public int tid; // 边的终止顶点编号</p><p>​    public int w; // 权重</p><p>​    public Edge(int sid, int tid, int w) {</p><p>​      this.sid = sid;</p><p>​      this.tid = tid;</p><p>​      this.w = w;</p><p>​    }</p><p>  }</p><p>  // 下面这个类是为了dijkstra实现用的</p><p>  private class Vertex {</p><p>​    public int id; // 顶点编号ID</p><p>​    public int dist; // 从起始顶点到这个顶点的距离</p><p>​    public Vertex(int id, int dist) {</p><p>​      this.id = id;</p><p>​      this.dist = dist;</p><p>​    }</p><p>  }</p><p>}</p><p>想要解决这个问题，有一个非常经典的算法，最短路径算法，更加准确地说，是<strong>单源最短路径算法</strong>（一个顶点到一个顶点）。提到最短路径算法，最出名的莫过于 Dijkstra 算法了。所以，我们现在来看，Dijkstra 算法是怎么工作的。</p><p>这个算法的原理稍微有点儿复杂，单纯的文字描述，不是很好懂。所以，我还是结合代码来讲解。</p><p>// 因为Java提供的优先级队列，没有暴露更新数据的接口，所以我们需要重新实现一个</p><p>private class PriorityQueue { // 根据vertex.dist构建小顶堆</p><p>  private Vertex[] nodes;</p><p>  private int count;</p><p>  public PriorityQueue(int v) {</p><p>​    this.nodes = new Vertex[v+1];</p><p>​    this.count = v;</p><p>  }</p><p>  public Vertex poll() { // TODO: 留给读者实现… }</p><p>  public void add(Vertex vertex) { // TODO: 留给读者实现…}</p><p>  // 更新结点的值，并且从下往上堆化，重新符合堆的定义。时间复杂度O(logn)。</p><p>  public void update(Vertex vertex) { // TODO: 留给读者实现…} </p><p>  public boolean isEmpty() { // TODO: 留给读者实现…}</p><p>}</p><p>public void dijkstra(int s, int t) { // 从顶点s到顶点t的最短路径</p><p>  int[] predecessor = new int[this.v]; // 用来还原最短路径</p><p>  Vertex[] vertexes = new Vertex[this.v];</p><p>  for (int i = 0; i &lt; this.v; ++i) {</p><p>​    vertexes[i] = new Vertex(i, Integer.MAX_VALUE);</p><p>  }</p><p>  PriorityQueue queue = new PriorityQueue(this.v);// 小顶堆</p><p>  boolean[] inqueue = new boolean[this.v]; // 标记是否进入过队列</p><p>  vertexes[s].dist = 0;</p><p>  queue.add(vertexes[s]);</p><p>  inqueue[s] = true;</p><p>  while (!queue.isEmpty()) {</p><p>​    Vertex minVertex= queue.poll(); // 取堆顶元素并删除</p><p>​    if (minVertex.id == t) break; // 最短路径产生了</p><p>​    for (int i = 0; i &lt; adj[minVertex.id].size(); ++i) {</p><p>​      Edge e = adj[minVertex.id].get(i); // 取出一条minVetex相连的边</p><p>​      Vertex nextVertex = vertexes[e.tid]; // minVertex–&gt;nextVertex</p><p>​      if (minVertex.dist + e.w &lt; nextVertex.dist) { // 更新next的dist</p><p>​        nextVertex.dist = minVertex.dist + e.w;</p><p>​        predecessor[nextVertex.id] = minVertex.id;</p><p>​        if (inqueue[nextVertex.id] == true) {</p><p>​          queue.update(nextVertex); // 更新队列中的dist值</p><p>​        } else {</p><p>​          queue.add(nextVertex);</p><p>​          inqueue[nextVertex.id] = true;</p><p>​        }</p><p>​      }</p><p>​    }</p><p>  }</p><p>  // 输出最短路径</p><p>  System.out.print(s);</p><p>  print(s, t, predecessor);</p><p>}</p><p>private void print(int s, int t, int[] predecessor) {</p><p>  if (s == t) return;</p><p>  print(s, predecessor[t], predecessor);</p><p>  System.out.print(“-&gt;” + t);</p><p>}</p><p>我们用 vertexes 数组，记录从起始顶点到每个顶点的距离（dist）。起初，我们把所有顶点的 dist 都初始化为无穷大（也就是代码中的 Integer.MAX_VALUE）。我们把起始顶点的 dist 值初始化为 0，然后将其放到优先级队列中。</p><p>我们从优先级队列中取出 dist 最小的顶点 minVertex，然后考察这个顶点可达的所有顶点（代码中的 nextVertex）。如果 minVertex 的 dist 值加上 minVertex 与 nextVertex 之间边的权重 w 小于 nextVertex 当前的 dist 值，也就是说，存在另一条更短的路径，它经过 minVertex 到达 nextVertex。那我们就把 nextVertex 的 dist 更新为 minVertex 的 dist 值加上 w。然后，我们把 nextVertex 加入到优先级队列中。重复这个过程，直到找到终止顶点 t 或者队列为空。</p><p>以上就是 Dijkstra 算法的核心逻辑。除此之外，代码中还有两个额外的变量，predecessor 数组和 inqueue 数组。</p><p>predecessor 数组的作用是为了还原最短路径，它记录每个顶点的前驱顶点。最后，我们通过递归的方式，将这个路径打印出来。打印路径的 print 递归代码我就不详细讲了，这个跟我们在图的搜索中讲的打印路径方法一样。如果不理解的话，你可以回过头去看下那一节。</p><p>inqueue 数组是为了避免将一个顶点多次添加到优先级队列中。我们更新了某个顶点的 dist 值之后，如果这个顶点已经在优先级队列中了，就不要再将它重复添加进去了。</p><p>看完了代码和文字解释，你可能还是有点懵，那我就举个例子，再给你解释一下。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp83f5yxb4j30vq0nsq89.jpg" alt="img"></p><p>理解了 Dijkstra 的原理和代码实现，我们来看下，<strong>Dijkstra 算法的时间复杂度是多少？</strong></p><p>在刚刚的代码实现中，最复杂就是 while 循环嵌套 for 循环那部分代码了。while 循环最多会执行 V 次（V 表示顶点的个数），而内部的 for 循环的执行次数不确定，跟每个顶点的相邻边的个数有关，我们分别记作 E0，E1，E2，……，E(V-1)。如果我们把这 V 个顶点的边都加起来，最大也不会超过图中所有边的个数 E（E 表示边的个数）。</p><p>for 循环内部的代码涉及从优先级队列取数据、往优先级队列中添加数据、更新优先级队列中的数据，这样三个主要的操作。我们知道，优先级队列是用堆来实现的，堆中的这几个操作，时间复杂度都是 O(logV)（堆中的元素个数不会超过顶点的个数 V）。</p><p>所以，综合这两部分，再利用乘法原则，整个代码的时间复杂度就是 O(E*logV)。</p><p>弄懂了 Dijkstra 算法，我们再来回答之前的问题，如何计算最优出行路线？</p><p>从理论上讲，用 Dijkstra 算法可以计算出两点之间的最短路径。但是，你有没有想过，对于一个超级大地图来说，岔路口、道路都非常多，对应到图这种数据结构上来说，就有非常多的顶点和边。如果为了计算两点之间的最短路径，在一个超级大图上动用 Dijkstra 算法，遍历所有的顶点和边，显然会非常耗时。那我们有没有什么优化的方法呢？</p><p>做工程不像做理论，一定要给出个最优解。理论上算法再好，如果执行效率太低，也无法应用到实际的工程中。<strong>对于软件开发工程师来说，我们经常要根据问题的实际背景，对解决方案权衡取舍。类似出行路线这种工程上的问题，我们没有必要非得求出个绝对最优解。很多时候，为了兼顾执行效率，我们只需要计算出一个可行的次优解就可以了</strong>。</p><p>有了这个原则，你能想出刚刚那个问题的优化方案吗？</p><p>虽然地图很大，但是两点之间的最短路径或者说较好的出行路径，并不会很“发散”，只会出现在两点之间和两点附近的区块内。所以我们可以在整个大地图上，划出一个小的区块，这个小区块恰好可以覆盖住两个点，但又不会很大。我们只需要在这个小区块内部运行 Dijkstra 算法，这样就可以避免遍历整个大图，也就大大提高了执行效率。</p><p>不过你可能会说了，如果两点距离比较远，从北京海淀区某个地点，到上海黄浦区某个地点，那上面的这种处理方法，显然就不工作了，毕竟覆盖北京和上海的区块并不小。</p><p>我给你点提示，你可以现在打开地图 App，缩小放大一下地图，看下地图上的路线有什么变化，然后再思考，这个问题该怎么解决。</p><p>对于这样两点之间距离较远的路线规划，我们可以把北京海淀区或者北京看作一个顶点，把上海黄浦区或者上海看作一个顶点，先规划大的出行路线。比如，如何从北京到上海，必须要经过某几个顶点，或者某几条干道，然后再细化每个阶段的小路线。</p><p>这样，最短路径问题就解决了。我们再来看另外两个问题，最少时间和最少红绿灯。</p><p>前面讲最短路径的时候，每条边的权重是路的长度。在计算最少时间的时候，算法还是不变，我们只需要把边的权重，从路的长度变成经过这段路所需要的时间。不过，这个时间会根据拥堵情况时刻变化。如何计算车通过一段路的时间呢？这是一个蛮有意思的问题，你可以自己思考下。</p><p>每经过一条边，就要经过一个红绿灯。关于最少红绿灯的出行方案，实际上，我们只需要把每条边的权值改为 1 即可，算法还是不变，可以继续使用前面讲的 Dijkstra 算法。不过，边的权值为 1，也就相当于无权图了，我们还可以使用之前讲过的广度优先搜索算法。因为我们前面讲过，广度优先搜索算法计算出来的两点之间的路径，就是两点的最短路径。</p><p>不过，这里给出的所有方案都非常粗糙，只是为了给你展示，如何结合实际的场景，灵活地应用算法，让算法为我们所用，真实的地图软件的路径规划，要比这个复杂很多。而且，比起 Dijkstra 算法，地图软件用的更多的是类似 A* 的启发式搜索算法，不过也是在 Dijkstra 算法上的优化罢了，我们后面会讲到，这里暂且不展开。</p><h2 id="总结引申-1"><a href="#总结引申-1" class="headerlink" title="总结引申"></a>总结引申</h2><p>今天，我们学习了一种非常重要的图算法，<strong>Dijkstra 最短路径算法</strong>。实际上，最短路径算法还有很多，比如 Bellford 算法、Floyd 算法等等。如果感兴趣，你可以自己去研究。</p><p>关于 Dijkstra 算法，我只讲了原理和代码实现。对于正确性，我没有去证明。之所以这么做，是因为证明过程会涉及比较复杂的数学推导。这个并不是我们的重点，你只要掌握这个算法的思路就可以了。</p><p>这些算法实现思路非常经典，掌握了这些思路，我们可以拿来指导、解决其他问题。比如 Dijkstra 这个算法的核心思想，就可以拿来解决下面这个看似完全不相关的问题。这个问题是我之前工作中遇到的真实的问题，为了在较短的篇幅里把问题介绍清楚，我对背景做了一些简化。</p><p>我们有一个翻译系统，只能针对单个词来做翻译。如果要翻译一整个句子，我们需要将句子拆成一个一个的单词，再丢给翻译系统。针对每个单词，翻译系统会返回一组可选的翻译列表，并且针对每个翻译打一个分，表示这个翻译的可信程度。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp83f7q0pnj30vq0f40uf.jpg" alt="img"></p><p>针对每个单词，我们从可选列表中，选择其中一个翻译，组合起来就是整个句子的翻译。每个单词的翻译的得分之和，就是整个句子的翻译得分。随意搭配单词的翻译，会得到一个句子的不同翻译。针对整个句子，我们希望计算出得分最高的前 k 个翻译结果，你会怎么编程来实现呢？</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp83f70dihj30vq0dg75b.jpg" alt="img"></p><p>当然，最简单的办法还是借助回溯算法，穷举所有的排列组合情况，然后选出得分最高的前 k 个翻译结果。但是，这样做的时间复杂度会比较高，是 O(m^n)，其中，m 表示平均每个单词的可选翻译个数，n 表示一个句子中包含多少个单词。这个解决方案，你可以当作回溯算法的练习题，自己编程实现一下，我就不多说了。</p><p>实际上，这个问题可以借助 Dijkstra 算法的核心思想，非常高效地解决。每个单词的可选翻译是按照分数从大到小排列的，所以 <em>a</em>0<em>b</em>0<em>c</em>0 肯定是得分最高组合结果。我们把 <em>a</em>0<em>b</em>0<em>c</em>0 及得分作为一个对象，放入到优先级队列中。</p><p>我们每次从优先级队列中取出一个得分最高的组合，并基于这个组合进行扩展。扩展的策略是每个单词的翻译分别替换成下一个单词的翻译。比如 <em>a</em>0<em>b</em>0<em>c</em>0 扩展后，会得到三个组合，<em>a</em>1<em>b</em>0<em>c</em>0、<em>a</em>0<em>b</em>1<em>c</em>0、<em>a</em>0<em>b</em>0<em>c</em>1。我们把扩展之后的组合，加到优先级队列中。重复这个过程，直到获取到 k 个翻译组合或者队列为空。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp83f6hmk1j30vq0m5jus.jpg" alt="img"></p><p>我们来看，这种实现思路的时间复杂度是多少？</p><p>假设句子包含 n 个单词，每个单词平均有 m 个可选的翻译，我们求得分最高的前 k 个组合结果。每次一个组合出队列，就对应着一个组合结果，我们希望得到 k 个，那就对应着 k 次出队操作。每次有一个组合出队列，就有 n 个组合入队列。优先级队列中出队和入队操作的时间复杂度都是 O(logX)，X 表示队列中的组合个数。所以，总的时间复杂度就是 O(k<em>n</em>logX)。那 X 到底是多少呢？</p><p>k 次出入队列，队列中的总数据不会超过 k<em>n，也就是说，出队、入队操作的时间复杂度是 O(log(k</em>n))。所以，总的时间复杂度就是 O(k<em>n</em>log(k*n))，比之前的指数级时间复杂度降低了很多。</p><h2 id="课后思考-1"><a href="#课后思考-1" class="headerlink" title="课后思考"></a>课后思考</h2><p>在计算最短时间的出行路线中，如何获得通过某条路的时间呢？这个题目很有意思，我之前面试的时候也被问到过，你可以思考看看。</p><p>今天讲的出行路线问题，我假设的是开车出行，那如果是公交出行呢？如果混合地铁、公交、步行，又该如何规划路线呢？</p><p>欢迎留言和我分享，也欢迎点击“请朋友读”，把今天的内容分享给你的好友，和他一起讨论、学习。</p><h1 id="45-位图：如何实现网页爬虫中的URL去重功能？"><a href="#45-位图：如何实现网页爬虫中的URL去重功能？" class="headerlink" title="45 | 位图：如何实现网页爬虫中的URL去重功能？"></a>45 | 位图：如何实现网页爬虫中的URL去重功能？</h1><p>王争 2019-01-09</p><p><img src="https://static001.geekbang.org/resource/image/01/38/01e51226d435eda4604acc019731c538.jpg" alt="img"></p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADYAAAABCAYAAACVOl3IAAAAJUlEQVQYV2N89+7df0FBQQYQeP/+PZgGAUJilMpjs4dSM5H1AwBwSSrLZGasMwAAAABJRU5ErkJggg==" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAABCAYAAADeko4lAAAAHUlEQVQYV2N89+7dfwYoEBQUBLPev3/PgItNSC0ADtASy+rFJtUAAAAASUVORK5CYII=" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADoAAAABCAYAAACPBr1GAAAAJ0lEQVQYV2N89+7dfwYoEBQUBLPev3/PQAkbm3mE7KBUHpd7YeYCAE50MMsBeqQ5AAAAAElFTkSuQmCC" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAABCAYAAAAB3PQ6AAAAHUlEQVQYV2N89+7df0FBQQYQeP/+PQMxbLBiIAAAQE0Py6Kq0rkAAAAASUVORK5CYII=" alt="img"></p><p></p><p>00:09</p><p><a href="javascript:;">1.25x<em></em></a></p><p>讲述：冯永吉 大小：13.84M 时长：15:06</p><p>网页爬虫是搜索引擎中的非常重要的系统，负责爬取几十亿、上百亿的网页。爬虫的工作原理是，通过解析已经爬取页面中的网页链接，然后再爬取这些链接对应的网页。而<strong>同一个网页链接有可能被包含在多个页面中，这就会导致爬虫在爬取的过程中，重复爬取相同的网页。如果你是一名负责爬虫的工程师，你会如何避免这些重复的爬取呢？</strong></p><p>最容易想到的方法就是，我们记录已经爬取的网页链接（也就是 URL），在爬取一个新的网页之前，我们拿它的链接，在已经爬取的网页链接列表中搜索。如果存在，那就说明这个网页已经被爬取过了；如果不存在，那就说明这个网页还没有被爬取过，可以继续去爬取。等爬取到这个网页之后，我们将这个网页的链接添加到已经爬取的网页链接列表了。</p><p>思路非常简单，我想你应该很容易就能想到。不过，我们该如何记录已经爬取的网页链接呢？需要用什么样的数据结构呢？</p><h2 id="算法解析-2"><a href="#算法解析-2" class="headerlink" title="算法解析"></a>算法解析</h2><p>关于这个问题，我们可以先回想下，是否可以用我们之前学过的数据结构来解决呢？</p><p>这个问题要处理的对象是网页链接，也就是 URL，需要支持的操作有两个，添加一个 URL 和查询一个 URL。除了这两个功能性的要求之外，在非功能性方面，我们还要求这两个操作的执行效率要尽可能高。除此之外，因为我们处理的是上亿的网页链接，内存消耗会非常大，所以在存储效率上，我们要尽可能地高效。</p><p>我们回想一下，满足这些条件的数据结构有哪些呢？显然，散列表、红黑树、跳表这些动态数据结构，都能支持快速地插入、查找数据，但是在内存消耗方面，是否可以接受呢？</p><p>我们拿散列表来举例。假设我们要爬取 10 亿个网页（像 Google、百度这样的通用搜索引擎，爬取的网页可能会更多），为了判重，我们把这 10 亿网页链接存储在散列表中。你来估算下，大约需要多少内存？</p><p>假设一个 URL 的平均长度是 64 字节，那单纯存储这 10 亿个 URL，需要大约 60GB 的内存空间。因为散列表必须维持较小的装载因子，才能保证不会出现过多的散列冲突，导致操作的性能下降。而且，用链表法解决冲突的散列表，还会存储链表指针。所以，如果将这 10 亿个 URL 构建成散列表，那需要的内存空间会远大于 60GB，有可能会超过 100GB。</p><p>当然，对于一个大型的搜索引擎来说，即便是 100GB 的内存要求，其实也不算太高，我们可以采用分治的思想，用多台机器（比如 20 台内存是 8GB 的机器）来存储这 10 亿网页链接。这种分治的处理思路，我们讲过很多次了，这里就不详细说了。</p><p>对于爬虫的 URL 去重这个问题，刚刚讲到的分治加散列表的思路，已经是可以实实在在工作的了。不过，<strong>作为一个有追求的工程师，我们应该考虑，在添加、查询数据的效率以及内存消耗方面，是否还有进一步的优化空间呢？</strong></p><p>你可能会说，散列表中添加、查找数据的时间复杂度已经是 O(1)，还能有进一步优化的空间吗？实际上，我们前面也讲过，时间复杂度并不能完全代表代码的执行时间。大 O 时间复杂度表示法，会忽略掉常数、系数和低阶，并且统计的对象是语句的频度。不同的语句，执行时间也是不同的。时间复杂度只是表示执行时间随数据规模的变化趋势，并不能度量在特定的数据规模下，代码执行时间的多少。</p><p>如果时间复杂度中原来的系数是 10，我们现在能够通过优化，将系数降为 1，那在时间复杂度没有变化的情况下，执行效率就提高了 10 倍。对于实际的软件开发来说，10 倍效率的提升，显然是一个非常值得的优化。</p><p>如果我们用基于链表的方法解决冲突问题，散列表中存储的是 URL，那当查询的时候，通过哈希函数定位到某个链表之后，我们还需要依次比对每个链表中的 URL。这个操作是比较耗时的，主要有两点原因。</p><p>一方面，链表中的结点在内存中不是连续存储的，所以不能一下子加载到 CPU 缓存中，没法很好地利用到 CPU 高速缓存，所以数据访问性能方面会打折扣。</p><p>另一方面，链表中的每个数据都是 URL，而 URL 不是简单的数字，是平均长度为 64 字节的字符串。也就是说，我们要让待判重的 URL，跟链表中的每个 URL，做字符串匹配。显然，这样一个字符串匹配操作，比起单纯的数字比对，要慢很多。所以，基于这两点，执行效率方面肯定是有优化空间的。</p><p>对于内存消耗方面的优化，除了刚刚这种基于散列表的解决方案，貌似没有更好的法子了。实际上，如果要想内存方面有明显的节省，那就得换一种解决方案，也就是我们今天要着重讲的这种存储结构，<strong>布隆过滤器</strong>（Bloom Filter）。</p><p>在讲布隆过滤器前，我要先讲一下另一种存储结构，<strong>位图</strong>（BitMap）。因为，布隆过滤器本身就是基于位图的，是对位图的一种改进。</p><p>我们先来看一个跟开篇问题非常类似、但比那个稍微简单的问题。<strong>我们有 1 千万个整数，整数的范围在 1 到 1 亿之间。如何快速查找某个整数是否在这 1 千万个整数中呢？</strong></p><p>当然，这个问题还是可以用散列表来解决。不过，我们可以使用一种比较“特殊”的散列表，那就是位图。我们申请一个大小为 1 亿、数据类型为布尔类型（true 或者 false）的数组。我们将这 1 千万个整数作为数组下标，将对应的数组值设置成 true。比如，整数 5 对应下标为 5 的数组值设置为 true，也就是 array[5]=true。</p><p>当我们查询某个整数 K 是否在这 1 千万个整数中的时候，我们只需要将对应的数组值 array[K]取出来，看是否等于 true。如果等于 true，那说明 1 千万整数中包含这个整数 K；相反，就表示不包含这个整数 K。</p><p>不过，很多语言中提供的布尔类型，大小是 1 个字节的，并不能节省太多内存空间。实际上，表示 true 和 false 两个值，我们只需要用一个二进制位（bit）就可以了。<strong>那如何通过编程语言，来表示一个二进制位呢？</strong></p><p>这里就要用到位运算了。我们可以借助编程语言中提供的数据类型，比如 int、long、char 等类型，通过位运算，用其中的某个位表示某个数字。文字描述起来有点儿不好理解，我把位图的代码实现写了出来，你可以对照着代码看下，应该就能看懂了。</p><p>public class BitMap { // Java中char类型占16bit，也即是2个字节</p><p>  private char[] bytes;</p><p>  private int nbits;</p><p>  public BitMap(int nbits) {</p><p>​    this.nbits = nbits;</p><p>​    this.bytes = new char[nbits/16+1];</p><p>  }</p><p>  public void set(int k) {</p><p>​    if (k &gt; nbits) return;</p><p>​    int byteIndex = k / 16;</p><p>​    int bitIndex = k % 16;</p><p>​    bytes[byteIndex] |= (1 &lt;&lt; bitIndex);</p><p>  }</p><p>  public boolean get(int k) {</p><p>​    if (k &gt; nbits) return false;</p><p>​    int byteIndex = k / 16;</p><p>​    int bitIndex = k % 16;</p><p>​    return (bytes[byteIndex] &amp; (1 &lt;&lt; bitIndex)) != 0;</p><p>  }</p><p>}</p><p>从刚刚位图结构的讲解中，你应该可以发现，位图通过数组下标来定位数据，所以，访问效率非常高。而且，每个数字用一个二进制位来表示，在数字范围不大的情况下，所需要的内存空间非常节省。</p><p>比如刚刚那个例子，如果用散列表存储这 1 千万的数据，数据是 32 位的整型数，也就是需要 4 个字节的存储空间，那总共至少需要 40MB 的存储空间。如果我们通过位图的话，数字范围在 1 到 1 亿之间，只需要 1 亿个二进制位，也就是 12MB 左右的存储空间就够了。</p><p>关于位图，我们就讲完了，是不是挺简单的？不过，这里我们有个假设，就是数字所在的范围不是很大。如果数字的范围很大，比如刚刚那个问题，数字范围不是 1 到 1 亿，而是 1 到 10 亿，那位图的大小就是 10 亿个二进制位，也就是 120MB 的大小，消耗的内存空间，不降反增。</p><p>这个时候，布隆过滤器就要出场了。布隆过滤器就是为了解决刚刚这个问题，对位图这种数据结构的一种改进。</p><p>还是刚刚那个例子，数据个数是 1 千万，数据的范围是 1 到 10 亿。布隆过滤器的做法是，我们仍然使用一个 1 亿个二进制大小的位图，然后通过哈希函数，对数字进行处理，让它落在这 1 到 1 亿范围内。比如我们把哈希函数设计成 f(x)=x%n。其中，x 表示数字，n 表示位图的大小（1 亿），也就是，对数字跟位图的大小进行取模求余。</p><p>不过，你肯定会说，哈希函数会存在冲突的问题啊，一亿零一和 1 两个数字，经过你刚刚那个取模求余的哈希函数处理之后，最后的结果都是 1。这样我就无法区分，位图存储的是 1 还是一亿零一了。</p><p>为了降低这种冲突概率，当然我们可以设计一个复杂点、随机点的哈希函数。除此之外，还有其他方法吗？我们来看布隆过滤器的处理方法。既然一个哈希函数可能会存在冲突，那用多个哈希函数一块儿定位一个数据，是否能降低冲突的概率呢？我来具体解释一下，布隆过滤器是怎么做的。</p><p>我们使用 K 个哈希函数，对同一个数字进行求哈希值，那会得到 K 个不同的哈希值，我们分别记作 <em>X</em>1，<em>X</em>2，<em>X</em>3，…，<em>X**K</em>。我们把这 K 个数字作为位图中的下标，将对应的 BitMap[<em>X</em>1]，BitMap[<em>X</em>2]，BitMap[<em>X</em>3]，…，BitMap[<em>X**K</em>]都设置成 true，也就是说，我们用 K 个二进制位，来表示一个数字的存在。</p><p>当我们要查询某个数字是否存在的时候，我们用同样的 K 个哈希函数，对这个数字求哈希值，分别得到 <em>Y</em>1，<em>Y</em>2，<em>Y</em>3，…，<em>Y**K</em>。我们看这 K 个哈希值，对应位图中的数值是否都为 true，如果都是 true，则说明，这个数字存在，如果有其中任意一个不为 true，那就说明这个数字不存在。</p><p><img src="https://static001.geekbang.org/resource/image/94/ae/94630c1c3b7657f560a1825bd9d02cae.jpg" alt="img"></p><p>对于两个不同的数字来说，经过一个哈希函数处理之后，可能会产生相同的哈希值。但是经过 K 个哈希函数处理之后，K 个哈希值都相同的概率就非常低了。尽管采用 K 个哈希函数之后，两个数字哈希冲突的概率降低了，但是，这种处理方式又带来了新的问题，那就是容易误判。我们看下面这个例子。</p><p><img src="https://static001.geekbang.org/resource/image/d0/1a/d0a3326ef0037f64102163209301aa1a.jpg" alt="img"></p><p>布隆过滤器的误判有一个特点，那就是，它只会对存在的情况有误判。如果某个数字经过布隆过滤器判断不存在，那说明这个数字真的不存在，不会发生误判；如果某个数字经过布隆过滤器判断存在，这个时候才会有可能误判，有可能并不存在。不过，只要我们调整哈希函数的个数、位图大小跟要存储数字的个数之间的比例，那就可以将这种误判的概率降到非常低。</p><p>尽管布隆过滤器会存在误判，但是，这并不影响它发挥大作用。很多场景对误判有一定的容忍度。比如我们今天要解决的爬虫判重这个问题，即便一个没有被爬取过的网页，被误判为已经被爬取，对于搜索引擎来说，也并不是什么大事情，是可以容忍的，毕竟网页太多了，搜索引擎也不可能 100% 都爬取到。</p><p>弄懂了布隆过滤器，我们今天的爬虫网页去重的问题，就很简单了。</p><p>我们用布隆过滤器来记录已经爬取过的网页链接，假设需要判重的网页有 10 亿，那我们可以用一个 10 倍大小的位图来存储，也就是 100 亿个二进制位，换算成字节，那就是大约 1.2GB。之前我们用散列表判重，需要至少 100GB 的空间。相比来讲，布隆过滤器在存储空间的消耗上，降低了非常多。</p><p>那我们再来看下，利用布隆过滤器，在执行效率方面，是否比散列表更加高效呢？</p><p>布隆过滤器用多个哈希函数对同一个网页链接进行处理，CPU 只需要将网页链接从内存中读取一次，进行多次哈希计算，理论上讲这组操作是 CPU 密集型的。而在散列表的处理方式中，需要读取散列值相同（散列冲突）的多个网页链接，分别跟待判重的网页链接，进行字符串匹配。这个操作涉及很多内存数据的读取，所以是内存密集型的。我们知道 CPU 计算可能是要比内存访问更快速的，所以，理论上讲，布隆过滤器的判重方式，更加快速。</p><h2 id="总结引申-2"><a href="#总结引申-2" class="headerlink" title="总结引申"></a>总结引申</h2><p>今天，关于搜索引擎爬虫网页去重问题的解决，我们从散列表讲到位图，再讲到布隆过滤器。布隆过滤器非常适合这种不需要 100% 准确的、允许存在小概率误判的大规模判重场景。除了爬虫网页去重这个例子，还有比如统计一个大型网站的每天的 UV 数，也就是每天有多少用户访问了网站，我们就可以使用布隆过滤器，对重复访问的用户进行去重。</p><p>我们前面讲到，布隆过滤器的误判率，主要跟哈希函数的个数、位图的大小有关。当我们往布隆过滤器中不停地加入数据之后，位图中不是 true 的位置就越来越少了，误判率就越来越高了。所以，对于无法事先知道要判重的数据个数的情况，我们需要支持自动扩容的功能。</p><p>当布隆过滤器中，数据个数与位图大小的比例超过某个阈值的时候，我们就重新申请一个新的位图。后面来的新数据，会被放置到新的位图中。但是，如果我们要判断某个数据是否在布隆过滤器中已经存在，我们就需要查看多个位图，相应的执行效率就降低了一些。</p><p>位图、布隆过滤器应用如此广泛，很多编程语言都已经实现了。比如 Java 中的 BitSet 类就是一个位图，Redis 也提供了 BitMap 位图类，Google 的 Guava 工具包提供了 BloomFilter 布隆过滤器的实现。如果你感兴趣，你可以自己去研究下这些实现的源码。</p><h2 id="课后思考-2"><a href="#课后思考-2" class="headerlink" title="课后思考"></a>课后思考</h2><p>假设我们有 1 亿个整数，数据范围是从 1 到 10 亿，如何快速并且省内存地给这 1 亿个数据从小到大排序？</p><p>还记得我们在哈希函数（下）讲过的利用分治思想，用散列表以及哈希函数，实现海量图库中的判重功能吗？如果我们允许小概率的误判，那是否可以用今天的布隆过滤器来解决呢？你可以参照我们当时的估算方法，重新估算下，用布隆过滤器需要多少台机器？</p><p>欢迎留言和我分享，也欢迎点击“请朋友读”，把今天的内容分享给你的好友，和他一起讨论、学习。</p><h1 id="46-概率统计：如何利用朴素贝叶斯算法过滤垃圾短信？"><a href="#46-概率统计：如何利用朴素贝叶斯算法过滤垃圾短信？" class="headerlink" title="46 | 概率统计：如何利用朴素贝叶斯算法过滤垃圾短信？"></a>46 | 概率统计：如何利用朴素贝叶斯算法过滤垃圾短信？</h1><p>王争 2019-01-11</p><p><img src="https://static001.geekbang.org/resource/image/0d/0a/0dd3a82c32db9385c85d039448b7570a.jpg" alt="img"></p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADYAAAABCAYAAACVOl3IAAAAJUlEQVQYV2N89+7df0FBQQYQeP/+PZgGAUJilMpjs4dSM5H1AwBwSSrLZGasMwAAAABJRU5ErkJggg==" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAABCAYAAADeko4lAAAAHUlEQVQYV2N89+7dfwYoEBQUBLPev3/PgItNSC0ADtASy+rFJtUAAAAASUVORK5CYII=" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADoAAAABCAYAAACPBr1GAAAAJ0lEQVQYV2N89+7dfwYoEBQUBLPev3/PQAkbm3mE7KBUHpd7YeYCAE50MMsBeqQ5AAAAAElFTkSuQmCC" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAABCAYAAAAB3PQ6AAAAHUlEQVQYV2N89+7df0FBQQYQeP/+PQMxbLBiIAAAQE0Py6Kq0rkAAAAASUVORK5CYII=" alt="img"></p><p></p><p>00:08</p><p><a href="javascript:;">1.25x<em></em></a></p><p>讲述：冯永吉 大小：13.37M 时长：14:35</p><p>上一节我们讲到，如何用位图、布隆过滤器，来过滤重复的数据。今天，我们再讲一个跟过滤相关的问题，如何过滤垃圾短信？</p><p>垃圾短信和骚扰电话，我想每个人都收到过吧？买房、贷款、投资理财、开发票，各种垃圾短信和骚扰电话，不胜其扰。<strong>如果你是一名手机应用开发工程师，让你实现一个简单的垃圾短信过滤功能以及骚扰电话拦截功能，该用什么样的数据结构和算法实现呢？</strong></p><h2 id="算法解析-3"><a href="#算法解析-3" class="headerlink" title="算法解析"></a>算法解析</h2><p>实际上，解决这个问题并不会涉及很高深的算法。今天，我就带你一块看下，如何利用简单的数据结构和算法，解决这种看似非常复杂的问题。</p><h3 id="1-基于黑名单的过滤器"><a href="#1-基于黑名单的过滤器" class="headerlink" title="1. 基于黑名单的过滤器"></a>1. 基于黑名单的过滤器</h3><p>我们可以维护一个骚扰电话号码和垃圾短信发送号码的黑名单。这个黑名单的收集，有很多途径，比如，我们可以从一些公开的网站上下载，也可以通过类似“360 骚扰电话拦截”的功能，通过用户自主标记骚扰电话来收集。对于被多个用户标记，并且标记个数超过一定阈值的号码，我们就可以定义为骚扰电话，并将它加入到我们的黑名单中。</p><p>如果黑名单中的电话号码不多的话，我们可以使用散列表、二叉树等动态数据结构来存储，对内存的消耗并不会很大。如果我们把每个号码看作一个字符串，并且假设平均长度是 16 个字节，那存储 50 万个电话号码，大约需要 10MB 的内存空间。即便是对于手机这样的内存有限的设备来说，这点内存的消耗也是可以接受的。</p><p>但是，如果黑名单中的电话号码很多呢？比如有 500 万个。这个时候，如果再用散列表存储，就需要大约 100MB 的存储空间。为了实现一个拦截功能，耗费用户如此多的手机内存，这显然有点儿不合理。</p><p>上一节我们讲了，布隆过滤器最大的特点就是比较省存储空间，所以，用它来解决这个问题再合适不过了。如果我们要存储 500 万个手机号码，我们把位图大小设置为 10 倍数据大小，也就是 5000 万，那也只需要使用 5000 万个二进制位（5000 万 bits），换算成字节，也就是不到 7MB 的存储空间。比起散列表的解决方案，内存的消耗减少了很多。</p><p>实际上，我们还有一种时间换空间的方法，可以将内存的消耗优化到极致。</p><p>我们可以把黑名单存储在服务器端上，把过滤和拦截的核心工作，交给服务器端来做。手机端只负责将要检查的号码发送给服务器端，服务器端通过查黑名单，判断这个号码是否应该被拦截，并将结果返回给手机端。</p><p>用这个解决思路完全不需要占用手机内存。不过，有利就有弊。我们知道，网络通信是比较慢的，所以，网络延迟就会导致处理速度降低。而且，这个方案还有个硬性要求，那就是只有在联网的情况下，才能正常工作。</p><p>基于黑名单的过滤器我就讲完了，不过，你可能还会说，布隆过滤器会有判错的概率呀！如果它把一个重要的电话或者短信，当成垃圾短信或者骚扰电话拦截了，对于用户来说，这是无法接受的。你说得没错，这是一个很大的问题。不过，我们现在先放一放，等三种过滤器都讲完之后，我再来解答。</p><h3 id="2-基于规则的过滤器"><a href="#2-基于规则的过滤器" class="headerlink" title="2. 基于规则的过滤器"></a>2. 基于规则的过滤器</h3><p>刚刚讲了一种基于黑名单的垃圾短信过滤方法，但是，如果某个垃圾短信发送者的号码并不在黑名单中，那这种方法就没办法拦截了。所以，基于黑名单的过滤方式，还不够完善，我们再继续看一种基于规则的过滤方式。</p><p>对于垃圾短信来说，我们还可以通过短信的内容，来判断某条短信是否是垃圾短信。我们预先设定一些规则，如果某条短信符合这些规则，我们就可以判定它是垃圾短信。实际上，规则可以有很多，比如下面这几个：</p><p>短信中包含特殊单词（或词语），比如一些非法、淫秽、反动词语等；</p><p>短信发送号码是群发号码，非我们正常的手机号码，比如 +60389585；</p><p>短信中包含回拨的联系方式，比如手机号码、微信、QQ、网页链接等，因为群发短信的号码一般都是无法回拨的；</p><p>短信格式花哨、内容很长，比如包含各种表情、图片、网页链接等；</p><p>符合已知垃圾短信的模板。垃圾短信一般都是重复群发，对于已经判定为垃圾短信的短信，我们可以抽象成模板，将获取到的短信与模板匹配，一旦匹配，我们就可以判定为垃圾短信。</p><p>当然，如果短信只是满足其中一条规则，如果就判定为垃圾短信，那会存在比较大的误判的情况。我们可以综合多条规则进行判断。比如，满足 2 条以上才会被判定为垃圾短信；或者每条规则对应一个不同的得分，满足哪条规则，我们就累加对应的分数，某条短信的总得分超过某个阈值，才会被判定为垃圾短信。</p><p>不过，我只是给出了一些制定规则的思路，具体落实到执行层面，其实还有很大的距离，还有很多细节需要处理。比如，第一条规则中，我们该如何定义特殊单词；第二条规则中，我们该如何定义什么样的号码是群发号码等等。限于篇幅，我就不一一详细展开来讲了。我这里只讲一下，如何定义特殊单词？</p><p>如果我们只是自己拍脑袋想，哪些单词属于特殊单词，那势必有比较大的主观性，也很容易漏掉某些单词。实际上，我们可以基于概率统计的方法，借助计算机强大的计算能力，找出哪些单词最常出现在垃圾短信中，将这些最常出现的单词，作为特殊单词，用来过滤短信。</p><p>不过这种方法的前提是，我们有大量的样本数据，也就是说，要有大量的短信（比如 1000 万条短信），并且我们还要求，每条短信都做好了标记，它是垃圾短信还是非垃圾短信。</p><p>我们对这 1000 万条短信，进行分词处理（借助中文或者英文分词算法），去掉“的、和、是”等没有意义的停用词（Stop words），得到 n 个不同的单词。针对每个单词，我们统计有多少个垃圾短信出现了这个单词，有多少个非垃圾短信会出现这个单词，进而求出每个单词出现在垃圾短信中的概率，以及出现在非垃圾短信中的概率。如果某个单词出现在垃圾短信中的概率，远大于出现在非垃圾短信中的概率，那我们就把这个单词作为特殊单词，用来过滤垃圾短信。</p><p>文字描述不好理解，我举个例子来解释一下。</p><p><img src="https://static001.geekbang.org/resource/image/05/c0/05b9358cac3721e746bbfec8b705cdc0.jpg" alt="img"></p><h3 id="3-基于概率统计的过滤器"><a href="#3-基于概率统计的过滤器" class="headerlink" title="3. 基于概率统计的过滤器"></a>3. 基于概率统计的过滤器</h3><p>基于规则的过滤器，看起来很直观，也很好理解，但是它也有一定的局限性。一方面，这些规则受人的思维方式局限，规则未免太过简单；另一方面，垃圾短信发送者可能会针对规则，精心设计短信，绕过这些规则的拦截。对此，我们再来看一种更加高级的过滤方式，基于概率统计的过滤方式。</p><p>这种基于概率统计的过滤方式，基础理论是基于朴素贝叶斯算法。为了让你更好地理解下面的内容，我们先通过一个非常简单的例子来看下，什么是朴素贝叶斯算法？</p><p>假设事件 A 是“小明不去上学”，事件 B 是“下雨了”。我们现在统计了一下过去 10 天的下雨情况和小明上学的情况，作为样本数据。</p><p><img src="https://static001.geekbang.org/resource/image/e8/32/e8a0bf4643453266c012e5384fc29932.jpg" alt="img"></p><p>我们来分析一下，这组样本有什么规律。在这 10 天中，有 4 天下雨，所以下雨的概率 P(B)=4/10。10 天中有 3 天，小明没有去上学，所以小明不去上学的概率 P(A)=3/10。在 4 个下雨天中，小明有 2 天没去上学，所以下雨天不去上学的概率 P(A|B)=2/4。在小明没有去上学的 3 天中，有 2 天下雨了，所以小明因为下雨而不上学的概率是 P(B|A)=2/3。实际上，这 4 个概率值之间，有一定的关系，这个关系就是朴素贝叶斯算法，我们用公式表示出来，就是下面这个样子。</p><p><img src="https://static001.geekbang.org/resource/image/fb/cc/fbef6a760f916941bc3128c2d32540cc.jpg" alt="img"></p><p>朴素贝叶斯算法是不是非常简单？我们用一个公式就可以将它概括。弄懂了朴素贝叶斯算法，我们再回到垃圾短信过滤这个问题上，看看如何利用朴素贝叶斯算法，来做垃圾短信的过滤。</p><p>基于概率统计的过滤器，是基于短信内容来判定是否是垃圾短信。而计算机没办法像人一样理解短信的含义。所以，我们需要把短信抽象成一组计算机可以理解并且方便计算的<strong>特征项</strong>，用这一组特征项代替短信本身，来做垃圾短信过滤。</p><p>我们可以通过分词算法，把一个短信分割成 n 个单词。这 n 个单词就是一组特征项，全权代表这个短信。因此，判定一个短信是否是垃圾短信这样一个问题，就变成了，判定同时包含这几个单词的短信是否是垃圾短信。</p><p>不过，这里我们并不像基于规则的过滤器那样，非黑即白，一个短信要么被判定为垃圾短信、要么被判定为非垃圾短息。我们使用概率，来表征一个短信是垃圾短信的可信程度。如果我们用公式将这个概率表示出来，就是下面这个样子：</p><p><img src="https://static001.geekbang.org/resource/image/b8/e7/b8f76a5fd26f785055b78ffe08ccfbe7.jpg" alt="img"></p><p>尽管我们有大量的短信样本，但是我们没法通过样本数据统计得到这个概率。为什么不可以呢？你可能会说，我只需要统计同时包含 <em>W</em>1，<em>W</em>2，<em>W</em>3，…，<em>W**n</em> 这 n 个单词的短信有多少个（我们假设有 x 个），然后看这里面属于垃圾短信的有几个（我们假设有 y 个），那包含 <em>W</em>1，<em>W</em>2，<em>W</em>3，…，<em>W**n</em> 这 n 个单词的短信是垃圾短信的概率就是 y/x。</p><p>理想很丰满，但现实往往很骨感。你忽视了非常重要的一点，那就是样本的数量再大，毕竟也是有限的，样本中不会有太多同时包含 <em>W</em>1，<em>W</em>2，<em>W</em>3，…，<em>W**n</em> 的短信的，甚至很多时候，样本中根本不存在这样的短信。没有样本，也就无法计算概率。所以这样的推理方式虽然正确，但是实践中并不好用。</p><p>这个时候，朴素贝叶斯公式就可以派上用场了。我们通过朴素贝叶斯公式，将这个概率的求解，分解为其他三个概率的求解。你可以看我画的图。那转化之后的三个概率是否可以通过样本统计得到呢？</p><p><img src="https://static001.geekbang.org/resource/image/39/ae/39c57b1a8a008e50a9f6cb8b7b9c9bae.jpg" alt="img"></p><p>P（<em>W</em>1，<em>W</em>2，<em>W</em>3，…，<em>W**n</em> 同时出现在一条短信中 | 短信是垃圾短信）这个概率照样无法通过样本来统计得到。但是我们可以基于下面这条著名的概率规则来计算。</p><p>独立事件发生的概率计算公式：P(A*B) = P(A)*P(B)</p><p>如果事件 A 和事件 B 是独立事件，两者的发生没有相关性，事件 A 发生的概率 P(A) 等于 p1，事件 B 发生的概率 P(B) 等于 p2，那两个同时发生的概率 P(A*B) 就等于 P(A)*P(B)。</p><p>基于这条独立事件发生概率的计算公式，我们可以把 P（W1，W2，W3，…，Wn 同时出现在一条短信中 | 短信是垃圾短信）分解为下面这个公式：</p><p><img src="https://static001.geekbang.org/resource/image/6c/f2/6c261a3f5312c515cf348cc59a5e73f2.jpg" alt="img"></p><p>其中，P（<em>W**i</em> 出现在短信中 | 短信是垃圾短信）表示垃圾短信中包含 <em>W**i</em> 这个单词的概率有多大。这个概率值通过统计样本很容易就能获得。我们假设垃圾短信有 y 个，其中包含 <em>W**i</em> 的有 x 个，那这个概率值就等于 x/y。</p><p>P（<em>W</em>1，<em>W</em>2，<em>W</em>3，…，<em>W**n</em> 同时出现在一条短信中 | 短信是垃圾短信）这个概率值，我们就计算出来了，我们再来看下剩下两个。</p><p>P（短信是垃圾短信）表示短信是垃圾短信的概率，这个很容易得到。我们把样本中垃圾短信的个数除以总样本短信个数，就是短信是垃圾短信的概率。</p><p>不过，P（<em>W</em>1，<em>W</em>2，<em>W</em>3，…，<em>W**n</em> 同时出现在一条短信中）这个概率还是不好通过样本统计得到，原因我们前面说过了，样本空间有限。不过，我们没必要非得计算这一部分的概率值。为什么这么说呢？</p><p>实际上，我们可以分别计算同时包含 <em>W</em>1，<em>W</em>2，<em>W</em>3，…，<em>W**n</em> 这 n 个单词的短信，是垃圾短信和非垃圾短信的概率。假设它们分别是 p1 和 p2。我们并不需要单纯地基于 p1 值的大小来判断是否是垃圾短信，而是通过对比 p1 和 p2 值的大小，来判断一条短信是否是垃圾短信。更细化一点讲，那就是，如果 p1 是 p2 的很多倍（比如 10 倍），我们才确信这条短信是垃圾短信。</p><p><img src="https://static001.geekbang.org/resource/image/0f/2a/0f0369a955ee8d15bd7d7958829d5b2a.jpg" alt="img"></p><p>基于这两个概率的倍数来判断是否是垃圾短信的方法，我们就可以不用计算 P（<em>W</em>1，<em>W</em>2，<em>W</em>3，…，<em>W**n</em> 同时出现在一条短信中）这一部分的值了，因为计算 p1 与 p2 的时候，都会包含这个概率值的计算，所以在求解 p1 和 p2 倍数（p1/p2）的时候，我们也就不需要这个值。</p><h2 id="总结引申-3"><a href="#总结引申-3" class="headerlink" title="总结引申"></a>总结引申</h2><p>今天，我们讲了基于黑名单、规则、概率统计三种垃圾短信的过滤方法，实际上，今天讲的这三种方法，还可以应用到很多类似的过滤、拦截的领域，比如垃圾邮件的过滤等等。</p><p>在讲黑名单过滤的时候，我讲到布隆过滤器可能会存在误判情况，可能会导致用户投诉。实际上，我们可以结合三种不同的过滤方式的结果，对同一个短信处理，如果三者都表明这个短信是垃圾短信，我们才把它当作垃圾短信拦截过滤，这样就会更精准。</p><p>当然，在实际的工程中，我们还需要结合具体的场景，以及大量的实验，不断去调整策略，权衡垃圾短信判定的<strong>准确率</strong>（是否会把不是垃圾的短信错判为垃圾短信）和<strong>召回率</strong>（是否能把所有的垃圾短信都找到），来实现我们的需求。</p><h2 id="课后思考-3"><a href="#课后思考-3" class="headerlink" title="课后思考"></a>课后思考</h2><p>关于垃圾短信过滤和骚扰电话的拦截，我们可以一块儿头脑风暴一下，看看你还有没有其他方法呢？</p><p>欢迎留言和我分享，也欢迎点击“请朋友读”，把今天的内容分享给你的好友，和他一起讨论、学习。</p><h1 id="47-向量空间：如何实现一个简单的音乐推荐系统？"><a href="#47-向量空间：如何实现一个简单的音乐推荐系统？" class="headerlink" title="47 | 向量空间：如何实现一个简单的音乐推荐系统？"></a>47 | 向量空间：如何实现一个简单的音乐推荐系统？</h1><p>王争 2019-01-14</p><p><img src="https://static001.geekbang.org/resource/image/1d/5b/1d138ccc0ec51be75ec7e790f895c25b.jpg" alt="img"></p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADYAAAABCAYAAACVOl3IAAAAJUlEQVQYV2N89+7df0FBQQYQeP/+PZgGAUJilMpjs4dSM5H1AwBwSSrLZGasMwAAAABJRU5ErkJggg==" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAABCAYAAADeko4lAAAAHUlEQVQYV2N89+7dfwYoEBQUBLPev3/PgItNSC0ADtASy+rFJtUAAAAASUVORK5CYII=" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADoAAAABCAYAAACPBr1GAAAAJ0lEQVQYV2N89+7dfwYoEBQUBLPev3/PQAkbm3mE7KBUHpd7YeYCAE50MMsBeqQ5AAAAAElFTkSuQmCC" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAABCAYAAAAB3PQ6AAAAHUlEQVQYV2N89+7df0FBQQYQeP/+PQMxbLBiIAAAQE0Py6Kq0rkAAAAASUVORK5CYII=" alt="img"></p><p></p><p>00:07</p><p><a href="javascript:;">1.25x<em></em></a></p><p>讲述：冯永吉 大小：7.67M 时长：08:22</p><p>很多人都喜爱听歌，以前我们用 MP3 听歌，现在直接通过音乐 App 在线就能听歌。而且，各种音乐 App 的功能越来越强大，不仅可以自己选歌听，还可以根据你听歌的口味偏好，给你推荐可能会喜爱的音乐，而且有时候，推荐的音乐还非常适合你的口味，甚至会惊艳到你！如此智能的一个功能，你知道它是怎么实现的吗？</p><h2 id="算法解析-4"><a href="#算法解析-4" class="headerlink" title="算法解析"></a>算法解析</h2><p>实际上，要解决这个问题，并不需要特别高深的理论。解决思路的核心思想非常简单、直白，用两句话就能总结出来。</p><p>找到跟你口味偏好相似的用户，把他们爱听的歌曲推荐给你；</p><p>找出跟你喜爱的歌曲特征相似的歌曲，把这些歌曲推荐给你。</p><p>接下来，我就分别讲解一下这两种思路的具体实现方法。</p><h3 id="1-基于相似用户做推荐"><a href="#1-基于相似用户做推荐" class="headerlink" title="1. 基于相似用户做推荐"></a>1. 基于相似用户做推荐</h3><p>如何找到跟你口味偏好相似的用户呢？或者说如何定义口味偏好相似呢？实际上，思路也很简单，我们把跟你听类似歌曲的人，看作口味相似的用户。你可以看我下面画的这个图。我用“1”表示“喜爱”，用“0”笼统地表示“不发表意见”。从图中我们可以看出，你跟小明共同喜爱的歌曲最多，有 5 首。于是，我们就可以说，小明跟你的口味非常相似。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp83goc1xej30vq0f4q51.jpg" alt="img"></p><p>我们只需要遍历所有的用户，对比每个用户跟你共同喜爱的歌曲个数，并且设置一个阈值，如果你和某个用户共同喜爱的歌曲个数超过这个阈值，我们就把这个用户看作跟你口味相似的用户，把这个用户喜爱但你还没听过的歌曲，推荐给你。</p><p>不过，刚刚的这个解决方案中有一个问题，我们如何知道用户喜爱哪首歌曲呢？也就是说，如何定义用户对某首歌曲的喜爱程度呢？</p><p>实际上，我们可以通过用户的行为，来定义这个喜爱程度。我们给每个行为定义一个得分，得分越高表示喜爱程度越高。</p><p><img src="https://static001.geekbang.org/resource/image/93/a6/93c26a89303a748199528fdd998ebba6.jpg" alt="img"></p><p>还是刚刚那个例子，我们如果把每个人对每首歌曲的喜爱程度表示出来，就是下面这个样子。图中，某个人对某首歌曲是否喜爱，我们不再用“1”或者“0”来表示，而是对应一个具体的分值。</p><p><img src="https://static001.geekbang.org/resource/image/05/a9/056552502f1cf4fdf331488e0eed5fa9.jpg" alt="img"></p><p>有了这样一个用户对歌曲的喜爱程度的对应表之后，如何来判断两个用户是否口味相似呢？</p><p>显然，我们不能再像之前那样，采用简单的计数来统计两个用户之间的相似度。还记得我们之前讲字符串相似度度量时，提到的编辑距离吗？这里的相似度度量，我们可以使用另外一个距离，那就是<strong>欧几里得距离</strong>（Euclidean distance）。欧几里得距离是用来计算两个向量之间的距离的。这个概念中有两个关键词，向量和距离，我来给你解释一下。</p><p>一维空间是一条线，我们用 1，2，3……这样单个的数，来表示一维空间中的某个位置；二维空间是一个面，我们用（1，3）（4，2）（2，2）……这样的两个数，来表示二维空间中的某个位置；三维空间是一个立体空间，我们用（1，3，5）（3，1，7）（2，4，3）……这样的三个数，来表示三维空间中的某个位置。一维、二维、三维应该都不难理解，那更高维中的某个位置该如何表示呢？</p><p>类比一维、二维、三维的表示方法，K 维空间中的某个位置，我们可以写作（<em>X</em>1，<em>X</em>2，<em>X</em>3，…，<em>X**K</em>）。这种表示方法就是<strong>向量</strong>（vector）。我们知道，二维、三维空间中，两个位置之间有距离的概念，类比到高纬空间，同样也有距离的概念，这就是我们说的两个向量之间的距离。</p><p>那如何计算两个向量之间的距离呢？我们还是可以类比到二维、三维空间中距离的计算方法。通过类比，我们就可以得到两个向量之间距离的计算公式。这个计算公式就是欧几里得距离的计算公式：</p><p><img src="https://static001.geekbang.org/resource/image/f4/12/f4d1d906c076688a43380f82e47dce12.jpg" alt="img"></p><p>我们把每个用户对所有歌曲的喜爱程度，都用一个向量表示。我们计算出两个向量之间的欧几里得距离，作为两个用户的口味相似程度的度量。从图中的计算可以看出，小明与你的欧几里得距离距离最小，也就是说，你俩在高维空间中靠得最近，所以，我们就断定，小明跟你的口味最相似。</p><p><img src="https://static001.geekbang.org/resource/image/3e/89/3e145a3054c1abdea5d3f207d13e9b89.jpg" alt="img"></p><h3 id="2-基于相似歌曲做推荐"><a href="#2-基于相似歌曲做推荐" class="headerlink" title="2. 基于相似歌曲做推荐"></a>2. 基于相似歌曲做推荐</h3><p>刚刚我们讲了基于相似用户的歌曲推荐方法，但是，如果用户是一个新用户，我们还没有收集到足够多的行为数据，这个时候该如何推荐呢？我们现在再来看另外一种推荐方法，基于相似歌曲的推荐方法，也就是说，如果某首歌曲跟你喜爱的歌曲相似，我们就把它推荐给你。</p><p>如何判断两首歌曲是否相似呢？对于人来说，这个事情可能会比较简单，但是对于计算机来说，判断两首歌曲是否相似，那就需要通过量化的数据来表示了。我们应该通过什么数据来量化两个歌曲之间的相似程度呢？</p><p>最容易想到的是，我们对歌曲定义一些特征项，比如是伤感的还是愉快的，是摇滚还是民谣，是柔和的还是高亢的等等。类似基于相似用户的推荐方法，我们给每个歌曲的每个特征项打一个分数，这样每个歌曲就都对应一个特征项向量。我们可以基于这个特征项向量，来计算两个歌曲之间的欧几里得距离。欧几里得距离越小，表示两个歌曲的相似程度越大。</p><p>但是，要实现这个方案，需要有一个前提，那就是我们能够找到足够多，并且能够全面代表歌曲特点的特征项，除此之外，我们还要人工给每首歌标注每个特征项的得分。对于收录了海量歌曲的音乐 App 来说，这显然是一个非常大的工程。此外，人工标注有很大的主观性，也会影响到推荐的准确性。</p><p>既然基于歌曲特征项计算相似度不可行，那我们就换一种思路。对于两首歌，如果喜欢听的人群都是差不多的，那侧面就可以反映出，这两首歌比较相似。如图所示，每个用户对歌曲有不同的喜爱程度，我们依旧通过上一个解决方案中定义得分的标准，来定义喜爱程度。</p><p><img src="https://static001.geekbang.org/resource/image/a3/ff/a324908e162a60efea4bd7c47c04a6ff.jpg" alt="img"></p><p>你有没有发现，这个图跟基于相似用户推荐中的图几乎一样。只不过这里把歌曲和用户主次颠倒了一下。基于相似用户的推荐方法中，针对每个用户，我们将对各个歌曲的喜爱程度作为向量。基于相似歌曲的推荐思路中，针对每个歌曲，我们将每个用户的打分作为向量。</p><p>有了每个歌曲的向量表示，我们通过计算向量之间的欧几里得距离，来表示歌曲之间的相似度。欧几里得距离越小，表示两个歌曲越相似。然后，我们就在用户已经听过的歌曲中，找出他喜爱程度较高的歌曲。然后，我们找出跟这些歌曲相似度很高的其他歌曲，推荐给他。</p><h2 id="总结引申-4"><a href="#总结引申-4" class="headerlink" title="总结引申"></a>总结引申</h2><p>实际上，这个问题是<strong>推荐系统</strong>（Recommendation System）里最典型的一类问题。之所以讲这部分内容，主要还是想给你展示，算法的强大之处，利用简单的向量空间的欧几里得距离，就能解决如此复杂的问题。不过，今天，我只给你讲解了基本的理论，实践中遇到的问题还有很多，比如冷启动问题，产品初期积累的数据不多，不足以做推荐等等。这些更加深奥的内容，你可以之后自己在实践中慢慢探索。</p><h2 id="课后思考-4"><a href="#课后思考-4" class="headerlink" title="课后思考"></a>课后思考</h2><p>关于今天讲的推荐算法，你还能想到其他应用场景吗？</p><p>欢迎留言和我分享，也欢迎点击“请朋友读”，把今天的内容分享给你的好友，和他一起讨论、学习。</p><h1 id="48-B-树：MySQL数据库索引是如何实现的？"><a href="#48-B-树：MySQL数据库索引是如何实现的？" class="headerlink" title="48 | B+树：MySQL数据库索引是如何实现的？"></a>48 | B+树：MySQL数据库索引是如何实现的？</h1><p>王争 2019-01-16</p><p><img src="https://static001.geekbang.org/resource/image/36/dc/36475968a64a81ceb13b8be7a1f20edc.jpg" alt="img"></p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADYAAAABCAYAAACVOl3IAAAAJUlEQVQYV2N89+7df0FBQQYQeP/+PZgGAUJilMpjs4dSM5H1AwBwSSrLZGasMwAAAABJRU5ErkJggg==" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAABCAYAAADeko4lAAAAHUlEQVQYV2N89+7dfwYoEBQUBLPev3/PgItNSC0ADtASy+rFJtUAAAAASUVORK5CYII=" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADoAAAABCAYAAACPBr1GAAAAJ0lEQVQYV2N89+7dfwYoEBQUBLPev3/PQAkbm3mE7KBUHpd7YeYCAE50MMsBeqQ5AAAAAElFTkSuQmCC" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAABCAYAAAAB3PQ6AAAAHUlEQVQYV2N89+7df0FBQQYQeP/+PQMxbLBiIAAAQE0Py6Kq0rkAAAAASUVORK5CYII=" alt="img"></p><p></p><p>00:23</p><p><a href="javascript:;">1.25x<em></em></a></p><p>讲述：冯永吉 大小：12.84M 时长：14:00</p><p>作为一个软件开发工程师，你对数据库肯定再熟悉不过了。作为主流的数据存储系统，它在我们的业务开发中，有着举足轻重的地位。在工作中，为了加速数据库中数据的查找速度，我们常用的处理思路是，对表中数据创建索引。那你是否思考过，<strong>数据库索引是如何实现的呢？底层使用的是什么数据结构和算法呢？</strong></p><h2 id="算法解析-5"><a href="#算法解析-5" class="headerlink" title="算法解析"></a>算法解析</h2><p>思考的过程比结论更重要。跟着我学习了这么多节课，很多同学已经意识到这一点，比如 Jerry 银银同学。我感到很开心。所以，今天的讲解，我会尽量还原这个解决方案的思考过程，让你知其然，并且知其所以然。</p><h3 id="1-解决问题的前提是定义清楚问题"><a href="#1-解决问题的前提是定义清楚问题" class="headerlink" title="1. 解决问题的前提是定义清楚问题"></a>1. 解决问题的前提是定义清楚问题</h3><p>如何定义清楚问题呢？除了对问题进行详细的调研，还有一个办法，那就是，通过<strong>对一些模糊的需求进行假设，来限定<strong><strong>要</strong></strong>解决的问题的范围</strong>。</p><p>如果你对数据库的操作非常了解，针对我们现在这个问题，你就能把索引的需求定义得非常清楚。但是，对于大部分软件工程师来说，我们可能只了解一小部分常用的 SQL 语句，所以，这里我们假设要解决的问题，只包含这样两个常用的需求：</p><p>根据某个值查找数据，比如 select * from user where id=1234；</p><p>根据区间值来查找某些数据，比如 select * from user where id &gt; 1234 and id &lt; 2345。</p><p>除了这些功能性需求之外，这种问题往往还会涉及一些非功能性需求，比如安全、性能、用户体验等等。限于专栏要讨论的主要是数据结构和算法，对于非功能性需求，我们着重考虑<strong>性能方面</strong>的需求。性能方面的需求，我们主要考察时间和空间两方面，也就是<strong>执行效率和存储空间</strong>。</p><p>在执行效率方面，我们希望通过索引，查询数据的效率尽可能地高；在存储空间方面，我们希望索引不要消耗太多的内存空间。</p><h3 id="2-尝试用学过的数据结构解决这个问题"><a href="#2-尝试用学过的数据结构解决这个问题" class="headerlink" title="2. 尝试用学过的数据结构解决这个问题"></a>2. 尝试用学过的数据结构解决这个问题</h3><p>问题的需求大致定义清楚了，我们现在回想一下，能否利用已经学习过的数据结构解决这个问题呢？支持快速查询、插入等操作的动态数据结构，我们已经学习过散列表、平衡二叉查找树、跳表。</p><p>我们先来看<strong>散列表</strong>。散列表的查询性能很好，时间复杂度是 O(1)。但是，散列表不能支持按照区间快速查找数据。所以，散列表不能满足我们的需求。</p><p>我们再来看<strong>平衡二叉查找树</strong>。尽管平衡二叉查找树查询的性能也很高，时间复杂度是 O(logn)。而且，对树进行中序遍历，我们还可以得到一个从小到大有序的数据序列，但这仍然不足以支持按照区间快速查找数据。</p><p>我们再来看<strong>跳表</strong>。跳表是在链表之上加上多层索引构成的。它支持快速地插入、查找、删除数据，对应的时间复杂度是 O(logn)。并且，跳表也支持按照区间快速地查找数据。我们只需要定位到区间起点值对应在链表中的结点，然后从这个结点开始，顺序遍历链表，直到区间终点对应的结点为止，这期间遍历得到的数据就是满足区间值的数据。</p><p><img src="https://static001.geekbang.org/resource/image/49/65/492206afe5e2fef9f683c7cff83afa65.jpg" alt="img"></p><p>这样看来，跳表是可以解决这个问题。实际上，数据库索引所用到的数据结构跟跳表非常相似，叫作 B+ 树。不过，它是通过二叉查找树演化过来的，而非跳表。为了给你还原发明 B+ 树的整个思考过程，所以，接下来，我还要从二叉查找树讲起，看它是如何一步一步被改造成 B+ 树的。</p><h3 id="3-改造二叉查找树来解决这个问题"><a href="#3-改造二叉查找树来解决这个问题" class="headerlink" title="3. 改造二叉查找树来解决这个问题"></a>3. 改造二叉查找树来解决这个问题</h3><p>为了让二叉查找树支持按照区间来查找数据，我们可以对它进行这样的改造：树中的节点并不存储数据本身，而是只是作为索引。除此之外，我们把每个叶子节点串在一条链表上，链表中的数据是从小到大有序的。经过改造之后的二叉树，就像图中这样，看起来是不是很像跳表呢？</p><p><img src="https://static001.geekbang.org/resource/image/25/f4/25700c1dc28ce094eed3ffac394531f4.jpg" alt="img"></p><p>改造之后，如果我们要求某个区间的数据。我们只需要拿区间的起始值，在树中进行查找，当查找到某个叶子节点之后，我们再顺着链表往后遍历，直到链表中的结点数据值大于区间的终止值为止。所有遍历到的数据，就是符合区间值的所有数据。</p><p><img src="https://static001.geekbang.org/resource/image/1c/cc/1cf179c03c702a6ef5b9336f5b1eaecc.jpg" alt="img"></p><p>但是，我们要为几千万、上亿的数据构建索引，如果将索引存储在内存中，尽管内存访问的速度非常快，查询的效率非常高，但是，占用的内存会非常多。</p><p>比如，我们给一亿个数据构建二叉查找树索引，那索引中会包含大约 1 亿个节点，每个节点假设占用 16 个字节，那就需要大约 1GB 的内存空间。给一张表建立索引，我们需要 1GB 的内存空间。如果我们要给 10 张表建立索引，那对内存的需求是无法满足的。如何解决这个索引占用太多内存的问题呢？</p><p>我们可以借助时间换空间的思路，把索引存储在硬盘中，而非内存中。我们都知道，硬盘是一个非常慢速的存储设备。通常内存的访问速度是纳秒级别的，而磁盘访问的速度是毫秒级别的。读取同样大小的数据，从磁盘中读取花费的时间，是从内存中读取所花费时间的上万倍，甚至几十万倍。</p><p>这种将索引存储在硬盘中的方案，尽管减少了内存消耗，但是在数据查找的过程中，需要读取磁盘中的索引，因此数据查询效率就相应降低很多。</p><p>二叉查找树，经过改造之后，支持区间查找的功能就实现了。不过，为了节省内存，如果把树存储在硬盘中，那么每个节点的读取（或者访问），都对应一次磁盘 IO 操作。树的高度就等于每次查询数据时磁盘 IO 操作的次数。</p><p>我们前面讲到，比起内存读写操作，磁盘 IO 操作非常耗时，所以我们优化的重点就是尽量减少磁盘 IO 操作，也就是，尽量降低树的高度。那如何降低树的高度呢？</p><p>我们来看下，如果我们把索引构建成 m 叉树，高度是不是比二叉树要小呢？如图所示，给 16 个数据构建二叉树索引，树的高度是 4，查找一个数据，就需要 4 个磁盘 IO 操作（如果根节点存储在内存中，其他节点存储在磁盘中），如果对 16 个数据构建五叉树索引，那高度只有 2，查找一个数据，对应只需要 2 次磁盘操作。如果 m 叉树中的 m 是 100，那对一亿个数据构建索引，树的高度也只是 3，最多只要 3 次磁盘 IO 就能获取到数据。磁盘 IO 变少了，查找数据的效率也就提高了。</p><p><img src="https://static001.geekbang.org/resource/image/69/59/69d4c48c1257dcb7dd6077d961b86259.jpg" alt="img"></p><p><img src="https://static001.geekbang.org/resource/image/76/cc/769687f57190a826a8f6f82793491ccc.jpg" alt="img"></p><p>如果我们将 m 叉树实现 B+ 树索引，用代码实现出来，就是下面这个样子（假设我们给 int 类型的数据库字段添加索引，所以代码中的 keywords 是 int 类型的）：</p><p>/**</p><p> * 这是B+树非叶子节点的定义。</p><p> *</p><p> * 假设keywords=[3, 5, 8, 10]</p><p> * 4个键值将数据分为5个区间：(-INF,3), [3,5), [5,8), [8,10), [10,INF)</p><p> * 5个区间分别对应：children[0]…children[4]</p><p> *</p><p> * m值是事先计算得到的，计算的依据是让所有信息的大小正好等于页的大小：</p><p> * PAGE_SIZE = (m-1)<em>4[keywordss大小]+m</em>8[children大小]</p><p> */</p><p>public class BPlusTreeNode {</p><p>  public static int m = 5; // 5叉树</p><p>  public int[] keywords = new int[m-1]; // 键值，用来划分数据区间</p><p>  public BPlusTreeNode[] children = new BPlusTreeNode[m];//保存子节点指针</p><p>}</p><p>/**</p><p> * 这是B+树中叶子节点的定义。</p><p> *</p><p> * B+树中的叶子节点跟内部节点是不一样的,</p><p> * 叶子节点存储的是值，而非区间。</p><p> * 这个定义里，每个叶子节点存储3个数据行的键值及地址信息。</p><p> *</p><p> * k值是事先计算得到的，计算的依据是让所有信息的大小正好等于页的大小：</p><p> * PAGE_SIZE = k<em>4[keyw..大小]+k</em>8[dataAd..大小]+8[prev大小]+8[next大小]</p><p> */</p><p>public class BPlusTreeLeafNode {</p><p>  public static int k = 3;</p><p>  public int[] keywords = new int[k]; // 数据的键值</p><p>  public long[] dataAddress = new long[k]; // 数据地址</p><p>  public BPlusTreeLeafNode prev; // 这个结点在链表中的前驱结点</p><p>  public BPlusTreeLeafNode next; // 这个结点在链表中的后继结点</p><p>}</p><p>我稍微解释一下这段代码。</p><p>对于相同个数的数据构建 m 叉树索引，m 叉树中的 m 越大，那树的高度就越小，那 m 叉树中的 m 是不是越大越好呢？到底多大才最合适呢？</p><p>不管是内存中的数据，还是磁盘中的数据，操作系统都是按页（一页大小通常是 4KB，这个值可以通过 getconfig PAGE_SIZE 命令查看）来读取的，一次会读一页的数据。如果要读取的数据量超过一页的大小，就会触发多次 IO 操作。所以，我们在选择 m 大小的时候，要尽量让每个节点的大小等于一个页的大小。读取一个节点，只需要一次磁盘 IO 操作。</p><p><img src="https://static001.geekbang.org/resource/image/ea/30/ea4472fd7bb7fa948532c8c8ba334430.jpg" alt="img"></p><p>尽管索引可以提高数据库的查询效率，但是，作为一名开发工程师，你应该也知道，索引有利也有弊，它也会让写入数据的效率下降。这是为什么呢？</p><p>数据的写入过程，会涉及索引的更新，这是索引导致写入变慢的主要原因。</p><p>对于一个 B+ 树来说，m 值是根据页的大小事先计算好的，也就是说，每个节点最多只能有 m 个子节点。在往数据库中写入数据的过程中，这样就有可能使索引中某些节点的子节点个数超过 m，这个节点的大小超过了一个页的大小，读取这样一个节点，就会导致多次磁盘 IO 操作。我们该如何解决这个问题呢？</p><p>实际上，处理思路并不复杂。我们只需要将这个节点分裂成两个节点。但是，节点分裂之后，其上层父节点的子节点个数就有可能超过 m 个。不过这也没关系，我们可以用同样的方法，将父节点也分裂成两个节点。这种级联反应会从下往上，一直影响到根节点。这个分裂过程，你可以结合着下面这个图一块看，会更容易理解（图中的 B+ 树是一个三叉树。我们限定叶子节点中，数据的个数超过 2 个就分裂节点；非叶子节点中，子节点的个数超过 3 个就分裂节点）。</p><p><img src="https://static001.geekbang.org/resource/image/18/e0/1800bc80e1e05b32a042ff6873e6c2e0.jpg" alt="img"></p><p>正是因为要时刻保证 B+ 树索引是一个 m 叉树，所以，索引的存在会导致数据库写入的速度降低。实际上，不光写入数据会变慢，删除数据也会变慢。这是为什么呢？</p><p>我们在删除某个数据的时候，也要对应地更新索引节点。这个处理思路有点类似跳表中删除数据的处理思路。频繁的数据删除，就会导致某些节点中，子节点的个数变得非常少，长此以往，如果每个节点的子节点都比较少，势必会影响索引的效率。</p><p>我们可以设置一个阈值。在 B+ 树中，这个阈值等于 m/2。如果某个节点的子节点个数小于 m/2，我们就将它跟相邻的兄弟节点合并。不过，合并之后节点的子节点个数有可能会超过 m。针对这种情况，我们可以借助插入数据时候的处理方法，再分裂节点。</p><p>文字描述不是很直观，我举了一个删除操作的例子，你可以对比着看下（图中的 B+ 树是一个五叉树。我们限定叶子节点中，数据的个数少于 2 个就合并节点；非叶子节点中，子节点的个数少于 3 个就合并节点。）。</p><p><img src="https://static001.geekbang.org/resource/image/17/18/1730e34450dad29f062e76536622c918.jpg" alt="img"></p><p>数据库索引以及 B+ 树的由来，到此就讲完了。你有没有发现，B+ 树的结构和操作，跟跳表非常类似。理论上讲，对跳表稍加改造，也可以替代 B+ 树，作为数据库的索引实现的。</p><p>B+ 树发明于 1972 年，跳表发明于 1989 年，我们可以大胆猜想下，跳表的作者有可能就是受了 B+ 树的启发，才发明出跳表来的。不过，这个也无从考证了。</p><h2 id="总结引申-5"><a href="#总结引申-5" class="headerlink" title="总结引申"></a>总结引申</h2><p>今天，我们讲解了数据库索引实现，依赖的底层数据结构，B+ 树。它通过存储在磁盘的多叉树结构，做到了时间、空间的平衡，既保证了执行效率，又节省了内存。</p><p>前面的讲解中，为了一步一步详细地给你介绍 B+ 树的由来，内容看起来比较零散。为了方便你掌握和记忆，我这里再总结一下 B+ 树的特点：</p><p>每个节点中子节点的个数不能超过 m，也不能小于 m/2；</p><p>根节点的子节点个数可以不超过 m/2，这是一个例外；</p><p>m 叉树只存储索引，并不真正存储数据，这个有点儿类似跳表；</p><p>通过链表将叶子节点串联在一起，这样可以方便按区间查找；</p><p>一般情况，根节点会被存储在内存中，其他节点存储在磁盘中。</p><p>除了 B+ 树，你可能还听说过 B 树、B- 树，我这里简单提一下。实际上，B- 树就是 B 树，英文翻译都是 B-Tree，这里的“-”并不是相对 B+ 树中的“+”，而只是一个连接符。这个很容易误解，所以我强调下。</p><p>而 B 树实际上是低级版的 B+ 树，或者说 B+ 树是 B 树的改进版。B 树跟 B+ 树的不同点主要集中在这几个地方：</p><p>B+ 树中的节点不存储数据，只是索引，而 B 树中的节点存储数据；</p><p>B 树中的叶子节点并不需要链表来串联。</p><p>也就是说，B 树只是一个每个节点的子节点个数不能小于 m/2 的 m 叉树。</p><h2 id="课后思考-5"><a href="#课后思考-5" class="headerlink" title="课后思考"></a>课后思考</h2><p>B+ 树中，将叶子节点串起来的链表，是单链表还是双向链表？为什么？</p><p>我们对平衡二叉查找树进行改造，将叶子节点串在链表中，就支持了按照区间来查找数据。我们在散列表（下）讲到，散列表也经常跟链表一块使用，如果我们把散列表中的结点，也用链表串起来，能否支持按照区间查找数据呢？</p><p>欢迎留言和我分享，也欢迎点击“请朋友读”，把今天的内容分享给你的好友，和他一起讨论、学习。</p><h1 id="49-搜索：如何用A-搜索算法实现游戏中的寻路功能？"><a href="#49-搜索：如何用A-搜索算法实现游戏中的寻路功能？" class="headerlink" title="49 | 搜索：如何用A*搜索算法实现游戏中的寻路功能？"></a>49 | 搜索：如何用A*搜索算法实现游戏中的寻路功能？</h1><p>王争 2019-01-18</p><p><img src="https://static001.geekbang.org/resource/image/05/b3/059c152aaa2cf0203a48bc6137052fb3.jpg" alt="img"></p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADYAAAABCAYAAACVOl3IAAAAJUlEQVQYV2N89+7df0FBQQYQeP/+PZgGAUJilMpjs4dSM5H1AwBwSSrLZGasMwAAAABJRU5ErkJggg==" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAABCAYAAADeko4lAAAAHUlEQVQYV2N89+7dfwYoEBQUBLPev3/PgItNSC0ADtASy+rFJtUAAAAASUVORK5CYII=" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADoAAAABCAYAAACPBr1GAAAAJ0lEQVQYV2N89+7dfwYoEBQUBLPev3/PQAkbm3mE7KBUHpd7YeYCAE50MMsBeqQ5AAAAAElFTkSuQmCC" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAABCAYAAAAB3PQ6AAAAHUlEQVQYV2N89+7df0FBQQYQeP/+PQMxbLBiIAAAQE0Py6Kq0rkAAAAASUVORK5CYII=" alt="img"></p><p></p><p>00:22</p><p><a href="javascript:;">1.25x<em></em></a></p><p>讲述：冯永吉 大小：10.28M 时长：11:13</p><p>魔兽世界、仙剑奇侠传这类 MMRPG 游戏，不知道你有没有玩过？在这些游戏中，有一个非常重要的功能，那就是人物角色自动寻路。<strong>当人物处于游戏地图中的某个位置的时候，我们用鼠标点击另外一个相对较远的位置，人物就会自动地绕过障碍物走过去。玩过这么多游戏，不知你是否思考过，这个功能是怎么实现的呢？</strong></p><h2 id="算法解析-6"><a href="#算法解析-6" class="headerlink" title="算法解析"></a>算法解析</h2><p>实际上，这是一个非常典型的搜索问题。人物的起点就是他当下所在的位置，终点就是鼠标点击的位置。我们需要在地图中，找一条从起点到终点的路径。这条路径要绕过地图中所有障碍物，并且看起来要是一种非常聪明的走法。所谓“聪明”，笼统地解释就是，走的路不能太绕。理论上讲，最短路径显然是最聪明的走法，是这个问题的最优解。</p><p>不过，在第 44 节最优出行路线规划问题中，我们也讲过，如果图非常大，那 Dijkstra 最短路径算法的执行耗时会很多。在真实的软件开发中，我们面对的是超级大的地图和海量的寻路请求，算法的执行效率太低，这显然是无法接受的。</p><p>实际上，像出行路线规划、游戏寻路，这些真实软件开发中的问题，一般情况下，我们都不需要非得求最优解（也就是最短路径）。在权衡路线规划质量和执行效率的情况下，我们只需要寻求一个次优解就足够了。那<strong>如何快速找出一条接近于最短路线的次优路线呢？</strong></p><p>这个快速的路径规划算法，就是我们今天要学习的 <strong>A* 算法</strong>。实际上，A* 算法是对 Dijkstra 算法的优化和改造。如何将 Dijkstra 算法改造成 A* 算法呢？为了更好地理解接下来要讲的内容，我建议你先温习下第 44 节中的 Dijkstra 算法的实现原理。</p><p>Dijkstra 算法有点儿类似 BFS 算法，它每次找到跟起点最近的顶点，往外扩展。这种往外扩展的思路，其实有些盲目。为什么这么说呢？我举一个例子来给你解释一下。下面这个图对应一个真实的地图，每个顶点在地图中的位置，我们用一个二维坐标（x，y）来表示，其中，x 表示横坐标，y 表示纵坐标。</p><p><img src="https://static001.geekbang.org/resource/image/11/dd/11840cc13071fe2da67675338e46cadd.jpg" alt="img"></p><p>在 Dijkstra 算法的实现思路中，我们用一个优先级队列，来记录已经遍历到的顶点以及这个顶点与起点的路径长度。顶点与起点路径长度越小，就越先被从优先级队列中取出来扩展，从图中举的例子可以看出，尽管我们找的是从 s 到 t 的路线，但是最先被搜索到的顶点依次是 1，2，3。通过肉眼来观察，这个搜索方向跟我们期望的路线方向（s 到 t 是从西向东）是反着的，路线搜索的方向明显“跑偏”了。</p><p>之所以会“跑偏”，那是因为我们是按照顶点与起点的路径长度的大小，来安排出队列顺序的。与起点越近的顶点，就会越早出队列。我们并没有考虑到这个顶点到终点的距离，所以，在地图中，尽管 1，2，3 三个顶点离起始顶点最近，但离终点却越来越远。</p><p>如果我们综合更多的因素，把这个顶点到终点可能还要走多远，也考虑进去，综合来判断哪个顶点该先出队列，那是不是就可以避免“跑偏”呢？</p><p>当我们遍历到某个顶点的时候，从起点走到这个顶点的路径长度是确定的，我们记作 g(i)（i 表示顶点编号）。但是，从这个顶点到终点的路径长度，我们是未知的。虽然确切的值无法提前知道，但是我们可以用其他估计值来代替。</p><p>这里我们可以通过这个顶点跟终点之间的直线距离，也就是欧几里得距离，来近似地估计这个顶点跟终点的路径长度（注意：路径长度跟直线距离是两个概念）。我们把这个距离记作 h(i)（i 表示这个顶点的编号），专业的叫法是<strong>启发函数</strong>（heuristic function）。因为欧几里得距离的计算公式，会涉及比较耗时的开根号计算，所以，我们一般通过另外一个更加简单的距离计算公式，那就是<strong>曼哈顿距离</strong>（Manhattan distance）。曼哈顿距离是两点之间横纵坐标的距离之和。计算的过程只涉及加减法、符号位反转，所以比欧几里得距离更加高效。</p><p>int hManhattan(Vertex v1, Vertex v2) { // Vertex表示顶点，后面有定义</p><p>  return Math.abs(v1.x - v2.x) + Math.abs(v1.y - v2.y);</p><p>}</p><p>原来只是单纯地通过顶点与起点之间的路径长度 g(i)，来判断谁先出队列，现在有了顶点到终点的路径长度估计值，我们通过两者之和 f(i)=g(i)+h(i)，来判断哪个顶点该最先出队列。综合两部分，我们就能有效避免刚刚讲的“跑偏”。这里 f(i) 的专业叫法是<strong>估价函数</strong>（evaluation function）。</p><p>从刚刚的描述，我们可以发现，A* 算法就是对 Dijkstra 算法的简单改造。实际上，代码实现方面，我们也只需要稍微改动几行代码，就能把 Dijkstra 算法的代码实现，改成 A* 算法的代码实现。</p><p>在 A* 算法的代码实现中，顶点 Vertex 类的定义，跟 Dijkstra 算法中的定义，稍微有点儿区别，多了 x，y 坐标，以及刚刚提到的 f(i) 值。图 Graph 类的定义跟 Dijkstra 算法中的定义一样。为了避免重复，我这里就没有再贴出来了。</p><p>private class Vertex {</p><p>  public int id; // 顶点编号ID</p><p>  public int dist; // 从起始顶点，到这个顶点的距离，也就是g(i)</p><p>  public int f; // 新增：f(i)=g(i)+h(i)</p><p>  public int x, y; // 新增：顶点在地图中的坐标（x, y）</p><p>  public Vertex(int id, int x, int y) {</p><p>​    this.id = id;</p><p>​    this.x = x;</p><p>​    this.y = y;</p><p>​    this.f = Integer.MAX_VALUE;</p><p>​    this.dist = Integer.MAX_VALUE;</p><p>  }</p><p>}</p><p>// Graph类的成员变量，在构造函数中初始化</p><p>Vertex[] vertexes = new Vertex[this.v];</p><p>// 新增一个方法，添加顶点的坐标</p><p>public void addVetex(int id, int x, int y) {</p><p>  vertexes[id] = new Vertex(id, x, y)</p><p>}</p><p>A* 算法的代码实现的主要逻辑是下面这段代码。它跟 Dijkstra 算法的代码实现，主要有 3 点区别：</p><p>优先级队列构建的方式不同。A* 算法是根据 f 值（也就是刚刚讲到的 f(i)=g(i)+h(i)）来构建优先级队列，而 Dijkstra 算法是根据 dist 值（也就是刚刚讲到的 g(i)）来构建优先级队列；</p><p>A* 算法在更新顶点 dist 值的时候，会同步更新 f 值；</p><p>循环结束的条件也不一样。Dijkstra 算法是在终点出队列的时候才结束，A* 算法是一旦遍历到终点就结束。</p><p>public void astar(int s, int t) { // 从顶点s到顶点t的路径</p><p>  int[] predecessor = new int[this.v]; // 用来还原路径</p><p>  // 按照vertex的f值构建的小顶堆，而不是按照dist</p><p>  PriorityQueue queue = new PriorityQueue(this.v);</p><p>  boolean[] inqueue = new boolean[this.v]; // 标记是否进入过队列</p><p>  vertexes[s].dist = 0;</p><p>  vertexes[s].f = 0;</p><p>  queue.add(vertexes[s]);</p><p>  inqueue[s] = true;</p><p>  while (!queue.isEmpty()) {</p><p>​    Vertex minVertex = queue.poll(); // 取堆顶元素并删除</p><p>​    for (int i = 0; i &lt; adj[minVertex.id].size(); ++i) {</p><p>​      Edge e = adj[minVertex.id].get(i); // 取出一条minVetex相连的边</p><p>​      Vertex nextVertex = vertexes[e.tid]; // minVertex–&gt;nextVertex</p><p>​      if (minVertex.dist + e.w &lt; nextVertex.dist) { // 更新next的dist,f</p><p>​        nextVertex.dist = minVertex.dist + e.w;</p><p>​        nextVertex.f </p><p>​           = nextVertex.dist+hManhattan(nextVertex, vertexes[t]);</p><p>​        predecessor[nextVertex.id] = minVertex.id;</p><p>​        if (inqueue[nextVertex.id] == true) {</p><p>​          queue.update(nextVertex);</p><p>​        } else {</p><p>​          queue.add(nextVertex);</p><p>​          inqueue[nextVertex.id] = true;</p><p>​        }</p><p>​      }</p><p>​      if (nextVertex.id == t) { // 只要到达t就可以结束while了</p><p>​        queue.clear(); // 清空queue，才能推出while循环</p><p>​        break; </p><p>​      }</p><p>​    }</p><p>  }</p><p>  // 输出路径</p><p>  System.out.print(s);</p><p>  print(s, t, predecessor); // print函数请参看Dijkstra算法的实现</p><p>}</p><p><strong>尽管 A* 算法可以更加快速地找到从起点到终点的路线，但是它并不能像 Dijkstra 算法那样，找到最短路线。这是为什么呢？</strong></p><p>要找出起点 s 到终点 t 的最短路径，最简单的方法是，通过回溯穷举所有从 s 到达 t 的不同路径，然后对比找出最短的那个。不过很显然，回溯算法的执行效率非常低，是指数级的。</p><p><img src="https://static001.geekbang.org/resource/image/38/4a/38ebd9aab387669465226fc7f644064a.jpg" alt="img"></p><p>Dijkstra 算法在此基础之上，利用动态规划的思想，对回溯搜索进行了剪枝，只保留起点到某个顶点的最短路径，继续往外扩展搜索。动态规划相较于回溯搜索，只是换了一个实现思路，但它实际上也考察到了所有从起点到终点的路线，所以才能得到最优解。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp83hwf25mj30vq0jfwg8.jpg" alt="img"></p><p>A* 算法之所以不能像 Dijkstra 算法那样，找到最短路径，主要原因是两者的 while 循环结束条件不一样。刚刚我们讲过，Dijkstra 算法是在终点出队列的时候才结束，A* 算法是一旦遍历到终点就结束。对于 Dijkstra 算法来说，当终点出队列的时候，终点的 dist 值是优先级队列中所有顶点的最小值，即便再运行下去，终点的 dist 值也不会再被更新了。对于 A* 算法来说，一旦遍历到终点，我们就结束 while 循环，这个时候，终点的 dist 值未必是最小值。</p><p>A* 算法利用贪心算法的思路，每次都找 f 值最小的顶点出队列，一旦搜索到终点就不在继续考察其他顶点和路线了。所以，它并没有考察所有的路线，也就不可能找出最短路径了。</p><p>搞懂了 A* 算法，我们再来看下，<strong>如何借助 A* 算法解决今天的游戏寻路问题？</strong></p><p>要利用 A* 算法解决这个问题，我们只需要把地图，抽象成图就可以了。不过，游戏中的地图跟第 44 节中讲的我们平常用的地图是不一样的。因为游戏中的地图并不像我们现实生活中那样，存在规划非常清晰的道路，更多的是宽阔的荒野、草坪等。所以，我们没法利用 44 节中讲到的抽象方法，把岔路口抽象成顶点，把道路抽象成边。</p><p>实际上，我们可以换一种抽象的思路，把整个地图分割成一个一个的小方块。在某一个方块上的人物，只能往上下左右四个方向的方块上移动。我们可以把每个方块看作一个顶点。两个方块相邻，我们就在它们之间，连两条有向边，并且边的权值都是 1。所以，这个问题就转化成了，在一个有向有权图中，找某个顶点到另一个顶点的路径问题。将地图抽象成边权值为 1 的有向图之后，我们就可以套用 A* 算法，来实现游戏中人物的自动寻路功能了。</p><h2 id="总结引申-6"><a href="#总结引申-6" class="headerlink" title="总结引申"></a>总结引申</h2><p>我们今天讲的 A* 算法属于一种<strong>启发式搜索算法</strong>（Heuristically Search Algorithm）。实际上，启发式搜索算法并不仅仅只有 A* 算法，还有很多其他算法，比如 IDA* 算法、蚁群算法、遗传算法、模拟退火算法等。如果感兴趣，你可以自行研究下。</p><p>启发式搜索算法利用估价函数，避免“跑偏”，贪心地朝着最有可能到达终点的方向前进。这种算法找出的路线，并不是最短路线。但是，实际的软件开发中的路线规划问题，我们往往并不需要非得找最短路线。所以，鉴于启发式搜索算法能很好地平衡路线质量和执行效率，它在实际的软件开发中的应用更加广泛。实际上，在第 44 节中，我们讲到的地图 App 中的出行路线规划问题，也可以利用启发式搜索算法来实现。</p><h2 id="课后思考-6"><a href="#课后思考-6" class="headerlink" title="课后思考"></a>课后思考</h2><p>我们之前讲的“迷宫问题”是否可以借助 A* 算法来更快速地找到一个走出去的路线呢？如果可以，请具体讲讲该怎么来做；如果不可以，请说说原因。</p><p>欢迎留言和我分享，也欢迎点击“请朋友读”，把今天的内容分享给你的好友，和他一起讨论、学习。</p><h1 id="50-索引：如何在海量数据中快速查找某个数据？"><a href="#50-索引：如何在海量数据中快速查找某个数据？" class="headerlink" title="50 | 索引：如何在海量数据中快速查找某个数据？"></a>50 | 索引：如何在海量数据中快速查找某个数据？</h1><p>王争 2019-01-21</p><p><img src="https://static001.geekbang.org/resource/image/2b/10/2bcfe50eece74bbeb969e253f30c4b10.jpg" alt="img"></p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADYAAAABCAYAAACVOl3IAAAAJUlEQVQYV2N89+7df0FBQQYQeP/+PZgGAUJilMpjs4dSM5H1AwBwSSrLZGasMwAAAABJRU5ErkJggg==" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAABCAYAAADeko4lAAAAHUlEQVQYV2N89+7dfwYoEBQUBLPev3/PgItNSC0ADtASy+rFJtUAAAAASUVORK5CYII=" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADoAAAABCAYAAACPBr1GAAAAJ0lEQVQYV2N89+7dfwYoEBQUBLPev3/PQAkbm3mE7KBUHpd7YeYCAE50MMsBeqQ5AAAAAElFTkSuQmCC" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAABCAYAAAAB3PQ6AAAAHUlEQVQYV2N89+7df0FBQQYQeP/+PQMxbLBiIAAAQE0Py6Kq0rkAAAAASUVORK5CYII=" alt="img"></p><p></p><p>00:10</p><p><a href="javascript:;">1.25x<em></em></a></p><p>讲述：冯永吉 大小：9.82M 时长：10:42</p><p>在第 48 节中，我们讲了 MySQL 数据库索引的实现原理。MySQL 底层依赖的是 B+ 树这种数据结构。留言里有同学问我，那<strong>类似 Redis 这样的 Key-Value 数据库中的索引，又是怎么实现的呢？底层依赖的又是什么数据结构呢？</strong></p><p>今天，我就来讲一下索引这种常用的技术解决思路，底层往往会依赖哪些数据结构。同时，通过索引这个应用场景，我也带你回顾一下，之前我们学过的几种支持动态集合的数据结构。</p><h2 id="为什么需要索引？"><a href="#为什么需要索引？" class="headerlink" title="为什么需要索引？"></a>为什么需要索引？</h2><p>在实际的软件开发中，业务纷繁复杂，功能千变万化，但是，万变不离其宗。如果抛开这些业务和功能的外壳，其实它们的本质都可以抽象为“对数据的存储和计算”。对应到数据结构和算法中，那“存储”需要的就是数据结构，“计算”需要的就是算法。</p><p>对于存储的需求，功能上无外乎增删改查。这其实并不复杂。但是，一旦存储的数据很多，那性能就成了这些系统要关注的重点，特别是在一些跟存储相关的基础系统（比如 MySQL 数据库、分布式文件系统等）、中间件（比如消息中间件 RocketMQ 等）中。</p><p>“如何节省存储空间、如何提高数据增删改查的执行效率”，这样的问题就成了设计的重点。而这些系统的实现，都离不开一个东西，那就是<strong>索引</strong>。不夸张地说，索引设计得好坏，直接决定了这些系统是否优秀。</p><p>索引这个概念，非常好理解。你可以类比书籍的目录来理解。如果没有目录，我们想要查找某个知识点的时候，就要一页一页翻。通过目录，我们就可以快速定位相关知识点的页数，查找的速度也会有质的提高。</p><h2 id="索引的需求定义"><a href="#索引的需求定义" class="headerlink" title="索引的需求定义"></a>索引的需求定义</h2><p>索引的概念不难理解，我想你应该已经搞明白。接下来，我们就分析一下，在设计索引的过程中，需要考虑到的一些因素，换句话说就是，我们该如何定义清楚需求呢？</p><p>对于系统设计需求，我们一般可以从<strong>功能性需求</strong>和<strong>非功能性需求</strong>两方面来分析，这个我们之前也说过。因此，这个问题也不例外。</p><h3 id="1-功能性需求"><a href="#1-功能性需求" class="headerlink" title="1. 功能性需求"></a>1. 功能性需求</h3><p>对于功能性需求需要考虑的点，我把它们大致概括成下面这几点。</p><p><strong>数据是格式化数据还是非格式化数据</strong>？要构建索引的原始数据，类型有很多。我把它分为两类，一类是结构化数据，比如，MySQL 中的数据；另一类是非结构化数据，比如搜索引擎中网页。对于非结构化数据，我们一般需要做预处理，提取出查询关键词，对关键词构建索引。</p><p><strong>数据是静态数据还是动态数据</strong>？如果原始数据是一组静态数据，也就是说，不会有数据的增加、删除、更新操作，所以，我们在构建索引的时候，只需要考虑查询效率就可以了。这样，索引的构建就相对简单些。不过，大部分情况下，我们都是对动态数据构建索引，也就是说，我们不仅要考虑到索引的查询效率，在原始数据更新的同时，我们还需要动态地更新索引。支持动态数据集合的索引，设计起来相对也要更加复杂些。</p><p><strong>索引存储在内存还是硬盘</strong>？如果索引存储在内存中，那查询的速度肯定要比存储在磁盘中的高。但是，如果原始数据量很大的情况下，对应的索引可能也会很大。这个时候，因为内存有限，我们可能就不得不将索引存储在磁盘中了。实际上，还有第三种情况，那就是一部分存储在内存，一部分存储在磁盘，这样就可以兼顾内存消耗和查询效率。</p><p><strong>单值查找还是区间查找</strong>？所谓单值查找，也就是根据查询关键词等于某个值的数据。这种查询需求最常见。所谓区间查找，就是查找关键词处于某个区间值的所有数据。你可以类比 MySQL 数据库的查询需求，自己想象一下。实际上，不同的应用场景，查询的需求会多种多样。</p><p><strong>单关键词查找还是多关键词组合查找</strong>？比如，搜索引擎中构建的索引，既要支持一个关键词的查找，比如“数据结构”，也要支持组合关键词查找，比如“数据结构 AND 算法”。对于单关键词的查找，索引构建起来相对简单些。对于多关键词查询来说，要分多种情况。像 MySQL 这种结构化数据的查询需求，我们可以实现针对多个关键词的组合，建立索引；对于像搜索引擎这样的非结构数据的查询需求，我们可以针对单个关键词构建索引，然后通过集合操作，比如求并集、求交集等，计算出多个关键词组合的查询结果。</p><p>实际上，不同的场景，不同的原始数据，对于索引的需求也会千差万别。我这里只列举了一些比较有共性的需求。</p><h3 id="2-非功能性需求"><a href="#2-非功能性需求" class="headerlink" title="2. 非功能性需求"></a>2. 非功能性需求</h3><p>讲完了功能性需求，我们再来看，索引设计的非功能性需求。</p><p><strong>不管是存储在内存中还是磁盘中，索引对存储空间的消耗不能过大</strong>。如果存储在内存中，索引对占用存储空间的限制就会非常苛刻。毕竟内存空间非常有限，一个中间件启动后就占用几个 GB 的内存，开发者显然是无法接受的。如果存储在硬盘中，那索引对占用存储空间的限制，稍微会放宽一些。但是，我们也不能掉以轻心。因为，有时候，索引对存储空间的消耗会超过原始数据。</p><p><strong>在考虑索引查询效率的同时，我们还要考虑索引的维护成本</strong>。索引的目的是提高查询效率，但是，基于动态数据集合构建的索引，我们还要考虑到，索引的维护成本。因为在原始数据动态增删改的同时，我们也需要动态地更新索引。而索引的更新势必会影响到增删改操作的性能。</p><h2 id="构建索引常用的数据结构有哪些？"><a href="#构建索引常用的数据结构有哪些？" class="headerlink" title="构建索引常用的数据结构有哪些？"></a>构建索引常用的数据结构有哪些？</h2><p>我刚刚从很宏观的角度，总结了在索引设计的过程中，需要考虑的一些共性因素。现在，我们就来看，对于不同需求的索引结构，底层一般使用哪种数据结构。</p><p>实际上，常用来构建索引的数据结构，就是我们之前讲过的几种支持动态数据集合的数据结构。比如，散列表、红黑树、跳表、B+ 树。除此之外，位图、布隆过滤器可以作为辅助索引，有序数组可以用来对静态数据构建索引。</p><p>我们知道，<strong>散列表</strong>增删改查操作的性能非常好，时间复杂度是 O(1)。一些键值数据库，比如 Redis、Memcache，就是使用散列表来构建索引的。这类索引，一般都构建在内存中。</p><p><strong>红黑树</strong>作为一种常用的平衡二叉查找树，数据插入、删除、查找的时间复杂度是 O(logn)，也非常适合用来构建内存索引。Ext 文件系统中，对磁盘块的索引，用的就是红黑树。</p><p><strong>B+ 树</strong>比起红黑树来说，更加适合构建存储在磁盘中的索引。B+ 树是一个多叉树，所以，对相同个数的数据构建索引，B+ 树的高度要低于红黑树。当借助索引查询数据的时候，读取 B+ 树索引，需要的磁盘 IO 次数会更少。所以，大部分关系型数据库的索引，比如 MySQL、Oracle，都是用 B+ 树来实现的。</p><p><strong>跳表</strong>也支持快速添加、删除、查找数据。而且，我们通过灵活调整索引结点个数和数据个数之间的比例，可以很好地平衡索引对内存的消耗及其查询效率。Redis 中的有序集合，就是用跳表来构建的。</p><p>除了散列表、红黑树、B+ 树、跳表之外，位图和布隆过滤器这两个数据结构，也可以用于索引中，辅助存储在磁盘中的索引，加速数据查找的效率。我们来看下，具体是怎么做的？</p><p>我们知道，<strong>布隆过滤器</strong>有一定的判错率。但是，我们可以规避它的短处，发挥它的长处。尽管对于判定存在的数据，有可能并不存在，但是对于判定不存在的数据，那肯定就不存在。而且，布隆过滤器还有一个更大的特点，那就是内存占用非常少。我们可以针对数据，构建一个布隆过滤器，并且存储在内存中。当要查询数据的时候，我们可以先通过布隆过滤器，判定是否存在。如果通过布隆过滤器判定数据不存在，那我们就没有必要读取磁盘中的索引了。对于数据不存在的情况，数据查询就更加快速了。</p><p>实际上，有序数组也可以被作为索引。如果数据是静态的，也就是不会有插入、删除、更新操作，那我们可以把数据的关键词（查询用的）抽取出来，组织成有序数组，然后利用二分查找算法来快速查找数据。</p><h2 id="总结引申-7"><a href="#总结引申-7" class="headerlink" title="总结引申"></a>总结引申</h2><p>今天这节算是一节总结课。我从索引这个非常常用的技术方案，给你展示了散列表、红黑树、跳表、位图、布隆过滤器、有序数组这些数据结构的应用场景。学习完这节课之后，不知道你对这些数据结构以及索引，有没有更加清晰的认识呢？</p><p>从这一节内容中，你应该可以看出，架构设计离不开数据结构和算法。要想成长为一个优秀的业务架构师、基础架构师，数据结构和算法的根基一定要打稳。因为，那些看似很惊艳的架构设计思路，实际上，都是来自最常用的数据结构和算法。</p><h2 id="课后思考-7"><a href="#课后思考-7" class="headerlink" title="课后思考"></a>课后思考</h2><p>你知道基础系统、中间件、开源软件等系统中，有哪些用到了索引吗？这些系统的索引是如何实现的呢？</p><p>欢迎留言和我分享，也欢迎点击“请朋友读”，把今天的内容分享给你的好友，和他一起讨论、学习。</p><h1 id="51-并行算法：如何利用并行处理提高算法的执行效率？"><a href="#51-并行算法：如何利用并行处理提高算法的执行效率？" class="headerlink" title="51 | 并行算法：如何利用并行处理提高算法的执行效率？"></a>51 | 并行算法：如何利用并行处理提高算法的执行效率？</h1><p>王争 2019-01-23</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp83j1mu3aj30vq0hs0us.jpg" alt="img"></p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADYAAAABCAYAAACVOl3IAAAAJUlEQVQYV2N89+7df0FBQQYQeP/+PZgGAUJilMpjs4dSM5H1AwBwSSrLZGasMwAAAABJRU5ErkJggg==" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAABCAYAAADeko4lAAAAHUlEQVQYV2N89+7dfwYoEBQUBLPev3/PgItNSC0ADtASy+rFJtUAAAAASUVORK5CYII=" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADoAAAABCAYAAACPBr1GAAAAJ0lEQVQYV2N89+7dfwYoEBQUBLPev3/PQAkbm3mE7KBUHpd7YeYCAE50MMsBeqQ5AAAAAElFTkSuQmCC" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAABCAYAAAAB3PQ6AAAAHUlEQVQYV2N89+7df0FBQQYQeP/+PQMxbLBiIAAAQE0Py6Kq0rkAAAAASUVORK5CYII=" alt="img"></p><p></p><p>00:09</p><p><a href="javascript:;">1.25x<em></em></a></p><p>讲述：冯永吉 大小：9.22M 时长：10:03</p><p>时间复杂度是衡量算法执行效率的一种标准。但是，时间复杂度并不能跟性能划等号。在真实的软件开发中，即便在不降低时间复杂度的情况下，也可以通过一些优化手段，提升代码的执行效率。毕竟，对于实际的软件开发来说，即便是像 10%、20% 这样微小的性能提升，也是非常可观的。</p><p>算法的目的就是为了提高代码执行的效率。那<strong>当算法无法再继续优化的情况下，我们该如何来进一步提高执行效率呢</strong>？我们今天就讲一种非常简单但又非常好用的优化方法，那就是并行计算。今天，我就通过几个例子，给你展示一下，<strong>如何借助并行计算的处理思想对算法进行改造？</strong></p><h2 id="并行排序"><a href="#并行排序" class="headerlink" title="并行排序"></a>并行排序</h2><p>假设我们要给大小为 8GB 的数据进行排序，并且，我们机器的内存可以一次性容纳这么多数据。对于排序来说，最常用的就是时间复杂度为 O(nlogn) 的三种排序算法，归并排序、快速排序、堆排序。从理论上讲，这个排序问题，已经很难再从算法层面优化了。而利用并行的处理思想，我们可以很轻松地将这个给 8GB 数据排序问题的执行效率提高很多倍。具体的实现思路有下面两种。</p><p><strong>第一种是对归并排序并行化处理</strong>。我们可以将这 8GB 的数据划分成 16 个小的数据集合，每个集合包含 500MB 的数据。我们用 16 个线程，并行地对这 16 个 500MB 的数据集合进行排序。这 16 个小集合分别排序完成之后，我们再将这 16 个有序集合合并。</p><p><strong>第二种是对快速排序并行化处理</strong>。我们通过扫描一遍数据，找到数据所处的范围区间。我们把这个区间从小到大划分成 16 个小区间。我们将 8GB 的数据划分到对应的区间中。针对这 16 个小区间的数据，我们启动 16 个线程，并行地进行排序。等到 16 个线程都执行结束之后，得到的数据就是有序数据了。</p><p>对比这两种处理思路，它们利用的都是分治的思想，对数据进行分片，然后并行处理。它们的区别在于，第一种处理思路是，先随意地对数据分片，排序之后再合并。第二种处理思路是，先对数据按照大小划分区间，然后再排序，排完序就不需要再处理了。这个跟归并和快排的区别如出一辙。</p><p>这里我还要多说几句，如果要排序的数据规模不是 8GB，而是 1TB，那问题的重点就不是算法的执行效率了，而是数据的读取效率。因为 1TB 的数据肯定是存在硬盘中，无法一次性读取到内存中，这样在排序的过程中，就会有频繁地磁盘数据的读取和写入。如何减少磁盘的 IO 操作，减少磁盘数据读取和写入的总量，就变成了优化的重点。不过这个不是我们这节要讨论的重点，你可以自己思考下。</p><h2 id="并行查找"><a href="#并行查找" class="headerlink" title="并行查找"></a>并行查找</h2><p>我们知道，散列表是一种非常适合快速查找的数据结构。</p><p>如果我们是给动态数据构建索引，在数据不断加入的时候，散列表的装载因子就会越来越大。为了保证散列表性能不下降，我们就需要对散列表进行动态扩容。对如此大的散列表进行动态扩容，一方面比较耗时，另一方面比较消耗内存。比如，我们给一个 2GB 大小的散列表进行扩容，扩展到原来的 1.5 倍，也就是 3GB 大小。这个时候，实际存储在散列表中的数据只有不到 2GB，所以内存的利用率只有 60%，有 1GB 的内存是空闲的。</p><p>实际上，我们可以将数据随机分割成 k 份（比如 16 份），每份中的数据只有原来的 1/k，然后我们针对这 k 个小数据集合分别构建散列表。这样，散列表的维护成本就变低了。当某个小散列表的装载因子过大的时候，我们可以单独对这个散列表进行扩容，而其他散列表不需要进行扩容。</p><p>还是刚才那个例子，假设现在有 2GB 的数据，我们放到 16 个散列表中，每个散列表中的数据大约是 150MB。当某个散列表需要扩容的时候，我们只需要额外增加 150*0.5=75MB 的内存（假设还是扩容到原来的 1.5 倍）。无论从扩容的执行效率还是内存的利用率上，这种多个小散列表的处理方法，都要比大散列表高效。</p><p>当我们要查找某个数据的时候，我们只需要通过 16 个线程，并行地在这 16 个散列表中查找数据。这样的查找性能，比起一个大散列表的做法，也并不会下降，反倒有可能提高。</p><p>当往散列表中添加数据的时候，我们可以选择将这个新数据放入装载因子最小的那个散列表中，这样也有助于减少散列冲突。</p><h2 id="并行字符串匹配"><a href="#并行字符串匹配" class="headerlink" title="并行字符串匹配"></a>并行字符串匹配</h2><p>我们前面学过，在文本中查找某个关键词这样一个功能，可以通过字符串匹配算法来实现。我们之前学过的字符串匹配算法有 KMP、BM、RK、BF 等。当在一个不是很长的文本中查找关键词的时候，这些字符串匹配算法中的任何一个，都可以表现得非常高效。但是，如果我们处理的是超级大的文本，那处理的时间可能就会变得很长，那有没有办法加快匹配速度呢？</p><p>我们可以把大的文本，分割成 k 个小文本。假设 k 是 16，我们就启动 16 个线程，并行地在这 16 个小文本中查找关键词，这样整个查找的性能就提高了 16 倍。16 倍效率的提升，从理论的角度来说并不多。但是，对于真实的软件开发来说，这显然是一个非常可观的优化。</p><p>不过，这里还有一个细节要处理，那就是原本包含在大文本中的关键词，被一分为二，分割到两个小文本中，这就会导致尽管大文本中包含这个关键词，但在这 16 个小文本中查找不到它。实际上，这个问题也不难解决，我们只需要针对这种特殊情况，做一些特殊处理就可以了。</p><p>我们假设关键词的长度是 m。我们在每个小文本的结尾和开始各取 m 个字符串。前一个小文本的末尾 m 个字符和后一个小文本的开头 m 个字符，组成一个长度是 2m 的字符串。我们再拿关键词，在这个长度为 2m 的字符串中再重新查找一遍，就可以补上刚才的漏洞了。</p><h2 id="并行搜索"><a href="#并行搜索" class="headerlink" title="并行搜索"></a>并行搜索</h2><p>前面我们学习过好几种搜索算法，它们分别是广度优先搜索、深度优先搜索、Dijkstra 最短路径算法、A* 启发式搜索算法。对于广度优先搜索算法，我们也可以将其改造成并行算法。</p><p>广度优先搜索是一种逐层搜索的搜索策略。基于当前这一层顶点，我们可以启动多个线程，并行地搜索下一层的顶点。在代码实现方面，原来广度优先搜索的代码实现，是通过一个队列来记录已经遍历到但还没有扩展的顶点。现在，经过改造之后的并行广度优先搜索算法，我们需要利用两个队列来完成扩展顶点的工作。</p><p>假设这两个队列分别是队列 A 和队列 B。多线程并行处理队列 A 中的顶点，并将扩展得到的顶点存储在队列 B 中。等队列 A 中的顶点都扩展完成之后，队列 A 被清空，我们再并行地扩展队列 B 中的顶点，并将扩展出来的顶点存储在队列 A。这样两个队列循环使用，就可以实现并行广度优先搜索算法。</p><h2 id="总结引申-8"><a href="#总结引申-8" class="headerlink" title="总结引申"></a>总结引申</h2><p>上一节，我们通过实际软件开发中的“索引”这一技术点，回顾了之前学过的一些支持动态数据集合的数据结构。今天，我们又通过“并行算法”这个话题，回顾了之前学过的一些算法。</p><p>今天的内容比较简单，没有太复杂的知识点。我通过一些例子，比如并行排序、查找、搜索、字符串匹配，给你展示了并行处理的实现思路，也就是对数据进行分片，对没有依赖关系的任务，并行地执行。</p><p>并行计算是一个工程上的实现思路，尽管跟算法关系不大，但是，在实际的软件开发中，它确实可以非常巧妙地提高程序的运行效率，是一种非常好用的性能优化手段。</p><p>特别是，当要处理的数据规模达到一定程度之后，我们无法通过继续优化算法，来提高执行效率 的时候，我们就需要在实现的思路上做文章，利用更多的硬件资源，来加快执行的效率。所以，在很多超大规模数据处理中，并行处理的思想，应用非常广泛，比如 MapReduce 实际上就是一种并行计算框架。</p><h2 id="课后思考-8"><a href="#课后思考-8" class="headerlink" title="课后思考"></a>课后思考</h2><p>假设我们有 n 个任务，为了提高执行的效率，我们希望能并行执行任务，但是各个任务之间又有一定的依赖关系，如何根据依赖关系找出可以并行执行的任务？</p><p>欢迎留言和我分享，也欢迎点击“请朋友读”，把今天的内容分享给你的好友，和他一起讨论、学习。</p><h1 id="-1"><a href="#-1" class="headerlink" title="======================================="></a>=======================================</h1><h1 id="实战篇-52-56（5讲）"><a href="#实战篇-52-56（5讲）" class="headerlink" title="实战篇 52-56（5讲）"></a>实战篇 52-56（5讲）</h1><h1 id="52-算法实战（一）：剖析Redis常用数据类型对应的数据结构"><a href="#52-算法实战（一）：剖析Redis常用数据类型对应的数据结构" class="headerlink" title="52 | 算法实战（一）：剖析Redis常用数据类型对应的数据结构"></a>52 | 算法实战（一）：剖析Redis常用数据类型对应的数据结构</h1><p>王争 2019-01-25</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp83tygu57j30vq0hsgn2.jpg" alt="img"></p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADYAAAABCAYAAACVOl3IAAAAJUlEQVQYV2N89+7df0FBQQYQeP/+PZgGAUJilMpjs4dSM5H1AwBwSSrLZGasMwAAAABJRU5ErkJggg==" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAABCAYAAADeko4lAAAAHUlEQVQYV2N89+7dfwYoEBQUBLPev3/PgItNSC0ADtASy+rFJtUAAAAASUVORK5CYII=" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADoAAAABCAYAAACPBr1GAAAAJ0lEQVQYV2N89+7dfwYoEBQUBLPev3/PQAkbm3mE7KBUHpd7YeYCAE50MMsBeqQ5AAAAAElFTkSuQmCC" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAABCAYAAAAB3PQ6AAAAHUlEQVQYV2N89+7df0FBQQYQeP/+PQMxbLBiIAAAQE0Py6Kq0rkAAAAASUVORK5CYII=" alt="img"></p><p></p><p>00:19</p><p><a href="javascript:;">1.25x<em></em></a></p><p>讲述：冯永吉 大小：11.29M 时长：12:19</p><p>到此为止，专栏前三部分我们全部讲完了。从今天开始，我们就正式进入实战篇的部分。这部分我主要通过一些开源项目、经典系统，真枪实弹地教你，如何将数据结构和算法应用到项目中。所以这部分的内容，更多的是知识点的回顾，相对于基础篇、高级篇的内容，其实这部分会更加容易看懂。</p><p>不过，我希望你不要只是看懂就完了。你要多举一反三地思考，自己接触过的开源项目、基础框架、中间件中，都用过哪些数据结构和算法。你也可以想一想，在自己做的项目中，有哪些可以用学过的数据结构和算法进一步优化。这样的学习效果才会更好。</p><p>好了，今天我就带你一块儿看下，<strong>经典数据库 Redis 中的常用数据类型，底层都是用哪种数据结构实现的？</strong></p><h2 id="Redis-数据库介绍"><a href="#Redis-数据库介绍" class="headerlink" title="Redis 数据库介绍"></a>Redis 数据库介绍</h2><p>Redis 是一种键值（Key-Value）数据库。相对于关系型数据库（比如 MySQL），Redis 也被叫作<strong>非关系型数据库</strong>。</p><p>像 MySQL 这样的关系型数据库，表的结构比较复杂，会包含很多字段，可以通过 SQL 语句，来实现非常复杂的查询需求。而 Redis 中只包含“键”和“值”两部分，只能通过“键”来查询“值”。正是因为这样简单的存储结构，也让 Redis 的读写效率非常高。</p><p>除此之外，Redis 主要是作为内存数据库来使用，也就是说，数据是存储在内存中的。尽管它经常被用作内存数据库，但是，它也支持将数据存储在硬盘中。这一点，我们后面会介绍。</p><p>Redis 中，键的数据类型是字符串，但是为了丰富数据存储的方式，方便开发者使用，值的数据类型有很多，常用的数据类型有这样几种，它们分别是字符串、列表、字典、集合、有序集合。</p><p>“字符串（string）”这种数据类型非常简单，对应到数据结构里，就是<strong>字符串</strong>。你应该非常熟悉，这里我就不多介绍了。我们着重看下，其他四种比较复杂点的数据类型，看看它们底层都依赖了哪些数据结构。</p><h2 id="列表（list）"><a href="#列表（list）" class="headerlink" title="列表（list）"></a>列表（list）</h2><p>我们先来看列表。列表这种数据类型支持存储一组数据。这种数据类型对应两种实现方法，一种是<strong>压缩列表</strong>（ziplist），另一种是双向循环链表。</p><p>当列表中存储的数据量比较小的时候，列表就可以采用压缩列表的方式实现。具体需要同时满足下面两个条件：</p><p>列表中保存的单个数据（有可能是字符串类型的）小于 64 字节；</p><p>列表中数据个数少于 512 个。</p><p>关于压缩列表，我这里稍微解释一下。它并不是基础数据结构，而是 Redis 自己设计的一种数据存储结构。它有点儿类似数组，通过一片连续的内存空间，来存储数据。不过，它跟数组不同的一点是，它允许存储的数据大小不同。具体的存储结构也非常简单，你可以看我下面画的这幅图。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp83tytehrj30vq0al75q.jpg" alt="img"></p><p>现在，我们来看看，压缩列表中的“压缩”两个字该如何理解？</p><p>听到“压缩”两个字，直观的反应就是节省内存。之所以说这种存储结构节省内存，是相较于数组的存储思路而言的。我们知道，数组要求每个元素的大小相同，如果我们要存储不同长度的字符串，那我们就需要用最大长度的字符串大小作为元素的大小（假设是 20 个字节）。那当我们存储小于 20 个字节长度的字符串的时候，便会浪费部分存储空间。听起来有点儿拗口，我画个图解释一下。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp83tzalluj30vq0bjwfv.jpg" alt="img"></p><p>压缩列表这种存储结构，一方面比较节省内存，另一方面可以支持不同类型数据的存储。而且，因为数据存储在一片连续的内存空间，通过键来获取值为列表类型的数据，读取的效率也非常高。</p><p>当列表中存储的数据量比较大的时候，也就是不能同时满足刚刚讲的两个条件的时候，列表就要通过双向循环链表来实现了。</p><p>在链表里，我们已经讲过双向循环链表这种数据结构了，如果不记得了，你可以先回去复习一下。这里我们着重看一下 Redis 中双向链表的编码实现方式。</p><p>Redis 的这种双向链表的实现方式，非常值得借鉴。它额外定义一个 list 结构体，来组织链表的首、尾指针，还有长度等信息。这样，在使用的时候就会非常方便。</p><p>// 以下是C语言代码，因为Redis是用C语言实现的。</p><p>typedef struct listnode {</p><p>  struct listNode *prev;</p><p>  struct listNode *next;</p><p>  void *value;</p><p>} listNode;</p><p>typedef struct list {</p><p>  listNode *head;</p><p>  listNode *tail;</p><p>  unsigned long len;</p><p>  // ….省略其他定义</p><p>} list;</p><h2 id="字典（hash）"><a href="#字典（hash）" class="headerlink" title="字典（hash）"></a>字典（hash）</h2><p>字典类型用来存储一组数据对。每个数据对又包含键值两部分。字典类型也有两种实现方式。一种是我们刚刚讲到的<strong>压缩列表</strong>，另一种是<strong>散列表</strong>。</p><p>同样，只有当存储的数据量比较小的情况下，Redis 才使用压缩列表来实现字典类型。具体需要满足两个条件：</p><p>字典中保存的键和值的大小都要小于 64 字节；</p><p>字典中键值对的个数要小于 512 个。</p><p>当不能同时满足上面两个条件的时候，Redis 就使用散列表来实现字典类型。Redis 使用MurmurHash2这种运行速度快、随机性好的哈希算法作为哈希函数。对于哈希冲突问题，Redis 使用链表法来解决。除此之外，Redis 还支持散列表的动态扩容、缩容。</p><p>当数据动态增加之后，散列表的装载因子会不停地变大。为了避免散列表性能的下降，当装载因子大于 1 的时候，Redis 会触发扩容，将散列表扩大为原来大小的 2 倍左右（具体值需要计算才能得到，如果感兴趣，你可以去阅读源码）。</p><p>当数据动态减少之后，为了节省内存，当装载因子小于 0.1 的时候，Redis 就会触发缩容，缩小为字典中数据个数的大约 2 倍大小（这个值也是计算得到的，如果感兴趣，你也可以去阅读源码）。</p><p>我们前面讲过，扩容缩容要做大量的数据搬移和哈希值的重新计算，所以比较耗时。针对这个问题，Redis 使用我们在散列表（中）讲的渐进式扩容缩容策略，将数据的搬移分批进行，避免了大量数据一次性搬移导致的服务停顿。</p><h2 id="集合（set）"><a href="#集合（set）" class="headerlink" title="集合（set）"></a>集合（set）</h2><p>集合这种数据类型用来存储一组不重复的数据。这种数据类型也有两种实现方法，一种是基于有序数组，另一种是基于散列表。</p><p>当要存储的数据，同时满足下面这样两个条件的时候，Redis 就采用有序数组，来实现集合这种数据类型。</p><p>存储的数据都是整数；</p><p>存储的数据元素个数不超过 512 个。</p><p>当不能同时满足这两个条件的时候，Redis 就使用散列表来存储集合中的数据。</p><h2 id="有序集合（sortedset）"><a href="#有序集合（sortedset）" class="headerlink" title="有序集合（sortedset）"></a>有序集合（sortedset）</h2><p>有序集合这种数据类型，我们在跳表里已经详细讲过了。它用来存储一组数据，并且每个数据会附带一个得分。通过得分的大小，我们将数据组织成跳表这样的数据结构，以支持快速地按照得分值、得分区间获取数据。</p><p>实际上，跟 Redis 的其他数据类型一样，有序集合也并不仅仅只有跳表这一种实现方式。当数据量比较小的时候，Redis 会用压缩列表来实现有序集合。具体点说就是，使用压缩列表来实现有序集合的前提，有这样两个：</p><p>所有数据的大小都要小于 64 字节；</p><p>元素个数要小于 128 个。</p><h2 id="数据结构持久化"><a href="#数据结构持久化" class="headerlink" title="数据结构持久化"></a>数据结构持久化</h2><p>尽管 Redis 经常会被用作内存数据库，但是，它也支持数据落盘，也就是将内存中的数据存储到硬盘中。这样，当机器断电的时候，存储在 Redis 中的数据也不会丢失。在机器重新启动之后，Redis 只需要再将存储在硬盘中的数据，重新读取到内存，就可以继续工作了。</p><p>刚刚我们讲到，Redis 的数据格式由“键”和“值”两部分组成。而“值”又支持很多数据类型，比如字符串、列表、字典、集合、有序集合。像字典、集合等类型，底层用到了散列表，散列表中有指针的概念，而指针指向的是内存中的存储地址。 那 Redis 是如何将这样一个跟具体内存地址有关的数据结构存储到磁盘中的呢？</p><p>实际上，Redis 遇到的这个问题并不特殊，很多场景中都会遇到。我们把它叫作<strong>数据结构的持久化问题</strong>，或者<strong>对象的持久化问题</strong>。这里的“持久化”，你可以笼统地理解为“存储到磁盘”。</p><p>如何将数据结构持久化到硬盘？我们主要有两种解决思路。</p><p>第一种是清除原有的存储结构，只将数据存储到磁盘中。当我们需要从磁盘还原数据到内存的时候，再重新将数据组织成原来的数据结构。实际上，Redis 采用的就是这种持久化思路。</p><p>不过，这种方式也有一定的弊端。那就是数据从硬盘还原到内存的过程，会耗用比较多的时间。比如，我们现在要将散列表中的数据存储到磁盘。当我们从磁盘中，取出数据重新构建散列表的时候，需要重新计算每个数据的哈希值。如果磁盘中存储的是几 GB 的数据，那重构数据结构的耗时就不可忽视了。</p><p>第二种方式是保留原来的存储格式，将数据按照原有的格式存储在磁盘中。我们拿散列表这样的数据结构来举例。我们可以将散列表的大小、每个数据被散列到的槽的编号等信息，都保存在磁盘中。有了这些信息，我们从磁盘中将数据还原到内存中的时候，就可以避免重新计算哈希值。</p><h2 id="总结引申-9"><a href="#总结引申-9" class="headerlink" title="总结引申"></a>总结引申</h2><p>今天，我们学习了 Redis 中常用数据类型底层依赖的数据结构，总结一下大概有这五种：<strong>压缩列表</strong>（可以看作一种特殊的数组）、<strong>有序数组</strong>、<strong>链表</strong>、<strong>散列表</strong>、<strong>跳表</strong>。实际上，Redis 就是这些常用数据结构的封装。</p><p>你有没有发现，有了数据结构和算法的基础之后，再去阅读 Redis 的源码，理解起来就容易多了？很多原来觉得很深奥的设计思想，是不是就都会觉得顺理成章了呢？</p><p>还是那句话，夯实基础很重要。同样是看源码，有些人只能看个热闹，了解一些皮毛，无法形成自己的知识结构，不能化为己用，过不几天就忘了。而有些人基础很好，不但能知其然，还能知其所以然，从而真正理解作者设计的动机。这样不但能有助于我们理解所用的开源软件，还能为我们自己创新添砖加瓦。</p><h2 id="课后思考-9"><a href="#课后思考-9" class="headerlink" title="课后思考"></a>课后思考</h2><p>你有没有发现，在数据量比较小的情况下，Redis 中的很多数据类型，比如字典、有序集合等，都是通过多种数据结构来实现的，为什么会这样设计呢？用一种固定的数据结构来实现，不是更加简单吗？</p><p>我们讲到数据结构持久化有两种方法。对于二叉查找树这种数据结构，我们如何将它持久化到磁盘中呢？</p><p>欢迎留言和我分享，也欢迎点击“请朋友读”，把今天的内容分享给你的好友，和他一起讨论、学习。</p><h1 id="53-算法实战（二）：剖析搜索引擎背后的经典数据结构和算法"><a href="#53-算法实战（二）：剖析搜索引擎背后的经典数据结构和算法" class="headerlink" title="53 | 算法实战（二）：剖析搜索引擎背后的经典数据结构和算法"></a>53 | 算法实战（二）：剖析搜索引擎背后的经典数据结构和算法</h1><p>王争 2019-01-28</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp83q7zhnvj30vq0hsmy3.jpg" alt="img"></p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADYAAAABCAYAAACVOl3IAAAAJUlEQVQYV2N89+7df0FBQQYQeP/+PZgGAUJilMpjs4dSM5H1AwBwSSrLZGasMwAAAABJRU5ErkJggg==" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAABCAYAAADeko4lAAAAHUlEQVQYV2N89+7dfwYoEBQUBLPev3/PgItNSC0ADtASy+rFJtUAAAAASUVORK5CYII=" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADoAAAABCAYAAACPBr1GAAAAJ0lEQVQYV2N89+7dfwYoEBQUBLPev3/PQAkbm3mE7KBUHpd7YeYCAE50MMsBeqQ5AAAAAElFTkSuQmCC" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAABCAYAAAAB3PQ6AAAAHUlEQVQYV2N89+7df0FBQQYQeP/+PQMxbLBiIAAAQE0Py6Kq0rkAAAAASUVORK5CYII=" alt="img"></p><p></p><p>00:00</p><p><a href="javascript:;">1.25x<em></em></a></p><p>讲述：冯永吉 大小：19.22M 时长：20:59</p><p>像百度、Google 这样的搜索引擎，在我们平时的工作、生活中，几乎天天都会用到。如果我们把搜索引擎也当作一个互联网产品的话，那它跟社交、电商这些类型的产品相比，有一个非常大的区别，那就是，它是一个技术驱动的产品。所谓技术驱动是指，搜索引擎实现起来，技术难度非常大，技术的好坏直接决定了这个产品的核心竞争力。</p><p>在搜索引擎的设计与实现中，会用到大量的算法。有很多针对特定问题的算法，也有很多我们专栏中讲到的基础算法。所以，百度、Google 这样的搜索引擎公司，在面试的时候，会格外重视考察候选人的算法能力。</p><p><strong>今天我就借助搜索引擎，这样一个非常有技术含量的产品，来给你展示一下，数据结构和算法是如何应用在其中的。</strong></p><h2 id="整体系统介绍"><a href="#整体系统介绍" class="headerlink" title="整体系统介绍"></a>整体系统介绍</h2><p>像 Google 这样的大型商用搜索引擎，有成千上万的工程师，十年如一日地对它进行优化改进，所以，它所包含的技术细节非常多。我很难、也没有这个能力，通过一篇文章把所有细节都讲清楚，当然这也不是我们专栏所专注的内容。</p><p>所以，接下来的讲解，我主要给你展示，如何在一台机器上（假设这台机器的内存是 8GB， 硬盘是 100 多 GB），通过少量的代码，实现一个小型搜索引擎。不过，麻雀虽小，五脏俱全。跟大型搜索引擎相比，实现这样一个小型搜索引擎所用到的理论基础是相通的。</p><p>搜索引擎大致可以分为四个部分：<strong>搜集</strong>、<strong>分析</strong>、<strong>索引</strong>、<strong>查询</strong>。其中，搜集，就是我们常说的利用爬虫爬取网页。分析，主要负责网页内容抽取、分词，构建临时索引，计算 PageRank 值这几部分工作。索引，主要负责通过分析阶段得到的临时索引，构建倒排索引。查询，主要负责响应用户的请求，根据倒排索引获取相关网页，计算网页排名，返回查询结果给用户。</p><p>接下来，我就按照网页处理的生命周期，从这四个阶段，依次来给你讲解，一个网页从被爬取到最终展示给用户，这样一个完整的过程。与此同时，我会穿插讲解，这个过程中需要用到哪些数据结构和算法。</p><h2 id="搜集"><a href="#搜集" class="headerlink" title="搜集"></a>搜集</h2><p>现在，互联网越来越发达，网站越来越多，对应的网页也就越来越多。对于搜索引擎来说，它事先并不知道网页都在哪里。打个比方来说就是，我们只知道海里面有很多鱼，但却并不知道鱼在哪里。那搜索引擎是如何爬取网页的呢？</p><p>搜索引擎把整个互联网看作数据结构中的有向图，把每个页面看作一个顶点。如果某个页面中包含另外一个页面的链接，那我们就在两个顶点之间连一条有向边。我们可以利用图的遍历搜索算法，来遍历整个互联网中的网页。</p><p>我们前面介绍过两种图的遍历方法，深度优先和广度优先。搜索引擎采用的是广度优先搜索策略。具体点讲的话，那就是，我们先找一些比较知名的网页（专业的叫法是权重比较高）的链接（比如新浪主页网址、腾讯主页网址等），作为种子网页链接，放入到队列中。爬虫按照广度优先的策略，不停地从队列中取出链接，然后去爬取对应的网页，解析出网页里包含的其他网页链接，再将解析出来的链接添加到队列中。</p><p>基本的原理就是这么简单。但落实到实现层面，还有很多技术细节。我下面借助搜集阶段涉及的几个重要文件，来给你解释一下搜集工程都有哪些关键技术细节。</p><h3 id="1-待爬取网页链接文件：links-bin"><a href="#1-待爬取网页链接文件：links-bin" class="headerlink" title="1. 待爬取网页链接文件：links.bin"></a>1. 待爬取网页链接文件：links.bin</h3><p>在广度优先搜索爬取页面的过程中，爬虫会不停地解析页面链接，将其放到队列中。于是，队列中的链接就会越来越多，可能会多到内存放不下。所以，我们用一个存储在磁盘中的文件（links.bin）来作为广度优先搜索中的队列。爬虫从 links.bin 文件中，取出链接去爬取对应的页面。等爬取到网页之后，将解析出来的链接，直接存储到 links.bin 文件中。</p><p>这样用文件来存储网页链接的方式，还有其他好处。比如，支持断点续爬。也就是说，当机器断电之后，网页链接不会丢失；当机器重启之后，还可以从之前爬取到的位置继续爬取。</p><p>关于如何解析页面获取链接，我额外多说几句。我们可以把整个页面看作一个大的字符串，然后利用字符串匹配算法，在这个大字符串中，搜索<link>这样一个网页标签，然后顺序读取<link></link>之间的字符串。这其实就是网页链接。</p><h3 id="2-网页判重文件：bloom-filter-bin"><a href="#2-网页判重文件：bloom-filter-bin" class="headerlink" title="2. 网页判重文件：bloom_filter.bin"></a>2. 网页判重文件：bloom_filter.bin</h3><p>如何避免重复爬取相同的网页呢？这个问题我们在位图那一节已经讲过了。使用布隆过滤器，我们就可以快速并且非常节省内存地实现网页的判重。</p><p>不过，还是刚刚那个问题，如果我们把布隆过滤器存储在内存中，那机器宕机重启之后，布隆过滤器就被清空了。这样就可能导致大量已经爬取的网页会被重复爬取。</p><p>这个问题该怎么解决呢？我们可以定期地（比如每隔半小时）将布隆过滤器持久化到磁盘中，存储在 bloom_filter.bin 文件中。这样，即便出现机器宕机，也只会丢失布隆过滤器中的部分数据。当机器重启之后，我们就可以重新读取磁盘中的 bloom_filter.bin 文件，将其恢复到内存中。</p><h3 id="3-原始网页存储文件：doc-raw-bin"><a href="#3-原始网页存储文件：doc-raw-bin" class="headerlink" title="3. 原始网页存储文件：doc_raw.bin"></a>3. 原始网页存储文件：doc_raw.bin</h3><p>爬取到网页之后，我们需要将其存储下来，以备后面离线分析、索引之用。那如何存储海量的原始网页数据呢？</p><p>如果我们把每个网页都存储为一个独立的文件，那磁盘中的文件就会非常多，数量可能会有几千万，甚至上亿。常用的文件系统显然不适合存储如此多的文件。所以，我们可以把多个网页存储在一个文件中。每个网页之间，通过一定的标识进行分隔，方便后续读取。具体的存储格式，如下图所示。其中，doc_id 这个字段是网页的编号，我们待会儿再解释。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp83q5m3u0j30vq0hw3zl.jpg" alt="img"></p><p>当然，这样的一个文件也不能太大，因为文件系统对文件的大小也有一定的限制。所以，我们可以设置每个文件的大小不能超过一定的值（比如 1GB）。随着越来越多的网页被添加到文件中，文件的大小就会越来越大，当超过 1GB 的时候，我们就创建一个新的文件，用来存储新爬取的网页。</p><p>假设一台机器的硬盘大小是 100GB 左右，一个网页的平均大小是 64KB。那在一台机器上，我们可以存储 100 万到 200 万左右的网页。假设我们的机器的带宽是 10MB，那下载 100GB 的网页，大约需要 10000 秒。也就是说，爬取 100 多万的网页，也就是只需要花费几小时的时间。</p><h3 id="4-网页链接及其编号的对应文件：doc-id-bin"><a href="#4-网页链接及其编号的对应文件：doc-id-bin" class="headerlink" title="4. 网页链接及其编号的对应文件：doc_id.bin"></a>4. 网页链接及其编号的对应文件：doc_id.bin</h3><p>刚刚我们提到了网页编号这个概念，我现在解释一下。网页编号实际上就是给每个网页分配一个唯一的 ID，方便我们后续对网页进行分析、索引。那如何给网页编号呢？</p><p>我们可以按照网页被爬取的先后顺序，从小到大依次编号。具体是这样做的：我们维护一个中心的计数器，每爬取到一个网页之后，就从计数器中拿一个号码，分配给这个网页，然后计数器加一。在存储网页的同时，我们将网页链接跟编号之间的对应关系，存储在另一个 doc_id.bin 文件中。</p><p><strong>爬虫在爬取网页的过程中，涉及的四个重要的文件，我就介绍完了。其中，links.bin 和 bloom_filter.bin 这两个文件是爬虫自身所用的。另外的两个（doc_raw.bin、doc_id.bin）是作为搜集阶段的成果，供后面的分析、索引、查询用的。</strong></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>网页爬取下来之后，我们需要对网页进行离线分析。分析阶段主要包括两个步骤，第一个是抽取网页文本信息，第二个是分词并创建临时索引。我们逐一来讲解。</p><h3 id="1-抽取网页文本信息"><a href="#1-抽取网页文本信息" class="headerlink" title="1. 抽取网页文本信息"></a>1. 抽取网页文本信息</h3><p>网页是半结构化数据，里面夹杂着各种标签、JavaScript 代码、CSS 样式。对于搜索引擎来说，它只关心网页中的文本信息，也就是，网页显示在浏览器中时，能被用户肉眼看到的那部分信息。我们如何从半结构化的网页中，抽取出搜索引擎关系的文本信息呢？</p><p>我们之所以把网页叫作半结构化数据，是因为它本身是按照一定的规则来书写的。这个规则就是 <strong>HTML 语法规范</strong>。我们依靠 HTML 标签来抽取网页中的文本信息。这个抽取的过程，大体可以分为两步。</p><p>第一步是去掉 JavaScript 代码、CSS 格式以及下拉框中的内容（因为下拉框在用户不操作的情况下，也是看不到的）。也就是<style></style>，<script></script>，<option></option>这三组标签之间的内容。我们可以利用 AC 自动机这种多模式串匹配算法，在网页这个大字符串中，一次性查找<style>, <script>, <option>这三个关键词。当找到某个关键词出现的位置之后，我们只需要依次往后遍历，直到对应结束标签（</style>, </script>, &lt;/option）为止。而这期间遍历到的字符串连带着标签就应该从网页中删除。</p><p>第二步是去掉所有 HTML 标签。这一步也是通过字符串匹配算法来实现的。过程跟第一步类似，我就不重复讲了。</p><h3 id="2-分词并创建临时索引"><a href="#2-分词并创建临时索引" class="headerlink" title="2. 分词并创建临时索引"></a>2. 分词并创建临时索引</h3><p>经过上面的处理之后，我们就从网页中抽取出了我们关心的文本信息。接下来，我们要对文本信息进行分词，并且创建临时索引。</p><p>对于英文网页来说，分词非常简单。我们只需要通过空格、标点符号等分隔符，将每个单词分割开来就可以了。但是，对于中文来说，分词就复杂太多了。我这里介绍一种比较简单的思路，基于字典和规则的分词方法。</p><p>其中，字典也叫词库，里面包含大量常用的词语（我们可以直接从网上下载别人整理好的）。我们借助词库并采用最长匹配规则，来对文本进行分词。所谓最长匹配，也就是匹配尽可能长的词语。我举个例子解释一下。</p><p>比如要分词的文本是“中国人民解放了”，我们词库中有“中国”“中国人”“中国人民”“中国人民解放军”这几个词，那我们就取最长匹配，也就是“中国人民”划为一个词，而不是把“中国”、“中国人”划为一个词。具体到实现层面，我们可以将词库中的单词，构建成 Trie 树结构，然后拿网页文本在 Trie 树中匹配。</p><p>每个网页的文本信息在分词完成之后，我们都得到一组单词列表。我们把单词与网页之间的对应关系，写入到一个临时索引文件中（tmp_Index.bin），这个临时索引文件用来构建倒排索引文件。临时索引文件的格式如下：</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp83q9eu6uj30vq0gkwg5.jpg" alt="img"></p><p>在临时索引文件中，我们存储的是单词编号，也就是图中的 term_id，而非单词本身。这样做的目的主要是为了节省存储的空间。那这些单词的编号是怎么来的呢？</p><p>给单词编号的方式，跟给网页编号类似。我们维护一个计数器，每当从网页文本信息中分割出一个新的单词的时候，我们就从计数器中取一个编号，分配给它，然后计数器加一。</p><p>在这个过程中，我们还需要使用散列表，记录已经编过号的单词。在对网页文本信息分词的过程中，我们拿分割出来的单词，先到散列表中查找，如果找到，那就直接使用已有的编号；如果没有找到，我们再去计数器中拿号码，并且将这个新单词以及编号添加到散列表中。</p><p>当所有的网页处理（分词及写入临时索引）完成之后，我们再将这个单词跟编号之间的对应关系，写入到磁盘文件中，并命名为 term_id.bin。</p><p><strong>经过分析阶段，我们得到了两个重要的文件。它们分别是临时索引文件（tmp_index.bin）和单词编号文件（term_id.bin）。</strong></p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>索引阶段主要负责将分析阶段产生的临时索引，构建成倒排索引。倒排索引（ Inverted index）中记录了每个单词以及包含它的网页列表。文字描述比较难理解，我画了一张倒排索引的结构图，你一看就明白。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp83qk5d5tj30vq0ih0v9.jpg" alt="img"></p><p>我们刚刚讲到，在临时索引文件中，记录的是单词跟每个包含它的文档之间的对应关系。那如何通过临时索引文件，构建出倒排索引文件呢？这是一个非常典型的算法问题，你可以先自己思考一下，再看我下面的讲解。</p><p>解决这个问题的方法有很多。考虑到临时索引文件很大，无法一次性加载到内存中，搜索引擎一般会选择使用<strong>多路归并排序</strong>的方法来实现。</p><p>我们先对临时索引文件，按照单词编号的大小进行排序。因为临时索引很大，所以一般基于内存的排序算法就没法处理这个问题了。我们可以用之前讲到的归并排序的处理思想，将其分割成多个小文件，先对每个小文件独立排序，最后再合并在一起。当然，实际的软件开发中，我们其实可以直接利用 MapReduce 来处理。</p><p>临时索引文件排序完成之后，相同的单词就被排列到了一起。我们只需要顺序地遍历排好序的临时索引文件，就能将每个单词对应的网页编号列表找出来，然后把它们存储在倒排索引文件中。具体的处理过程，我画成了一张图。通过图，你应该更容易理解。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp83qe6tugj30vq0jrgn1.jpg" alt="img"></p><p>除了倒排文件之外，我们还需要一个文件，来记录每个单词编号在倒排索引文件中的偏移位置。我们把这个文件命名为 term_offset.bin。这个文件的作用是，帮助我们快速地查找某个单词编号在倒排索引中存储的位置，进而快速地从倒排索引中读取单词编号对应的网页编号列表。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp83q9vborj30vq0fdta7.jpg" alt="img"></p><p><strong>经过索引阶段的处理，我们得到了两个有价值的文件，它们分别是倒排索引文件（index.bin）和记录单词编号在索引文件中的偏移位置的文件（term_offset.bin）。</strong></p><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p>前面三个阶段的处理，只是为了最后的查询做铺垫。因此，现在我们就要利用之前产生的几个文件，来实现最终的用户搜索功能。</p><p>doc_id.bin：记录网页链接和编号之间的对应关系。</p><p>term_id.bin：记录单词和编号之间的对应关系。</p><p>index.bin：倒排索引文件，记录每个单词编号以及对应包含它的网页编号列表。</p><p>term_offsert.bin：记录每个单词编号在倒排索引文件中的偏移位置。</p><p>这四个文件中，除了倒排索引文件（index.bin）比较大之外，其他的都比较小。为了方便快速查找数据，我们将其他三个文件都加载到内存中，并且组织成散列表这种数据结构。</p><p>当用户在搜索框中，输入某个查询文本的时候，我们先对用户输入的文本进行分词处理。假设分词之后，我们得到 k 个单词。</p><p>我们拿这 k 个单词，去 term_id.bin 对应的散列表中，查找对应的单词编号。经过这个查询之后，我们得到了这 k 个单词对应的单词编号。</p><p>我们拿这 k 个单词编号，去 term_offset.bin 对应的散列表中，查找每个单词编号在倒排索引文件中的偏移位置。经过这个查询之后，我们得到了 k 个偏移位置。</p><p>我们拿这 k 个偏移位置，去倒排索引（index.bin）中，查找 k 个单词对应的包含它的网页编号列表。经过这一步查询之后，我们得到了 k 个网页编号列表。</p><p>我们针对这 k 个网页编号列表，统计每个网页编号出现的次数。具体到实现层面，我们可以借助散列表来进行统计。统计得到的结果，我们按照出现次数的多少，从小到大排序。出现次数越多，说明包含越多的用户查询单词（用户输入的搜索文本，经过分词之后的单词）。</p><p>经过这一系列查询，我们就得到了一组排好序的网页编号。我们拿着网页编号，去 doc_id.bin 文件中查找对应的网页链接，分页显示给用户就可以了。</p><h2 id="总结引申-10"><a href="#总结引申-10" class="headerlink" title="总结引申"></a>总结引申</h2><p>今天，我给你展示了一个小型搜索引擎的设计思路。这只是一个搜索引擎设计的基本原理，有很多优化、细节我们并未涉及，比如计算网页权重的PageRank算法、计算查询结果排名的tf-idf模型等等。</p><p>在讲解的过程中，我们涉及的数据结构和算法有：图、散列表、Trie 树、布隆过滤器、单模式字符串匹配算法、AC 自动机、广度优先遍历、归并排序等。如果对其中哪些内容不清楚，你可以回到对应的章节进行复习。</p><p>最后，如果有时间的话，我强烈建议你，按照我的思路，自己写代码实现一个简单的搜索引擎。这样写出来的，即便只是一个 demo，但对于你深入理解数据结构和算法，也是很有帮助的。</p><h2 id="课后思考-10"><a href="#课后思考-10" class="headerlink" title="课后思考"></a>课后思考</h2><p>图的遍历方法有两种，深度优先和广度优先。我们讲到，搜索引擎中的爬虫是通过广度优先策略来爬取网页的。搜索引擎为什么选择广度优先策略，而不是深度优先策略呢？</p><p>大部分搜索引擎在结果显示的时候，都支持摘要信息和网页快照。实际上，你只需要对我今天讲的设计思路，稍加改造，就可以支持这两项功能。你知道如何改造吗？</p><p>欢迎留言和我分享，也欢迎点击“请朋友读”，把今天的内容分享给你的好友，和他一起讨论、学习。</p><h1 id="54-算法实战（三）：剖析高性能队列Disruptor背后的数据结构和算法"><a href="#54-算法实战（三）：剖析高性能队列Disruptor背后的数据结构和算法" class="headerlink" title="54 | 算法实战（三）：剖析高性能队列Disruptor背后的数据结构和算法"></a>54 | 算法实战（三）：剖析高性能队列Disruptor背后的数据结构和算法</h1><p>王争 2019-01-30</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp83qjrnw9j30vq0hsabq.jpg" alt="img"></p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADYAAAABCAYAAACVOl3IAAAAJUlEQVQYV2N89+7df0FBQQYQeP/+PZgGAUJilMpjs4dSM5H1AwBwSSrLZGasMwAAAABJRU5ErkJggg==" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAABCAYAAADeko4lAAAAHUlEQVQYV2N89+7dfwYoEBQUBLPev3/PgItNSC0ADtASy+rFJtUAAAAASUVORK5CYII=" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADoAAAABCAYAAACPBr1GAAAAJ0lEQVQYV2N89+7dfwYoEBQUBLPev3/PQAkbm3mE7KBUHpd7YeYCAE50MMsBeqQ5AAAAAElFTkSuQmCC" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAABCAYAAAAB3PQ6AAAAHUlEQVQYV2N89+7df0FBQQYQeP/+PQMxbLBiIAAAQE0Py6Kq0rkAAAAASUVORK5CYII=" alt="img"></p><p></p><p>00:00</p><p><a href="javascript:;">1.25x<em></em></a></p><p>讲述：冯永吉 大小：10.67M 时长：11:38</p><p>Disruptor 你是否听说过呢？它是一种内存消息队列。从功能上讲，它其实有点儿类似 Kafka。不过，和 Kafka 不同的是，Disruptor 是线程之间用于消息传递的队列。它在 Apache Storm、Camel、Log4j 2 等很多知名项目中都有广泛应用。</p><p>之所以如此受青睐，主要还是因为它的性能表现非常优秀。它比 Java 中另外一个非常常用的内存消息队列 ArrayBlockingQueue（ABS）的性能，要高一个数量级，可以算得上是最快的内存消息队列了。它还因此获得过 Oracle 官方的 Duke 大奖。</p><p>如此高性能的内存消息队列，在设计和实现上，必然有它独到的地方。今天，我们就来一块儿看下，<strong>Disruptor 是如何做到如此高性能的？其底层依赖了哪些数据结构和算法？</strong></p><h2 id="基于循环队列的“生产者-消费者模型”"><a href="#基于循环队列的“生产者-消费者模型”" class="headerlink" title="基于循环队列的“生产者 - 消费者模型”"></a>基于循环队列的“生产者 - 消费者模型”</h2><p>什么是内存消息队列？对很多业务工程师或者前端工程师来说，可能会比较陌生。不过，如果我说“生产者 - 消费者模型”，估计大部分人都知道。在这个模型中，“生产者”生产数据，并且将数据放到一个中心存储容器中。之后，“消费者”从中心存储容器中，取出数据消费。</p><p>这个模型非常简单、好理解，那你有没有思考过，这里面存储数据的中心存储容器，是用什么样的数据结构来实现的呢？</p><p>实际上，实现中心存储容器最常用的一种数据结构，就是我们在第 9 节讲的队列。队列支持数据的先进先出。正是这个特性，使得数据被消费的顺序性可以得到保证，也就是说，早被生产的数据就会早被消费。</p><p>我们在第 9 节讲过，队列有两种实现思路。一种是基于链表实现的链式队列，另一种是基于数组实现的顺序队列。不同的需求背景下，我们会选择不同的实现方式。</p><p>如果我们要实现一个无界队列，也就是说，队列的大小事先不确定，理论上可以支持无限大。这种情况下，我们适合选用链表来实现队列。因为链表支持快速地动态扩容。如果我们要实现一个有界队列，也就是说，队列的大小事先确定，当队列中数据满了之后，生产者就需要等待。直到消费者消费了数据，队列有空闲位置的时候，生产者才能将数据放入。</p><p>实际上，相较于无界队列，有界队列的应用场景更加广泛。毕竟，我们的机器内存是有限的。而无界队列占用的内存数量是不可控的。对于实际的软件开发来说，这种不可控的因素，就会有潜在的风险。在某些极端情况下，无界队列就有可能因为内存持续增长，而导致 OOM（Out of Memory）错误。</p><p>在第 9 节中，我们还讲过一种特殊的顺序队列，循环队列。我们讲过，非循环的顺序队列在添加、删除数据的工程中，会涉及数据的搬移操作，导致性能变差。而循环队列正好可以解决这个数据搬移的问题，所以，性能更加好。所以，大部分用到顺序队列的场景中，我们都选择用顺序队列中的循环队列。</p><p>实际上，<strong>循环队列这种数据结构，就是我们今天要讲的内存消息队列的雏形。</strong>我借助循环队列，实现了一个最简单的“生产者 - 消费者模型”。对应的代码我贴到这里，你可以看看。</p><p>为了方便你理解，对于生产者和消费者之间操作的同步，我并没有用到线程相关的操作。而是采用了“当队列满了之后，生产者就轮训等待；当队列空了之后，消费者就轮训等待”这样的措施。</p><p>public class Queue {</p><p>  private Long[] data;</p><p>  private int size = 0, head = 0, tail = 0;</p><p>  public Queue(int size) {</p><p>​    this.data = new Long[size];</p><p>​    this.size = size;</p><p>  }</p><p>  public boolean add(Long element) {</p><p>​    if ((tail + 1) % size == head) return false;</p><p>​    data[tail] = element;</p><p>​    tail = (tail + 1) % size;</p><p>​    return true;</p><p>  }</p><p>  public Long poll() {</p><p>​    if (head == tail) return null;</p><p>​    long ret = data[head];</p><p>​    head = (head + 1) % size;</p><p>​    return ret;</p><p>  }</p><p>}</p><p>public class Producer {</p><p>  private Queue queue;</p><p>  public Producer(Queue queue) {</p><p>​    this.queue = queue;</p><p>  }</p><p>  public void produce(Long data) throws InterruptedException {</p><p>​    while (!queue.add(data)) {</p><p>​      Thread.sleep(100);</p><p>​    }</p><p>  }</p><p>}</p><p>public class Consumer {</p><p>  private Queue queue;</p><p>  public Consumer(Queue queue) {</p><p>​    this.queue = queue;</p><p>  }</p><p>  public void comsume() throws InterruptedException {</p><p>​    while (true) {</p><p>​      Long data = queue.poll();</p><p>​      if (data == null) {</p><p>​        Thread.sleep(100);</p><p>​      } else {</p><p>​        // TODO:…消费数据的业务逻辑…</p><p>​      }</p><p>​    }</p><p>  }</p><p>}</p><h2 id="基于加锁的并发“生产者-消费者模型”"><a href="#基于加锁的并发“生产者-消费者模型”" class="headerlink" title="基于加锁的并发“生产者 - 消费者模型”"></a>基于加锁的并发“生产者 - 消费者模型”</h2><p>实际上，刚刚的“生产者 - 消费者模型”实现代码，是不完善的。为什么这么说呢？</p><p>如果我们只有一个生产者往队列中写数据，一个消费者从队列中读取数据，那上面的代码是没有问题的。但是，如果有多个生产者在并发地往队列中写入数据，或者多个消费者并发地从队列中消费数据，那上面的代码就不能正确工作了。我来给你讲讲为什么。</p><p>在多个生产者或者多个消费者并发操作队列的情况下，刚刚的代码主要会有下面两个问题：</p><p>多个生产者写入的数据可能会互相覆盖；</p><p>多个消费者可能会读取重复的数据。</p><p>因为第一个问题和第二个问题产生的原理是类似的。所以，我着重讲解第一个问题是如何产生的以及该如何解决。对于第二个问题，你可以类比我对第一个问题的解决思路自己来想一想。</p><p>两个线程同时往队列中添加数据，也就相当于两个线程同时执行类 Queue 中的 add() 函数。我们假设队列的大小 size 是 10，当前的 tail 指向下标 7，head 指向下标 3，也就是说，队列中还有空闲空间。这个时候，线程 1 调用 add() 函数，往队列中添加一个值为 12 的数据；线程 2 调用 add() 函数，往队列中添加一个值为 15 的数据。在极端情况下，本来是往队列中添加了两个数据（12 和 15），最终可能只有一个数据添加成功，另一个数据会被覆盖。这是为什么呢？</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp83qkl4agj30vq0hzjtc.jpg" alt="img"></p><p>为了方便你查看队列 Queue 中的 add() 函数，我把它从上面的代码中摘录出来，贴在这里。</p><p>public boolean add(Long element) {</p><p>  if ((tail + 1) % size == head) return false;</p><p>  data[tail] = element;</p><p>  tail = (tail + 1) % size;</p><p>  return true;</p><p>}</p><p>从这段代码中，我们可以看到，第 3 行给 data[tail]赋值，然后第 4 行才给 tail 的值加一。赋值和 tail 加一两个操作，并非原子操作。这就会导致这样的情况发生：当线程 1 和线程 2 同时执行 add() 函数的时候，线程 1 先执行完了第 3 行语句，将 data[7]（tail 等于 7）的值设置为 12。在线程 1 还未执行到第 4 行语句之前，也就是还未将 tail 加一之前，线程 2 执行了第 3 行语句，又将 data[7]的值设置为 15，也就是说，那线程 2 插入的数据覆盖了线程 1 插入的数据。原本应该插入两个数据（12 和 15）的，现在只插入了一个数据（15）。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp83qdpg1qj30vq0i7djb.jpg" alt="img"></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp83ql2atzj30vq0iptc7.jpg" alt="img"></p><p>那如何解决这种线程并发往队列中添加数据时，导致的数据覆盖、运行不正确问题呢？</p><p>最简单的处理方法就是给这段代码加锁，同一时间只允许一个线程执行 add() 函数。这就相当于将这段代码的执行，由并行改成了串行，也就不存在我们刚刚说的问题了。</p><p>不过，天下没有免费的午餐，加锁将并行改成串行，必然导致多个生产者同时生产数据的时候，执行效率的下降。当然，我们可以继续优化代码，用CAS（compare and swap，比较并交换）操作等减少加锁的粒度，但是，这不是我们这节的重点。我们直接看 Disruptor 的处理方法。</p><h2 id="基于无锁的并发“生产者-消费者模型”"><a href="#基于无锁的并发“生产者-消费者模型”" class="headerlink" title="基于无锁的并发“生产者 - 消费者模型”"></a>基于无锁的并发“生产者 - 消费者模型”</h2><p>尽管 Disruptor 的源码读起来很复杂，但是基本思想其实非常简单。实际上，它是换了一种队列和“生产者 - 消费者模型”的实现思路。</p><p>之前的实现思路中，队列只支持两个操作，添加数据和读取并移除数据，分别对应代码中的 add() 函数和 poll() 函数，而 Disruptor 采用了另一种实现思路。</p><p>对于生产者来说，它往队列中添加数据之前，先申请可用空闲存储单元，并且是批量地申请连续的 n 个（n≥1）存储单元。当申请到这组连续的存储单元之后，后续往队列中添加元素，就可以不用加锁了，因为这组存储单元是这个线程独享的。不过，从刚刚的描述中，我们可以看出，申请存储单元的过程是需要加锁的。</p><p>对于消费者来说，处理的过程跟生产者是类似的。它先去申请一批连续可读的存储单元（这个申请的过程也是需要加锁的），当申请到这批存储单元之后，后续的读取操作就可以不用加锁了。</p><p>不过，还有一个需要特别注意的地方，那就是，如果生产者 A 申请到了一组连续的存储单元，假设是下标为 3 到 6 的存储单元，生产者 B 紧跟着申请到了下标是 7 到 9 的存储单元，那在 3 到 6 没有完全写入数据之前，7 到 9 的数据是无法读取的。这个也是 Disruptor 实现思路的一个弊端。</p><p>文字描述不好理解，我画了一个图，给你展示一下这个操作过程。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp83q8frqkj30vq0ns0y1.jpg" alt="img"></p><p>实际上，Disruptor 采用的是 RingBuffer 和 AvailableBuffer 这两个结构，来实现我刚刚讲的功能。不过，因为我们主要聚焦在数据结构和算法上，所以我对这两种结构做了简化，但是基本思想是一致的。如果你对 Disruptor 感兴趣，可以去阅读一下它的源码。</p><h2 id="总结引申-11"><a href="#总结引申-11" class="headerlink" title="总结引申"></a>总结引申</h2><p>今天，我讲了如何实现一个高性能的并发队列。这里的“并发”两个字，实际上就是多线程安全的意思。</p><p>常见的内存队列往往采用循环队列来实现。这种实现方法，对于只有一个生产者和一个消费者的场景，已经足够了。但是，当存在多个生产者或者多个消费者的时候，单纯的循环队列的实现方式，就无法正确工作了。</p><p>这主要是因为，多个生产者在同时往队列中写入数据的时候，在某些情况下，会存在数据覆盖的问题。而多个消费者同时消费数据，在某些情况下，会存在消费重复数据的问题。</p><p>针对这个问题，最简单、暴力的解决方法就是，对写入和读取过程加锁。这种处理方法，相当于将原来可以并行执行的操作，强制串行执行，相应地就会导致操作性能的下降。</p><p>为了在保证逻辑正确的前提下，尽可能地提高队列在并发情况下的性能，Disruptor 采用了“两阶段写入”的方法。在写入数据之前，先加锁申请批量的空闲存储单元，之后往队列中写入数据的操作就不需要加锁了，写入的性能因此就提高了。Disruptor 对消费过程的改造，跟对生产过程的改造是类似的。它先加锁申请批量的可读取的存储单元，之后从队列中读取数据的操作也就不需要加锁了，读取的性能因此也就提高了。</p><p>你可能会觉得这个优化思路非常简单。实际上，不管架构设计还是产品设计，往往越简单的设计思路，越能更好地解决问题。正所谓“大道至简”，就是这个意思。</p><h2 id="课后思考-11"><a href="#课后思考-11" class="headerlink" title="课后思考"></a>课后思考</h2><p>为了提高存储性能，我们往往通过分库分表的方式设计数据库表。假设我们有 8 张表用来存储用户信息。这个时候，每张用户表中的 ID 字段就不能通过自增的方式来产生了。因为这样的话，就会导致不同表之间的用户 ID 值重复。</p><p>为了解决这个问题，我们需要实现一个 ID 生成器，可以为所有的用户表生成唯一的 ID 号。那现在问题是，如何设计一个高性能、支持并发的、能够生成全局唯一 ID 的 ID 生成器呢？</p><p>欢迎留言和我分享，也欢迎点击“请朋友读”，把今天的内容分享给你的好友，和他一起讨论、学习。</p><h1 id="55-算法实战（四）：剖析微服务接口鉴权限流背后的数据结构和算法"><a href="#55-算法实战（四）：剖析微服务接口鉴权限流背后的数据结构和算法" class="headerlink" title="55 | 算法实战（四）：剖析微服务接口鉴权限流背后的数据结构和算法"></a>55 | 算法实战（四）：剖析微服务接口鉴权限流背后的数据结构和算法</h1><p>王争 2019-02-01</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp83qc78w3j30vq0hsdgu.jpg" alt="img"></p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADYAAAABCAYAAACVOl3IAAAAJUlEQVQYV2N89+7df0FBQQYQeP/+PZgGAUJilMpjs4dSM5H1AwBwSSrLZGasMwAAAABJRU5ErkJggg==" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAABCAYAAADeko4lAAAAHUlEQVQYV2N89+7dfwYoEBQUBLPev3/PgItNSC0ADtASy+rFJtUAAAAASUVORK5CYII=" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADoAAAABCAYAAACPBr1GAAAAJ0lEQVQYV2N89+7dfwYoEBQUBLPev3/PQAkbm3mE7KBUHpd7YeYCAE50MMsBeqQ5AAAAAElFTkSuQmCC" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAABCAYAAAAB3PQ6AAAAHUlEQVQYV2N89+7df0FBQQYQeP/+PQMxbLBiIAAAQE0Py6Kq0rkAAAAASUVORK5CYII=" alt="img"></p><p></p><p>00:00</p><p><a href="javascript:;">1.25x<em></em></a></p><p>讲述：冯永吉 大小：13.42M 时长：14:38</p><p>微服务是最近几年才兴起的概念。简单点讲，就是把复杂的大应用，解耦拆分成几个小的应用。这样做的好处有很多。比如，这样有利于团队组织架构的拆分，毕竟团队越大协作的难度越大；再比如，每个应用都可以独立运维，独立扩容，独立上线，各个应用之间互不影响。不用像原来那样，一个小功能上线，整个大应用都要重新发布。</p><p>不过，有利就有弊。大应用拆分成微服务之后，服务之间的调用关系变得更复杂，平台的整体复杂熵升高，出错的概率、debug 问题的难度都高了好几个数量级。所以，为了解决这些问题，服务治理便成了微服务的一个技术重点。</p><p>所谓服务治理，简单点讲，就是管理微服务，保证平台整体正常、平稳地运行。服务治理涉及的内容比较多，比如鉴权、限流、降级、熔断、监控告警等等。这些服务治理功能的实现，底层依赖大量的数据结构和算法。今天，我就拿其中的鉴权和限流这两个功能，来带你看看，它们的实现过程中都要用到哪些数据结构和算法。</p><h2 id="鉴权背景介绍"><a href="#鉴权背景介绍" class="headerlink" title="鉴权背景介绍"></a>鉴权背景介绍</h2><p>以防你之前可能对微服务没有太多了解，所以我对鉴权的背景做了简化。</p><p>假设我们有一个微服务叫用户服务（User Service）。它提供很多用户相关的接口，比如获取用户信息、注册、登录等，给公司内部的其他应用使用。但是，并不是公司内部所有应用，都可以访问这个用户服务，也并不是每个有访问权限的应用，都可以访问用户服务的所有接口。</p><p>我举了一个例子给你讲解一下，你可以看我画的这幅图。这里面，只有 A、B、C、D 四个应用可以访问用户服务，并且，每个应用只能访问用户服务的部分接口。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp83qi5fahj30vq0j0dhg.jpg" alt="img"></p><p>要实现接口鉴权功能，我们需要事先将应用对接口的访问权限规则设置好。当某个应用访问其中一个接口的时候，我们就可以拿应用的请求 URL，在规则中进行匹配。如果匹配成功，就说明允许访问；如果没有可以匹配的规则，那就说明这个应用没有这个接口的访问权限，我们就拒绝服务。</p><h2 id="如何实现快速鉴权？"><a href="#如何实现快速鉴权？" class="headerlink" title="如何实现快速鉴权？"></a>如何实现快速鉴权？</h2><p>接口的格式有很多，有类似 Dubbo 这样的 RPC 接口，也有类似 Spring Cloud 这样的 HTTP 接口。不同接口的鉴权实现方式是类似的，我这里主要拿 HTTP 接口给你讲解。</p><p>鉴权的原理比较简单、好理解。那具体到实现层面，我们该用什么数据结构来存储规则呢？用户请求 URL 在规则中快速匹配，又该用什么样的算法呢？</p><p>实际上，不同的规则和匹配模式，对应的数据结构和匹配算法也是不一样的。所以，关于这个问题，我继续细化为三个更加详细的需求给你讲解。</p><h3 id="1-如何实现精确匹配规则？"><a href="#1-如何实现精确匹配规则？" class="headerlink" title="1. 如何实现精确匹配规则？"></a>1. 如何实现精确匹配规则？</h3><p>我们先来看最简单的一种匹配模式。只有当请求 URL 跟规则中配置的某个接口精确匹配时，这个请求才会被接受、处理。为了方便你理解，我举了一个例子，你可以看一下。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp83qabiztj30vq0nstbz.jpg" alt="img"></p><p>不同的应用对应不同的规则集合。我们可以采用散列表来存储这种对应关系。我这里着重讲下，每个应用对应的规则集合，该如何存储和匹配。</p><p>针对这种匹配模式，我们可以将每个应用对应的权限规则，存储在一个字符串数组中。当用户请求到来时，我们拿用户的请求 URL，在这个字符串数组中逐一匹配，匹配的算法就是我们之前学过的字符串匹配算法（比如 KMP、BM、BF 等）。</p><p>规则不会经常变动，所以，为了加快匹配速度，我们可以按照字符串的大小给规则排序，把它组织成有序数组这种数据结构。当要查找某个 URL 能否匹配其中某条规则的时候，我们可以采用二分查找算法，在有序数组中进行匹配。</p><p>而二分查找算法的时间复杂度是 O(logn)（n 表示规则的个数），这比起时间复杂度是 O(n) 的顺序遍历快了很多。对于规则中接口长度比较长，并且鉴权功能调用量非常大的情况，这种优化方法带来的性能提升还是非常可观的 。</p><h3 id="2-如何实现前缀匹配规则？"><a href="#2-如何实现前缀匹配规则？" class="headerlink" title="2. 如何实现前缀匹配规则？"></a>2. 如何实现前缀匹配规则？</h3><p>我们再来看一种稍微复杂的匹配模式。只要某条规则可以匹配请求 URL 的前缀，我们就说这条规则能够跟这个请求 URL 匹配。同样，为了方便你理解这种匹配模式，我还是举一个例子说明一下。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp83qej52aj30vq0kz0ws.jpg" alt="img"></p><p>不同的应用对应不同的规则集合。我们采用散列表来存储这种对应关系。我着重讲一下，每个应用的规则集合，最适合用什么样的数据结构来存储。</p><p>在Trie 树那节，我们讲到，Trie 树非常适合用来做前缀匹配。所以，针对这个需求，我们可以将每个用户的规则集合，组织成 Trie 树这种数据结构。</p><p>不过，Trie 树中的每个节点不是存储单个字符，而是存储接口被“/”分割之后的子目录（比如“/user/name”被分割为“user”“name”两个子目录）。因为规则并不会经常变动，所以，在 Trie 树中，我们可以把每个节点的子节点们，组织成有序数组这种数据结构。在匹配的过程中，我们可以利用二分查找算法，决定从一个节点应该跳到哪一个子节点。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp83q8y6q9j30vq0ep0v8.jpg" alt="img"></p><h3 id="3-如何实现模糊匹配规则？"><a href="#3-如何实现模糊匹配规则？" class="headerlink" title="3. 如何实现模糊匹配规则？"></a>3. 如何实现模糊匹配规则？</h3><p>如果我们的规则更加复杂，规则中包含通配符，比如“*<em>”表示匹配任意多个子目录，“</em>”表示匹配任意一个子目录。只要用户请求 URL 可以跟某条规则模糊匹配，我们就说这条规则适用于这个请求。为了方便你理解，我举一个例子来解释一下。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp83qasmf0j30vq0l00vd.jpg" alt="img"></p><p>不同的应用对应不同的规则集合。我们还是采用散列表来存储这种对应关系。这点我们刚才讲过了，这里不再重复说了。我们着重看下，每个用户对应的规则集合，该用什么数据结构来存储？针对这种包含通配符的模糊匹配，我们又该使用什么算法来实现呢？</p><p>还记得我们在回溯算法那节讲的正则表达式的例子吗？我们可以借助正则表达式那个例子的解决思路，来解决这个问题。我们采用回溯算法，拿请求 URL 跟每条规则逐一进行模糊匹配。如何用回溯算法进行模糊匹配，这部分我就不重复讲了。你如果忘记了，可以回到相应章节复习一下。</p><p>不过，这个解决思路的时间复杂度是非常高的。我们需要拿每一个规则，跟请求 URL 匹配一遍。那有没有办法可以继续优化一下呢？</p><p>实际上，我们可以结合实际情况，挖掘出这样一个隐形的条件，那就是，并不是每条规则都包含通配符，包含通配符的只是少数。于是，我们可以把不包含通配符的规则和包含通配符的规则分开处理。</p><p>我们把不包含通配符的规则，组织成有序数组或者 Trie 树（具体组织成什么结构，视具体的需求而定，是精确匹配，就组织成有序数组，是前缀匹配，就组织成 Trie 树），而这一部分匹配就会非常高效。剩下的是少数包含通配符的规则，我们只要把它们简单存储在一个数组中就可以了。尽管匹配起来会比较慢，但是毕竟这种规则比较少，所以这种方法也是可以接受的。</p><p>当接收到一个请求 URL 之后，我们可以先在不包含通配符的有序数组或者 Trie 树中查找。如果能够匹配，就不需要继续在通配符规则中匹配了；如果不能匹配，就继续在通配符规则中查找匹配。</p><h2 id="限流背景介绍"><a href="#限流背景介绍" class="headerlink" title="限流背景介绍"></a>限流背景介绍</h2><p>讲完了鉴权的实现思路，我们再来看一下限流。</p><p>所谓限流，顾名思义，就是对接口调用的频率进行限制。比如每秒钟不能超过 100 次调用，超过之后，我们就拒绝服务。限流的原理听起来非常简单，但它在很多场景中，发挥着重要的作用。比如在秒杀、大促、双 11、618 等场景中，限流已经成为了保证系统平稳运行的一种标配的技术解决方案。</p><p>按照不同的限流粒度，限流可以分为很多种类型。比如给每个接口限制不同的访问频率，或者给所有接口限制总的访问频率，又或者更细粒度地限制某个应用对某个接口的访问频率等等。</p><p>不同粒度的限流功能的实现思路都差不多，所以，我今天主要针对限制所有接口总的访问频率这样一个限流需求来讲解。其他粒度限流需求的实现思路，你可以自己思考。</p><h2 id="如何实现精准限流？"><a href="#如何实现精准限流？" class="headerlink" title="如何实现精准限流？"></a>如何实现精准限流？</h2><p>最简单的限流算法叫<strong>固定时间窗口限流算法</strong>。这种算法是如何工作的呢？首先我们需要选定一个时间起点，之后每当有接口请求到来，我们就将计数器加一。如果在当前时间窗口内，根据限流规则（比如每秒钟最大允许 100 次访问请求），出现累加访问次数超过限流值的情况时，我们就拒绝后续的访问请求。当进入下一个时间窗口之后，计数器就清零重新计数。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp83qf6j0xj30vq0l7go3.jpg" alt="img"></p><p>这种基于固定时间窗口的限流算法的缺点是，限流策略过于粗略，无法应对两个时间窗口临界时间内的突发流量。这是怎么回事呢？我举一个例子给你解释一下。</p><p>假设我们的限流规则是，每秒钟不能超过 100 次接口请求。第一个 1s 时间窗口内，100 次接口请求都集中在最后 10ms 内。在第二个 1s 的时间窗口内，100 次接口请求都集中在最开始的 10ms 内。虽然两个时间窗口内流量都符合限流要求（≤100 个请求），但在两个时间窗口临界的 20ms 内，会集中有 200 次接口请求。固定时间窗口限流算法并不能对这种情况做限制，所以，集中在这 20ms 内的 200 次请求就有可能压垮系统。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp83qbt181j30vq0ey75q.jpg" alt="img"></p><p>为了解决这个问题，我们可以对固定时间窗口限流算法稍加改造。我们可以限制任意时间窗口（比如 1s）内，接口请求数都不能超过某个阈值（ 比如 100 次）。因此，相对于固定时间窗口限流算法，这个算法叫<strong>滑动时间窗口限流算法</strong>。</p><p>流量经过滑动时间窗口限流算法整形之后，可以保证任意一个 1s 的时间窗口内，都不会超过最大允许的限流值，从流量曲线上来看会更加平滑。那具体到实现层面，我们该如何来做呢？</p><p>我们假设限流的规则是，在任意 1s 内，接口的请求次数都不能大于 K 次。我们就维护一个大小为 K+1 的循环队列，用来记录 1s 内到来的请求。注意，这里循环队列的大小等于限流次数加一，因为循环队列存储数据时会浪费一个存储单元。</p><p>当有新的请求到来时，我们将与这个新请求的时间间隔超过 1s 的请求，从队列中删除。然后，我们再来看循环队列中是否有空闲位置。如果有，则把新请求存储在队列尾部（tail 指针所指的位置）；如果没有，则说明这 1 秒内的请求次数已经超过了限流值 K，所以这个请求被拒绝服务。</p><p>为了方便你理解，我举一个例子，给你解释一下。在这个例子中，我们假设限流的规则是，任意 1s 内，接口的请求次数都不能大于 6 次。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp83qlmnykj30vq0nsq7m.jpg" alt="img"></p><p>即便滑动时间窗口限流算法可以保证任意时间窗口内，接口请求次数都不会超过最大限流值，但是仍然不能防止，在细时间粒度上访问过于集中的问题。</p><p>比如我刚刚举的那个例子，第一个 1s 的时间窗口内，100 次请求都集中在最后 10ms 中，也就是说，基于时间窗口的限流算法，不管是固定时间窗口还是滑动时间窗口，只能在选定的时间粒度上限流，对选定时间粒度内的更加细粒度的访问频率不做限制。</p><p>实际上，针对这个问题，还有很多更加平滑的限流算法，比如令牌桶算法、漏桶算法等。如果感兴趣，你可以自己去研究一下。</p><h2 id="总结引申-12"><a href="#总结引申-12" class="headerlink" title="总结引申"></a>总结引申</h2><p>今天，我们讲解了跟微服务相关的接口鉴权和限流功能的实现思路。现在，我稍微总结一下。</p><p>关于鉴权，我们讲了三种不同的规则匹配模式。不管是哪种匹配模式，我们都可以用散列表来存储不同应用对应的不同规则集合。对于每个应用的规则集合的存储，三种匹配模式使用不同的数据结构。</p><p>对于第一种精确匹配模式，我们利用有序数组来存储每个应用的规则集合，并且通过二分查找和字符串匹配算法，来匹配请求 URL 与规则。对于第二种前缀匹配模式，我们利用 Trie 树来存储每个应用的规则集合。对于第三种模糊匹配模式，我们采用普通的数组来存储包含通配符的规则，通过回溯算法，来进行请求 URL 与规则的匹配。</p><p>关于限流，我们讲了两种限流算法，第一种是固定时间窗口限流算法，第二种是滑动时间窗口限流算法。对于滑动时间窗口限流算法，我们用了之前学习过的循环队列来实现。比起固定时间窗口限流算法，它对流量的整形效果更好，流量更加平滑。</p><p>从今天的学习中，我们也可以看出，对于基础架构工程师来说，如果不精通数据结构和算法，我们就很难开发出性能卓越的基础架构、中间件。这其实就体现了数据结构和算法的重要性。</p><h2 id="课后思考-12"><a href="#课后思考-12" class="headerlink" title="课后思考"></a>课后思考</h2><p>除了用循环队列来实现滑动时间窗口限流算法之外，我们是否还可以用其他数据结构来实现呢？请对比一下这些数据结构跟循环队列在解决这个问题时的优劣之处。</p><p>分析一下鉴权那部分内容中，前缀匹配算法的时间复杂度和空间复杂度。</p><p>最后，有个消息提前通知你一下。本节是专栏的倒数第二节课了，不知道学到现在，你掌握得怎么样呢？为了帮你复习巩固，做到真正掌握这些知识，我针对专栏涉及的数据结构和算法，精心编制了一套练习题。从正月初一到初七，每天发布一篇。你要做好准备哦！</p><h1 id="56-算法实战（五）：如何用学过的数据结构和算法实现一个短网址系统？"><a href="#56-算法实战（五）：如何用学过的数据结构和算法实现一个短网址系统？" class="headerlink" title="56 | 算法实战（五）：如何用学过的数据结构和算法实现一个短网址系统？"></a>56 | 算法实战（五）：如何用学过的数据结构和算法实现一个短网址系统？</h1><p>王争 2019-02-04</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp83qcvbalj30vq0hst9l.jpg" alt="img"></p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADYAAAABCAYAAACVOl3IAAAAJUlEQVQYV2N89+7df0FBQQYQeP/+PZgGAUJilMpjs4dSM5H1AwBwSSrLZGasMwAAAABJRU5ErkJggg==" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAABCAYAAADeko4lAAAAHUlEQVQYV2N89+7dfwYoEBQUBLPev3/PgItNSC0ADtASy+rFJtUAAAAASUVORK5CYII=" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADoAAAABCAYAAACPBr1GAAAAJ0lEQVQYV2N89+7dfwYoEBQUBLPev3/PQAkbm3mE7KBUHpd7YeYCAE50MMsBeqQ5AAAAAElFTkSuQmCC" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAABCAYAAAAB3PQ6AAAAHUlEQVQYV2N89+7df0FBQQYQeP/+PQMxbLBiIAAAQE0Py6Kq0rkAAAAASUVORK5CYII=" alt="img"></p><p></p><p>00:00</p><p><a href="javascript:;">1.25x<em></em></a></p><p>讲述：冯永吉 大小：13.98M 时长：15:15</p><p>短网址服务你用过吗？如果我们在微博里发布一条带网址的信息，微博会把里面的网址转化成一个更短的网址。我们只要访问这个短网址，就相当于访问原始的网址。比如下面这两个网址，尽管长度不同，但是都可以跳转到我的一个 GitHub 开源项目里。其中，第二个网址就是通过新浪提供的短网址服务生成的。</p><p>原始网址：<a href="https://github.com/wangzheng0822/ratelimiter4j">https://github.com/wangzheng0822/ratelimiter4j</a></p><p>短网址：<a href="http://t.cn/EtR9QEG">http://t.cn/EtR9QEG</a></p><p>从功能上讲，短网址服务其实非常简单，就是把一个长的网址转化成一个短的网址。作为一名软件工程师，你是否思考过，这样一个简单的功能，是如何实现的呢？底层都依赖了哪些数据结构和算法呢？</p><h2 id="短网址服务整体介绍"><a href="#短网址服务整体介绍" class="headerlink" title="短网址服务整体介绍"></a>短网址服务整体介绍</h2><p>刚刚我们讲了，短网址服务的一个核心功能，就是把原始的长网址转化成短网址。除了这个功能之外，短网址服务还有另外一个必不可少的功能。那就是，当用户点击短网址的时候，短网址服务会将浏览器重定向为原始网址。这个过程是如何实现的呢？</p><p>为了方便你理解，我画了一张对比图，你可以看下。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp83q77pb9j30vq0ktq4f.jpg" alt="img"></p><p>从图中我们可以看出，浏览器会先访问短网址服务，通过短网址获取到原始网址，再通过原始网址访问到页面。不过这部分功能并不是我们今天要讲的重点。我们重点来看，如何将长网址转化成短网址？</p><h2 id="如何通过哈希算法生成短网址？"><a href="#如何通过哈希算法生成短网址？" class="headerlink" title="如何通过哈希算法生成短网址？"></a>如何通过哈希算法生成短网址？</h2><p>我们前面学过哈希算法。哈希算法可以将一个不管多长的字符串，转化成一个长度固定的哈希值。我们可以利用哈希算法，来生成短网址。</p><p>前面我们已经提过一些哈希算法了，比如 MD5、SHA 等。但是，实际上，我们并不需要这些复杂的哈希算法。在生成短网址这个问题上，毕竟，我们不需要考虑反向解密的难度，所以我们只需要关心哈希算法的计算速度和冲突概率。</p><p>能够满足这样要求的哈希算法有很多，其中比较著名并且应用广泛的一个哈希算法，那就是MurmurHash 算法。尽管这个哈希算法在 2008 年才被发明出来，但现在它已经广泛应用到 Redis、MemCache、Cassandra、HBase、Lucene 等众多著名的软件中。</p><p>MurmurHash 算法提供了两种长度的哈希值，一种是 32bits，一种是 128bits。为了让最终生成的短网址尽可能短，我们可以选择 32bits 的哈希值。对于开头那个 GitHub 网址，经过 MurmurHash 计算后，得到的哈希值就是 181338494。我们再拼上短网址服务的域名，就变成了最终的短网址 <a href="http://t.cn/181338494%EF%BC%88%E5%85%B6%E4%B8%AD%EF%BC%8Chttp://t.cn">http://t.cn/181338494（其中，http://t.cn</a> 是短网址服务的域名）。</p><h3 id="1-如何让短网址更短？"><a href="#1-如何让短网址更短？" class="headerlink" title="1. 如何让短网址更短？"></a>1. 如何让短网址更短？</h3><p>不过，你可能已经看出来了，通过 MurmurHash 算法得到的短网址还是很长啊，而且跟我们开头那个网址的格式好像也不一样。别着急，我们只需要稍微改变一个哈希值的表示方法，就可以轻松把短网址变得更短些。</p><p>我们可以将 10 进制的哈希值，转化成更高进制的哈希值，这样哈希值就变短了。我们知道，16 进制中，我们用 A～F，来表示 10～15。在网址 URL 中，常用的合法字符有 0～9、a～z、A～Z 这样 62 个字符。为了让哈希值表示起来尽可能短，我们可以将 10 进制的哈希值转化成 62 进制。具体的计算过程，我写在这里了。最终用 62 进制表示的短网址就是<a href="http://t.cn/cgSqq%E3%80%82">http://t.cn/cgSqq。</a></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp83qffvjtj30vq0k43zx.jpg" alt="img"></p><h3 id="2-如何解决哈希冲突问题？"><a href="#2-如何解决哈希冲突问题？" class="headerlink" title="2. 如何解决哈希冲突问题？"></a>2. 如何解决哈希冲突问题？</h3><p>不过，我们前面讲过，哈希算法无法避免的一个问题，就是哈希冲突。尽管 MurmurHash 算法，冲突的概率非常低。但是，一旦冲突，就会导致两个原始网址被转化成同一个短网址。当用户访问短网址的时候，我们就无从判断，用户想要访问的是哪一个原始网址了。这个问题该如何解决呢？</p><p>一般情况下，我们会保存短网址跟原始网址之间的对应关系，以便后续用户在访问短网址的时候，可以根据对应关系，查找到原始网址。存储这种对应关系的方式有很多，比如我们自己设计存储系统或者利用现成的数据库。前面我们讲到的数据库有 MySQL、Redis。我们就拿 MySQL 来举例。假设短网址与原始网址之间的对应关系，就存储在 MySQL 数据库中。</p><p>当有一个新的原始网址需要生成短网址的时候，我们先利用 MurmurHash 算法，生成短网址。然后，我们拿这个新生成的短网址，在 MySQL 数据库中查找。</p><p>如果没有找到相同的短网址，这也就表明，这个新生成的短网址没有冲突。于是我们就将这个短网址返回给用户（请求生成短网址的用户），然后将这个短网址与原始网址之间的对应关系，存储到 MySQL 数据库中。</p><p>如果我们在数据库中，找到了相同的短网址，那也并不一定说明就冲突了。我们从数据库中，将这个短网址对应的原始网址也取出来。如果数据库中的原始网址，跟我们现在正在处理的原始网址是一样的，这就说明已经有人请求过这个原始网址的短网址了。我们就可以拿这个短网址直接用。如果数据库中记录的原始网址，跟我们正在处理的原始网址不一样，那就说明哈希算法发生了冲突。不同的原始网址，经过计算，得到的短网址重复了。这个时候，我们该怎么办呢？</p><p>我们可以给原始网址拼接一串特殊字符，比如“[DUPLICATED]”，然后再重新计算哈希值，两次哈希计算都冲突的概率，显然是非常低的。假设出现非常极端的情况，又发生冲突了，我们可以再换一个拼接字符串，比如“[OHMYGOD]”，再计算哈希值。然后把计算得到的哈希值，跟原始网址拼接了特殊字符串之后的文本，一并存储在 MySQL 数据库中。</p><p>当用户访问短网址的时候，短网址服务先通过短网址，在数据库中查找到对应的原始网址。如果原始网址有拼接特殊字符（这个很容易通过字符串匹配算法找到），我们就先将特殊字符去掉，然后再将不包含特殊字符的原始网址返回给浏览器。</p><h3 id="3-如何优化哈希算法生成短网址的性能？"><a href="#3-如何优化哈希算法生成短网址的性能？" class="headerlink" title="3. 如何优化哈希算法生成短网址的性能？"></a>3. 如何优化哈希算法生成短网址的性能？</h3><p>为了判断生成的短网址是否冲突，我们需要拿生成的短网址，在数据库中查找。如果数据库中存储的数据非常多，那查找起来就会非常慢，势必影响短网址服务的性能。那有没有什么优化的手段呢？</p><p>还记得我们之前讲的 MySQL 数据库索引吗？我们可以给短网址字段添加 B+ 树索引。这样通过短网址查询原始网址的速度就提高了很多。实际上，在真实的软件开发中，我们还可以通过一个小技巧，来进一步提高速度。</p><p>在短网址生成的过程中，我们会跟数据库打两次交道，也就是会执行两条 SQL 语句。第一个 SQL 语句是通过短网址查询短网址与原始网址的对应关系，第二个 SQL 语句是将新生成的短网址和原始网址之间的对应关系存储到数据库。</p><p>我们知道，一般情况下，数据库和应用服务（只做计算不存储数据的业务逻辑部分）会部署在两个独立的服务器或者虚拟服务器上。那两条 SQL 语句的执行就需要两次网络通信。这种 IO 通信耗时以及 SQL 语句的执行，才是整个短网址服务的性能瓶颈所在。所以，为了提高性能，我们需要尽量减少 SQL 语句。那又该如何减少 SQL 语句呢？</p><p>我们可以给数据库中的短网址字段，添加一个唯一索引（不只是索引，还要求表中不能有重复的数据）。当有新的原始网址需要生成短网址的时候，我们并不会先拿生成的短网址，在数据库中查找判重，而是直接将生成的短网址与对应的原始网址，尝试存储到数据库中。如果数据库能够将数据正常写入，那说明并没有违反唯一索引，也就是说，这个新生成的短网址并没有冲突。</p><p>当然，如果数据库反馈违反唯一性索引异常，那我们还得重新执行刚刚讲过的“查询、写入”过程，SQL 语句执行的次数不减反增。但是，在大部分情况下，我们把新生成的短网址和对应的原始网址，插入到数据库的时候，并不会出现冲突。所以，大部分情况下，我们只需要执行一条写入的 SQL 语句就可以了。所以，从整体上看，总的 SQL 语句执行次数会大大减少。</p><p>实际上，我们还有另外一个优化 SQL 语句次数的方法，那就是借助布隆过滤器。</p><p>我们把已经生成的短网址，构建成布隆过滤器。我们知道，布隆过滤器是比较节省内存的一种存储结构，长度是 10 亿的布隆过滤器，也只需要 125MB 左右的内存空间。</p><p>当有新的短网址生成的时候，我们先拿这个新生成的短网址，在布隆过滤器中查找。如果查找的结果是不存在，那就说明这个新生成的短网址并没有冲突。这个时候，我们只需要再执行写入短网址和对应原始网页的 SQL 语句就可以了。通过先查询布隆过滤器，总的 SQL 语句的执行次数减少了。</p><p>到此，利用哈希算法来生成短网址的思路，我就讲完了。实际上，这种解决思路已经完全满足需求了，我们已经可以直接用到真实的软件开发中。不过，我们还有另外一种短网址的生成算法，那就是利用自增的 ID 生成器来生成短网址。我们接下来就看一下，这种算法是如何工作的？对于哈希算法生成短网址来说，它又有什么优势和劣势？</p><h2 id="如何通过-ID-生成器生成短网址？"><a href="#如何通过-ID-生成器生成短网址？" class="headerlink" title="如何通过 ID 生成器生成短网址？"></a>如何通过 ID 生成器生成短网址？</h2><p>我们可以维护一个 ID 自增生成器。它可以生成 1、2、3…这样自增的整数 ID。当短网址服务接收到一个原始网址转化成短网址的请求之后，它先从 ID 生成器中取一个号码，然后将其转化成 62 进制表示法，拼接到短网址服务的域名（比如<a href="http://t.cn/%EF%BC%89%E5%90%8E%E9%9D%A2%EF%BC%8C%E5%B0%B1%E5%BD%A2%E6%88%90%E4%BA%86%E6%9C%80%E7%BB%88%E7%9A%84%E7%9F%AD%E7%BD%91%E5%9D%80%E3%80%82%E6%9C%80%E5%90%8E%EF%BC%8C%E6%88%91%E4%BB%AC%E8%BF%98%E6%98%AF%E4%BC%9A%E6%8A%8A%E7%94%9F%E6%88%90%E7%9A%84%E7%9F%AD%E7%BD%91%E5%9D%80%E5%92%8C%E5%AF%B9%E5%BA%94%E7%9A%84%E5%8E%9F%E5%A7%8B%E7%BD%91%E5%9D%80%E5%AD%98%E5%82%A8%E5%88%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E3%80%82">http://t.cn/）后面，就形成了最终的短网址。最后，我们还是会把生成的短网址和对应的原始网址存储到数据库中。</a></p><p>理论非常简单好理解。不过，这里有几个细节问题需要处理。</p><h3 id="1-相同的原始网址可能会对应不同的短网址"><a href="#1-相同的原始网址可能会对应不同的短网址" class="headerlink" title="1. 相同的原始网址可能会对应不同的短网址"></a>1. 相同的原始网址可能会对应不同的短网址</h3><p>每次新来一个原始网址，我们就生成一个新的短网址，这种做法就会导致两个相同的原始网址生成了不同的短网址。这个该如何处理呢？实际上，我们有两种处理思路。</p><p>第一种处理思路是<strong>不做处理</strong>。听起来有点无厘头，我稍微解释下你就明白了。实际上，相同的原始网址对应不同的短网址，这个用户是可以接受的。在大部分短网址的应用场景里，用户只关心短网址能否正确地跳转到原始网址。至于短网址长什么样子，他其实根本就不关心。所以，即便是同一个原始网址，两次生成的短网址不一样，也并不会影响到用户的使用。</p><p>第二种处理思路是<strong>借助哈希算法生成短网址的处理思想，</strong>当要给一个原始网址生成短网址的时候，我们要先拿原始网址在数据库中查找，看数据库中是否已经存在相同的原始网址了。如果数据库中存在，那我们就取出对应的短网址，直接返回给用户。</p><p>不过，这种处理思路有个问题，我们需要给数据库中的短网址和原始网址这两个字段，都添加索引。短网址上加索引是为了提高用户查询短网址对应的原始网页的速度，原始网址上加索引是为了加快刚刚讲的通过原始网址查询短网址的速度。这种解决思路虽然能满足“相同原始网址对应相同短网址”这样一个需求，但是是有代价的：一方面两个索引会占用更多的存储空间，另一方面索引还会导致插入、删除等操作性能的下降。</p><h3 id="2-如何实现高性能的-ID-生成器？"><a href="#2-如何实现高性能的-ID-生成器？" class="headerlink" title="2. 如何实现高性能的 ID 生成器？"></a>2. 如何实现高性能的 ID 生成器？</h3><p>实现 ID 生成器的方法有很多，比如利用数据库自增字段。当然我们也可以自己维护一个计数器，不停地加一加一。但是，一个计数器来应对频繁的短网址生成请求，显然是有点吃力的（因为计数器必须保证生成的 ID 不重复，笼统概念上讲，就是需要加锁）。如何提高 ID 生成器的性能呢？关于这个问题，实际上，有很多解决思路。我这里给出两种思路。</p><p>第一种思路是借助第 54 节中讲的方法。我们可以给 ID 生成器装多个前置发号器。我们批量地给每个前置发号器发送 ID 号码。当我们接受到短网址生成请求的时候，就选择一个前置发号器来取号码。这样通过多个前置发号器，明显提高了并发发号的能力。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp83qiqvb0j30vq0mx0u5.jpg" alt="img"></p><p>第二种思路跟第一种差不多。不过，我们不再使用一个 ID 生成器和多个前置发号器这样的架构，而是，直接实现多个 ID 生成器同时服务。为了保证每个 ID 生成器生成的 ID 不重复。我们要求每个 ID 生成器按照一定的规则，来生成 ID 号码。比如，第一个 ID 生成器只能生成尾号为 0 的，第二个只能生成尾号为 1 的，以此类推。这样通过多个 ID 生成器同时工作，也提高了 ID 生成的效率。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp83q4g9haj30vq0grjsn.jpg" alt="img"></p><h2 id="总结引申-13"><a href="#总结引申-13" class="headerlink" title="总结引申"></a>总结引申</h2><p>今天，我们讲了短网址服务的两种实现方法。我现在来稍微总结一下。</p><p>第一种实现思路是通过哈希算法生成短网址。我们采用计算速度快、冲突概率小的 MurmurHash 算法，并将计算得到的 10 进制数，转化成 62 进制表示法，进一步缩短短网址的长度。对于哈希算法的哈希冲突问题，我们通过给原始网址添加特殊前缀字符，重新计算哈希值的方法来解决。</p><p>第二种实现思路是通过 ID 生成器来生成短网址。我们维护一个 ID 自增的 ID 生成器，给每个原始网址分配一个 ID 号码，并且同样转成 62 进制表示法，拼接到短网址服务的域名之后，形成最终的短网址。</p><h2 id="课后思考-13"><a href="#课后思考-13" class="headerlink" title="课后思考"></a>课后思考</h2><p>如果我们还要额外支持用户自定义短网址功能（http//t.cn/{用户自定部分}），我们又该如何改造刚刚的算法呢?</p><p>我们在讲通过 ID 生成器生成短网址这种实现思路的时候，讲到相同的原始网址可能会对应不同的短网址。针对这个问题，其中一个解决思路就是，不做处理。但是，如果每个请求都生成一个短网址，并且存储在数据库中，那这样会不会撑爆数据库呢？我们又该如何解决呢？</p><p>今天是农历的大年三十，我们专栏的正文到这里也就全部结束了。从明天开始，我会每天发布一篇练习题，内容针对专栏涉及的数据结构和算法。从初一到初七，帮你复习巩固所学知识，拿下数据结构和算法，打响新年进步的第一枪！明天见！</p><p>出自【1】<a name='toc1'></a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="">参考1</a><a href="#toc1">🔼</a></li><li></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;</summary>
    
    
    
    <category term="编程" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>⭐️数据结构与算法</title>
    <link href="http://example.com/2021/04/02/%E3%80%90%E7%BC%96%E7%A8%8B%E3%80%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2021/04/02/%E3%80%90%E7%BC%96%E7%A8%8B%E3%80%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</id>
    <published>2021-04-01T16:00:00.000Z</published>
    <updated>2022-02-03T07:24:34.211Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp84xlwx77j30u01tau05.jpg" alt="img"></p><span id="more"></span><h2 id="学习路线"><a href="#学习路线" class="headerlink" title="学习路线"></a>学习路线</h2><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp85qs1hz5j31400u019a.jpg" alt="img"></p><h3 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h3><ul><li><input disabled="" type="checkbox"> 复杂度分析</li><li><input disabled="" type="checkbox"> 数组</li><li><input disabled="" type="checkbox"> 栈</li><li><input disabled="" type="checkbox"> 队列</li><li><input disabled="" type="checkbox"> 链表</li><li><input disabled="" type="checkbox"> 递归</li><li><input disabled="" type="checkbox"> 排序</li><li><input disabled="" type="checkbox"> 二分查找</li></ul><h3 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h3><ul><li><input disabled="" type="checkbox"> 散列表</li><li><input disabled="" type="checkbox"> 二叉树</li><li><input disabled="" type="checkbox"> 堆</li><li><input disabled="" type="checkbox"> 堆排序</li><li><input disabled="" type="checkbox"> BF/RK字符串匹配</li><li><input disabled="" type="checkbox"> Trie🌲</li><li><input disabled="" type="checkbox"> 图的表示</li><li><input disabled="" type="checkbox"> BFS/DFS</li></ul><h3 id="第三阶段"><a href="#第三阶段" class="headerlink" title="第三阶段"></a>第三阶段</h3><ul><li><input disabled="" type="checkbox"> 四种算法思想：贪心、分治、动态规划、回溯</li><li><input disabled="" type="checkbox"> 跳表</li><li><input disabled="" type="checkbox"> 拓扑排序、Dijkstra算法， A*算法</li><li><input disabled="" type="checkbox"> B+ 树</li><li><input disabled="" type="checkbox"> 位图</li></ul><h3 id="第四阶段"><a href="#第四阶段" class="headerlink" title="第四阶段"></a>第四阶段</h3><ul><li><input disabled="" type="checkbox"> 红黑树</li><li><input disabled="" type="checkbox"> 哈希算法</li><li><input disabled="" type="checkbox"> 哈希算法</li><li><input disabled="" type="checkbox"> BM/KMP/AC自动机</li><li><input disabled="" type="checkbox"> 高级篇、实战篇</li></ul><h2 id="数据结构、算法概念"><a href="#数据结构、算法概念" class="headerlink" title="数据结构、算法概念"></a>数据结构、算法概念</h2><ul><li>什么是数据结构、算法？</li></ul><p>当我们遇到一个实际问题时，首先需要解决两件事：</p><p>（1）如何将数据存储在计算机中；</p><p>（2）用什么方法和策略解决问题。</p><p><strong>前者是数据结构，后者是算法。</strong></p><p><strong>数据</strong>是一切能输入计算机中的信息的总和，<strong>结构</strong>是指数据之间的关系。<strong>数据结构</strong>就是将数据及其之间的关系有效地存储在计算机中并进行基本操作。<strong>算法</strong>是对特定问题求解步骤的一种描述，通俗讲就是解决问题的方法和策略。</p><ul><li>二者关系</li></ul><p>数据结构和算法是相辅相成的。<strong>数据结构是为算法服务的，算法要作用在特定的数据结构之上</strong>。 因此，我们无法孤立数据结构来讲算法，也无法孤立算法来讲数据结构。</p><blockquote><p>比如，因为数组因为具有随机访问的特点，二分查找就需要用数组来存储数据。如果选择链表，则二分查找算法就无法工作了</p></blockquote><p>只有数据结构没有算法，相当于只把数据存储到计算机中，而没有有效的方法去处理，就像一幢只有框架的烂尾楼；若只有算法，没有数据结构，就像沙漠里的海市蜃楼，只不过是空中楼阁罢了。</p><p>在遇到一个实际问题时，要充分利用自己所学的数据结构，将数据及其之间的关系有效地存储在计算机中，然后选择合适的算法策略，并用程序高效地实现。这就是Niklaus Wirth教授所说的：“数据结构+算法＝程序”。</p><ul><li>学习原则</li></ul><p><strong>要学习它的“来历”“自身的特点”“适合解决的问题”以及“实际的应用场景”</strong></p><p><strong>很多时候我们并不是要去死记硬背某个数据结构或者算法，而是要学习它背后的思想和处理技巧，这些东西才是最有价值的</strong>。</p><p>学习数据结构最难的不是理解和掌握原理，而是能灵活地将各种场景和问题抽象成对应的数据结构和算法</p><p>学习数据结构和算法，并不是为了死记硬背几个知识点。我们的目的是建立时间复杂度、空间复杂 度意识，写出高质量的代码，能够设计基础架构，提升编程技能，训练逻辑思维，积攒人生经验，以此 获得工作回报，实现你的价值，完善你的人生。</p><p><strong>掌握了数据结构与算法，你看待问题的深度，解决问题的⻆度就会完全不一样</strong>。因为这样的你，就像是 站在巨人的肩膀上，拿着生存利器行走世界。数据结构与算法，会为你的编程之路，甚至人生之路打开 一扇通往新世界的大⻔。</p><p>学习一个算法可分为三步：</p><blockquote><p>先了解算法本身解决什么问题</p><p>然后学习它的解决策略</p><p>最后了解相似算法之间的联系</p></blockquote><p>参考：<a href="https://www.zhihu.com/question/31082722">用链表的目的是什么？省空间还是省时间？</a>高赞回答：</p><blockquote><p>所以你说“用链表的目的是什么”？</p><p>没目的。</p><p>或者说，目的是让你学会因地制宜的、灵活的组织数据——而且随便你搞出多么奇怪的数据结构、多么复杂的数据组织形式，你都能清晰的给出它（对某个特定任务）的时间/空间复杂度。</p><p>当你能掌握到这个程度时，你完全可以把完全二叉树、满二叉树、红黑树、B树、B+树的定义统统忘掉；但只要有需要，你随时随地都能把你面对的数据整进一个结合了二叉树和队列优点的、不知道该叫什么的数据结构里——从而以最高效率完成你面对的任务。</p><p>换句话说，不要浮在表面、只看到链表二叉树之类东西；而是要深入进去，把它们统统拆散了、揉碎了、忘记了——你要做它们的发明者，不要做它们的使用者。</p><p>你要学的，是最高效率把玩海量数据的思路；你不仅要能因地制宜的给出解决方案、还要有能力给出综合最优的方案（并作出证明）——停留在链表这个表面上，那是连门在哪都没摸到，谈何入门。</p></blockquote><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><blockquote><p>注意递推公式和递归树求递归复杂度</p></blockquote><ul><li>重要性</li></ul><p>复杂度分析究竟有多􏰀要呢?可以这么说，它几乎占了数据结构和算法这⻔课的半壁江山，是数据结构和算法学习的<strong>精髓</strong>。</p><p>数据结构和算法解决的是如何更省、更快地存储和处理数据的问题，因此，我们就需要一个考􏰁效率和 资源消耗的方法，这就是复杂度分析方法。所以，如果你只掌握了数据结构和算法的特点、用法，但是 没有学会复杂度分析，那就相当于只知道操作口诀，而没掌握心法。<strong>只有把心法了然于胸，才能做到无 招胜有招!</strong></p><ul><li>O() 复杂度</li></ul><p>要理解O() 复杂度 的含义，O()并不表示代码真正的执行时间，而是表示<strong>代码执行时间随数据规模增长的变化趋势</strong>，所以大O时间复杂度，也叫渐进时间复杂度，简称时间复杂度。</p><blockquote><p>更详细的参考：<a href="http://bigocheatsheet.com/">Know Thy Complexities!</a>：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqk4qum5uyj31hu0t2npd.jpg" alt="image-20210516115644557"><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqk4v64747j315a0oy4qp.jpg" alt="image-20210516120055333"></p></blockquote><ul><li>时间复杂度量级</li></ul><p>分为：</p><p>1）多项式量级 </p><p>2）非多项式量级（NP, non-deterministic polynomial）</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp979osnjzj313o0ibwqu.jpg" alt="IMG_E5863834E01F-1"></p><ul><li>空间复杂度</li></ul><p>我们说空间复杂度的时候<u>，是指除了原本的数据存储空间外</u>，算法运行还需要<strong>额外的</strong>存储空间。</p><ul><li>最好、最坏和平均情况时间复杂度</li></ul><p>e.g.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// n表示数组array的长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span>[] <span class="built_in">array</span>, <span class="keyword">int</span> n, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> pos = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">array</span>[i] == x) &#123;</span><br><span class="line">       pos = i;</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本例子代码用于在数组中查找变量 x 的位置</p><p>对于最好情况，x 刚好在数组的第一个位置，则复杂度为O(1)；</p><p>最差情况，不在数组中，则复杂度为O(n)；</p><p>当然，这两种情况都比较极端，发生概率不大。考虑**<u>平均时间复杂度</u><strong>，引入</strong>概率分析**。（这里算的是期望）</p><blockquote><p>我们知道，要查找的变量 x，要么在数组里，要么就不在数组里。这两种情况对应的概率统计起来很麻烦，为了方便你理解，我们假设在数组中与不在数组中的概率都为 1/2。另外，要查找的数据出现在 0～n-1 这 n 个位置的概率也是一样的，为 1/n。所以，根据概率乘法法则，要查找的数据出现在 0～n-1 中任意位置的概率就是 1/(2n)。</p><p>因此，前面的推导过程中存在的最大问题就是，没有将各种情况发生的概率考虑进去。如果我们把每种情况发生的概率也考虑进去，那平均时间复杂度的计算过程就变成了这样：</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp982ch8m0j313s0ccnap.jpg" alt="image-20210405220945927"></p></blockquote><p>则最后的平均时间复杂度仍为O(n)</p><ul><li>均摊时间复杂度</li></ul><p>对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间<strong>存在前后连贯的时序关系</strong>，这个时候，我们就可以将这一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。而且，在能够应用均摊时间复杂度分析的场合，<strong>一般均摊时间复杂度就等于最好情况时间复杂度</strong>。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p><strong>数组（Array）是一种线性表数据结构。它用一组连续的内存空间，存储具有相同类型的数据。</strong>最大的特点就是支持随机访问，但插入、删除操作也因此变得比较低效，平均情况时间复杂度为 O(n)。</p><p>这里需要注意以下几点：</p><p>第一是<strong>线性表</strong>（Linear List）。顾名思义，线性表就是数据排成像一条线一样的结构。<strong>每个线性表上的数据最多只有前和后两个方向（前驱和后继）</strong>。其实除了数组，链表、队列、栈等也是线性表结构。【注意这里的‘前后’】</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gyntpi8xx1j312d0u0tbg.jpg" alt="image-20220123191948251"></p><p>与之对应，<strong>有<u><em>’非线性表‘</em></u>，</strong>数据之间并不是简单的前后关系，如树，图等</p><blockquote><p>那么有了线性结构，我们为什么还需要非线性结构呢？ </p><p>答案是为了高效地兼顾静态操作和动态操作，<strong>我们一般使用树去管理需要大量动态操作的数据</strong>。</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gv0utfbp1cj61960jajt702.jpg" alt="image-20211002122911606"></p><ul><li>第二个是连续的内存空间和相同类型的数据—–&gt;<strong>’随机访问‘</strong></li></ul><p>随机访问的公式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[i]_address = base_address + i * data_type_size</span><br></pre></td></tr></table></figure><p>如下，内存块的首地址为 base_address =00, data_type_size=4B</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gynu3bnhnzj310q0880ud.jpg" alt="image-20220123193304934"></p><ul><li>插入</li></ul><p>对于插入，如果数组是有序的， 插入平均复杂度为O(n)【依据概率计算】：（1+2+…+n）/n=O(n)</p><p>但是，如果数组存储的数据并没有任何规律，数组只是当做一个存储数据的集合，复杂度可以降为o(1)，如下：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gyntl88fbkj313c0jcwg1.jpg" alt="image-20220123191537896"></p><p>利用这种处理技巧，在特定场景下，在第 k 个位置插入一个元素的时间复杂度就会降为 O(1)。</p><p>这个处理思想在<strong>快排中也会用到</strong></p><ul><li>删除</li></ul><p>和插入类似，如果删除数组末尾的数据，则最好情况时间复杂度为 O(1)；如果删除开头的数据，则最坏情况时间复杂度为 O(n)；平均情况时间复杂度也为 O(n)。</p><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>链表，不需要一块连续的内存空间，通过“指针”将零散的内存块串联起来使用</p><ul><li>单链表</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqkhexjdpdj31fs0awe24.jpg" alt="image-20210516191501331"></p><p>代码实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 参考：https://jackkuo666.github.io/Data_Structure_with_Python_book/chapter3/section1.html</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        self.data = data</span><br><span class="line">        self.<span class="built_in">next</span>=<span class="literal">None</span></span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleLinkList</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.head = <span class="literal">None</span>   <span class="comment"># 初始化，创建头指针</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;头部插入元素&#x27;&#x27;&#x27;</span></span><br><span class="line">        node = Node(item)</span><br><span class="line">        node.<span class="built_in">next</span> = self.head</span><br><span class="line">        self.head = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;尾部插入&quot;&quot;&quot;</span></span><br><span class="line">        node = Node(item)</span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            self.head = node</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur = self.head</span><br><span class="line">            <span class="keyword">while</span> cur.<span class="built_in">next</span>:  <span class="comment"># 非None</span></span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;判断链表是否为空&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.head <span class="keyword">is</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">travel</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;遍历链表&#x27;&#x27;&#x27;</span></span><br><span class="line">        p = self.head</span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            <span class="built_in">print</span>(p.data)</span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        node = self.head</span><br><span class="line">        nodes = []</span><br><span class="line">        <span class="keyword">while</span> node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            nodes.append(node.data)</span><br><span class="line">            node = node.<span class="built_in">next</span></span><br><span class="line">        nodes.append(<span class="string">&quot;None&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot; -&gt; &quot;</span>.join(nodes)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">llist = SingleLinkList()</span><br><span class="line"><span class="built_in">print</span>(llist)</span><br><span class="line">llist.add(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(llist)</span><br><span class="line">llist.add(<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">llist.add(<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(llist)</span><br><span class="line"></span><br><span class="line">llist = SingleLinkList()</span><br><span class="line"><span class="built_in">print</span>(llist)</span><br><span class="line">llist.append(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(llist)</span><br><span class="line">llist.append(<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">llist.append(<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(llist)</span><br><span class="line"></span><br><span class="line"><span class="literal">None</span></span><br><span class="line">a -&gt; <span class="literal">None</span></span><br><span class="line">c -&gt; b -&gt; a -&gt; <span class="literal">None</span></span><br><span class="line"><span class="literal">None</span></span><br><span class="line">a -&gt; <span class="literal">None</span></span><br><span class="line">a -&gt; b -&gt; c -&gt; <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>注意头插和尾插的输出顺序</p><ul><li>插入、删除</li></ul><p>复杂度均为 O(1)</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqkhhuvnggj31cu0cetpj.jpg" alt="image-20210516191749915"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqkhi1d8r7j31b0098dun.jpg" alt="image-20210516191804109"></p><ul><li>循环链表</li></ul><p>跟单链表相比，区别是尾结点指针指向链表的头结点</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpah2ovka4j30vq0b33zb.jpg" alt="img"></p><p><strong>循环链表</strong>的优点是从链尾到链头比较方便。</p><p>当<strong>要处理的数据具有环型结构特点时，就特别适合采用循环链表</strong>。比如著名的约瑟夫问题。</p><ul><li>双向链表</li></ul><p><a href="https://blog.csdn.net/qq490691606/article/details/49948263">Python 实现双向链表（图解）</a></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqls41wojpj31cu06snbl.jpg" alt="image-20210517221044722"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqltomwamrj313a07ygyn.jpg" alt="image-20210517230508499"></p><ul><li>数组 VS 链表</li></ul><p>正是因为内存存储的区别，它们插入、删除、随机访问操作的时间复杂度正好相反。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gynwo0qrg8j30w00a0js7.jpg" alt="image-20220123210210524"></p><p>链表本身没有大小 的限制，天然地支持动态扩容。</p><p>除此之外，如果你的代码对内存的使用非常苛刻，那数组就更适合你。因为链表中的每个结点都需要消 耗额外的存储空间去存储一份指向下一个结点的指针，所以内存消耗会翻倍。而且，对链表进行频繁的 插入、删除操作，还会导致频繁的内存申请和释放，容易造成内存碎片，如果是 Java 语言，就有可能会 导致频繁的 GC(Garbage Collection，垃圾回收)。</p><p>所以，在我们实际的开发中，针对不同类型的项目，要根据具体情况，权衡究竟是选择数组还是链表。</p><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>队列跟栈一样，也是一种操作受限的线性表数据结构。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gv15cis0thj61cy084t9m02.jpg" alt="image-20211002183322757"></p><ul><li>数组实现</li></ul><p>通过 移动head ,tail 控制入队和出队，当tail 移动到数组最右边，需要数据搬移</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gv1687k03lj610m0c8mys02.jpg" alt="image-20211002190353757"></p><p>如要避免数据搬移，可采用循环队列：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gv16dbb5ivj619a0k20va02.jpg" alt="IMG_CA2CC59959D7-1"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, size=<span class="number">100</span></span>):</span></span><br><span class="line">        self.size = size</span><br><span class="line">        self.queue = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size)]</span><br><span class="line">        self.front = <span class="number">0</span>  <span class="comment"># 队首</span></span><br><span class="line">        self.rear = <span class="number">0</span> <span class="comment"># 队尾</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, element</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.is_filled():</span><br><span class="line">            self.rear =(self.rear+<span class="number">1</span>) % self.size</span><br><span class="line">            self.queue[self.rear] = element</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> IndexError(<span class="string">&#x27;queue is filled&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.is_empty():</span><br><span class="line">            self.front = (self.front+<span class="number">1</span>) % self.size</span><br><span class="line">            <span class="keyword">return</span> self.queue[self.front]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> IndexError(<span class="string">&#x27;queue is empty!!&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;判断队空&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.rear==self.front</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_filled</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;判断队满&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> (self.rear+<span class="number">1</span>) % self.size == self.front</span><br><span class="line">---------------------------------------------</span><br><span class="line"></span><br><span class="line">q = Queue(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    q.push(i)</span><br><span class="line"><span class="built_in">print</span>(q.is_filled())</span><br><span class="line"><span class="built_in">print</span>(q.pop())</span><br><span class="line">q.push(<span class="number">4</span>)</span><br></pre></td></tr></table></figure><ul><li>链表实现</li></ul><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpblrprhh3j312k0i847d.jpg" alt="IMG_A95FD02F8B3D-1"></p><ul><li>阻塞队列</li></ul><p>阻塞 队列其实是在队列的基础上增加了阻塞操作。就是在队列为空的时候，从队头取数据会 被阻塞。因为此时还没有数据可取，直到队列中有了数据才能返回;如果队列已经满了，那么插入数据 的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpcp7bk14nj31720hatu1.jpg" alt="image-20210408221918674"></p><p>利用阻塞队列可以轻松实现一个<strong>”生产者-消费者模型“</strong></p><p>基于阻塞队列，我们还可以通过协调“生产者”和“消费者”的个数，来提高数据的处理效率</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpcpbogzv3j31dy0g4x4n.jpg" alt="image-20210408222332733"></p><ul><li>并发队列</li></ul><p>在多线程情况下，会有多个线程同时操作队列，这个时候就会存在线程安全问题，那如何实现一个线程安全的队列呢?</p><p>线程安全的队列我们叫作<strong>并发队列</strong>。最简单直接的实现方式是直接在 enqueue()、dequeue() 方法上加 锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或者取操作。实际上，基于数组的循环队 列，利用 CAS 原子操作，可以实现非常高效的并发队列。这也是循环队列比链式队列应用更加广泛的原 因。</p><p>总之，阻塞队列就是入队、出队操作可以阻塞，并发队列就是队列的操作多线程安全</p><ul><li>内置模块</li></ul><p>双端队列</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gv17ma4kggj60yw0d8wgi02.jpg" alt="image-20210304235311165"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="comment"># 创建队列</span></span><br><span class="line">d = collections.deque()</span><br><span class="line"></span><br><span class="line">d.append(<span class="number">1</span>) <span class="comment">#从队尾入队</span></span><br><span class="line">d.popleft() <span class="comment">#从队头出队</span></span><br><span class="line"></span><br><span class="line">d.appendleft(<span class="number">2</span>) <span class="comment">#从队头入队</span></span><br><span class="line">d.pop() <span class="comment">#从队尾出队</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用 <code>deque(maxlen=N)</code> 构造函数会新建一个固定大小的队列。当新的元素加入并且这个队列已满的时候， 最前面的元素会自动pop()。</p><p>可以实现linux tail命令，打印文件的最后几行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tail</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        q = deque(f, n)</span><br><span class="line">        <span class="keyword">return</span> q</span><br><span class="line"><span class="built_in">print</span>(tail(<span class="number">5</span>))</span><br></pre></td></tr></table></figure><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>从栈的操作特性上来看，<strong>栈是一种</strong>“<strong>操作受限</strong>”<strong>的线性表</strong>，只允许在一端插入和删除数据。</p><p>事实上，从功能上来说，数组或链表确实可以替代栈，但你要知道，特定的数据结构是对特定场景的抽象，而且，数组或链表暴露了太多的操作接口，操作上的确灵活自由，但使用时就比较不可控，自然也就更容易出错。</p><p><strong>当某个数据集合只涉及在一端插入和删除数据，并且满足后进先出、先进后出的特性，这时我们就应该 首选</strong>“<strong>栈</strong>”<strong>这种数据结构</strong>。</p><ul><li>应用</li></ul><p>1）函数调用</p><p>图中 显示的是，在执行到 add() 函数时，函数调用栈的情况。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpbkmdba7yj31as0n2qv5.jpg" alt="image-20210407225513243"></p><p>2）表达式求值</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpbkoah3ybj316r0u0kjl.jpg" alt="image-20210407225706163"></p><h2 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h2><p>应用场景：Redis用跳表实现有序集合</p><p>跳表是一种各方面性能都比较优秀的<strong>动态数据结构</strong>，可以支持快速地插入、删除、查找操作，写起来也不复杂，甚至可以替代红黑树(Red-black tree)。</p><blockquote><p>链表+多级索引 = 跳表：</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpksnctla0j31dy0oge81.jpg" alt="image-20210415222252327"></p><ul><li>查询时间复杂度</li></ul><p>假设索引 h 级，最高索引有2个结点。那么整个跳表高度为：log(n)</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpkstbauktj31eq0n8hdt.jpg" alt="image-20210415222838932"></p><p>单层索引最多需要遍历3个结点，所以整体的复杂度为O(log(n))</p><p>此外，插入、删除的复杂度也为O(log(n))</p><ul><li>空间复杂度</li></ul><p>将所有索引的节点数相加得到：</p><p> n/2+n/4+n/8…+8+4+2=n-2。所以，跳表的空间复杂度是 O(n)。</p><ul><li>索引的动态更新</li></ul><p>如果不停地往跳表中插入数据，而不更新索引，极端情况下会退化成单链表，如下：</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpkt0roo8tj310o0ggdzt.jpg" alt="image-20210415223548875"></p><p>作为一种动态数据结构，我们需要某种手段来维护索引与原始链表大小之间的平衡，也就是说，如果链 表中结点多了，索引结点就相应地增加一些，避免复杂度退化，以及查找、插入、删除操作性能下降。</p><p>而跳表是<strong>通过随机函数来维护前面提到的“平衡性”</strong>：</p><p>我们通过一个随机函数，来决定将这个结点插入到哪几级索引中，比如随机函数生成了值 K，那我们就 将这个结点添加到第一级到第 K 级这 K 级索引中。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpkt26cslsj319p0u0npd.jpg" alt="image-20210415223709920"></p><h2 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h2><p>散列表英文名叫’Hash Table‘，又称’哈希表‘</p><p><strong>散列表用的是数组支持下标随机访问数据的特性，所以散列表其实是数组的一种扩展，由数组演化而来</strong>。可以说，没有数组，就没有散列表。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpkusfq4luj315y0pkb29.jpg" alt="image-20210415233700091"></p><p>注意，哈希函数哈希的是key ,因此，在dict中查找某个key是否存在操作的时间复杂度为o（1）；查找某个value是否存在操作的时间复杂度为o（n）</p><ul><li>散列冲突</li></ul><p>1）开放寻址法</p><p>开放寻址法的核心思想是，如果出现了散列冲突，我们就􏰂向后探测空位置，然后将其插入</p><p>2）链表法</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gv2bp3vaxqj61220i276802.jpg" alt="image-20211003185845645"></p><p>参考实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkList</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;链表类&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;节点&quot;&quot;&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, item</span>):</span></span><br><span class="line">            self.item = item</span><br><span class="line">            self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">LinkListIterator</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;迭代器类&quot;&quot;&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, node</span>):</span></span><br><span class="line">            self.node=node</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__next__</span>(<span class="params">self</span>):</span></span><br><span class="line">            <span class="keyword">if</span> self.node:</span><br><span class="line">                cur_node = self.node</span><br><span class="line">                self.node = cur_node.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">return</span> cur_node.item</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">raise</span> StopIteration</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">            <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, iterable=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.head = <span class="literal">None</span></span><br><span class="line">        self.tail = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> iterable:</span><br><span class="line">            self.extend(iterable)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span>(<span class="params">self, obj</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;尾插&quot;&quot;&quot;</span></span><br><span class="line">        s= LinkList.Node(obj)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.head:</span><br><span class="line">            self.head = s</span><br><span class="line">            self.tail = s</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.tail.<span class="built_in">next</span> = s</span><br><span class="line">            self.tail = s</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">extend</span>(<span class="params">self, iterable</span>):</span></span><br><span class="line">        <span class="keyword">for</span> obj <span class="keyword">in</span> iterable:</span><br><span class="line">            self.append(obj)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span>(<span class="params">self, obj</span>):</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> self:</span><br><span class="line">            <span class="keyword">if</span> n==obj:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;使链表类支持迭代&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.LinkListIterator(self.head)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        map(str, self)  --&gt; 转化成str</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&lt;&lt;&quot;</span> + <span class="string">&quot;, &quot;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, self)) + <span class="string">&quot;&gt;&gt;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lk = LinkList([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line"><span class="keyword">for</span> ele <span class="keyword">in</span> lk:</span><br><span class="line">    <span class="built_in">print</span>(ele)</span><br><span class="line"><span class="built_in">print</span>(lk)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HashTable</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    类似于集合的结构</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, size=<span class="number">101</span></span>):</span></span><br><span class="line">        self.size = size</span><br><span class="line">        self.T = [LinkList() <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(self.size)]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hash</span>(<span class="params">self, k</span>):</span></span><br><span class="line">        <span class="keyword">return</span> k % self.size</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self, k</span>):</span></span><br><span class="line">        hash_value = self.<span class="built_in">hash</span>(k)</span><br><span class="line">        <span class="comment"># 要判断重复,先查找</span></span><br><span class="line">        <span class="keyword">if</span> self.find(k):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;重复插入&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.T[hash_value].append(k)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span>(<span class="params">self, k</span>):</span></span><br><span class="line">        i = self.<span class="built_in">hash</span>(k)</span><br><span class="line">        <span class="keyword">return</span> self.T[i].find(k)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ht =HashTable()</span><br><span class="line">ht.insert(<span class="number">0</span>)</span><br><span class="line">ht.insert(<span class="number">1</span>)</span><br><span class="line">ht.insert(<span class="number">3</span>)</span><br><span class="line">ht.insert(<span class="number">102</span>)</span><br><span class="line">ht.insert(<span class="number">0</span>)</span><br><span class="line">ht.insert(<span class="number">508</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;,&#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, ht.T)))</span><br><span class="line"><span class="built_in">print</span>(ht.find(<span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(ht.find(<span class="number">4</span>))</span><br><span class="line">---------------</span><br><span class="line">重复插入</span><br><span class="line">&lt;&lt;<span class="number">0</span>&gt;&gt;,&lt;&lt;<span class="number">1</span>, <span class="number">102</span>&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;<span class="number">3</span>, <span class="number">508</span>&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><blockquote><p>课后题</p></blockquote><ol><li>假设我们有 10 万条 URL 访问日志，如何按照访问次数给 URL 排序？</li></ol><p>遍历 10 万条数据，以 URL 为 key，访问次数为 value，存入散列表，同时记录下访问次数的最大值 K，时间复杂度 O(N)。</p><p>如果 K 不是很大，可以使用桶排序，时间复杂度 O(N)。如果 K 非常大（比如大于 10 万），就使用快速排序，复杂度 O(NlogN)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="string">&#x27;sdfg&#x27;</span>:<span class="number">1</span>, <span class="string">&#x27;zzjk&#x27;</span>:<span class="number">9</span>, <span class="string">&#x27;ooo&#x27;</span>:<span class="number">4</span>, <span class="string">&#x27;ww.s&#x27;</span>:<span class="number">3</span>&#125;</span><br><span class="line"><span class="built_in">sorted</span>(a.items(), key = <span class="keyword">lambda</span> item:item[<span class="number">1</span>])</span><br><span class="line">-----------------------------------</span><br><span class="line">[(<span class="string">&#x27;sdfg&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;ww.s&#x27;</span>, <span class="number">3</span>), (<span class="string">&#x27;ooo&#x27;</span>, <span class="number">4</span>), (<span class="string">&#x27;zzjk&#x27;</span>, <span class="number">9</span>)]</span><br></pre></td></tr></table></figure><ol start="2"><li>有两个字符串数组，每个数组大约有 10 万条字符串，如何快速找出两个数组中相同的字符串？</li></ol><p>以第一个字符串数组构建散列表，key 为字符串，value 为出现次数。再遍历第二个字符串数组，以字符串为 key 在散列表中查找，如果 value 大于零，说明存在相同字符串。时间复杂度 O(N)。</p><ul><li>如何设计工业级的散列表</li></ul><p><strong>主要考虑：如何设计散列函数，如何根据装载因子动态扩容，以及如何选择散列冲突解决方法：</strong></p><p>关于散列函数的设计，我们要尽可能让散列后的值随机且均匀分布，这样会尽可能地减少散列冲突，即便冲突之后，分配到每个槽内的数据也比较均匀。除此之外，散列函数的设计也不能太复杂，太复杂就 会太耗时间，也会影响散列表的性能。</p><p>关于散列冲突解决方法的选择，我对比了开放寻址法和链表法两种方法的优劣和适应的场景。大部分情 况下，链表法更加普适。而且，我们还可以通过将链表法中的链表改造成其他动态查找数据结构，比如 红黑树，来避免散列表时间复杂度退化成 O(n)，抵御散列碰撞攻击。但是，对于小规模数据、装载因子 不高的散列表，比较适合用开放寻址法。</p><p>对于动态散列表来说，不管我们如何设计散列函数，选择什么样的散列冲突解决方法。随着数据的不断 增加，散列表总会出现装载因子过高的情况。这个时候，我们就需要启动动态扩容。</p><ul><li>散列表和链表的组合使用</li></ul><blockquote><p>案例：LRU缓存淘汰算法</p></blockquote><p>单链表实现的复杂度为O(n)</p><p>借助散列表，实现复杂度O(1):</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gprrdtw0puj318c0rinpd.jpg" alt="image-20210421225756369"></p><ul><li>哈希算法</li></ul><p>哈希算法的定义和原理非常简单，基本上一句话就可以概括了。将任意⻓度的二进制值串映射为固定⻓ 度的二进制值串，这个映射的规则就是<strong>哈希算法</strong>，而通过原始数据映射之后得到的二进制值串就是<strong>哈希值</strong>。</p><p>但是，要想设计一个优秀的哈希算法并不容易，需要满足的几点要求:</p><p>1）从哈希值不能反向推导出原始数据(所以哈希算法也叫单向哈希算法);</p><p>2)对输入数据非常敏感，哪怕原始数据只修改了一个 Bit，最后得到的哈希值也大不相同; </p><p>3)散列冲突的概率要很小，对于不同的原始数据，哈希值相同的概率非常小; </p><p>4)哈希算法的执行效率要尽􏰃高效，针对较⻓的文本，也能快速地计算出哈希值。</p><p><strong>根据’鸽巢原理‘，哈希算法无法做到零冲突。</strong></p><blockquote><p>我们知道，哈希算法产生的哈希值的⻓度是固定且有限的。比如前面举的 MD5 的例子，哈希值是固定 的 128 位二进制串，能表示的数据是有限的，最多能表示 2^128 个数据，而我们要哈希的数据是无穷的。基于鸽巢原理，如果我们对 2^128+1 个数据求哈希值，就必然会存在哈希值相同的情况</p></blockquote><p>一些应用：</p><p>1）<strong>安全加密</strong></p><p><strong>MD5</strong>(MD5 Message-Digest Algorithm，MD5 消息摘要算法)；</p><p><strong>SHA</strong>(Secure Hash Algorithm，安全散列算法)</p><p>除了这两个之外，当然还有很多其他加密算法，比如 DES(Data Encryption Standard，数据加密标 准)、AES(Advanced Encryption Standard，高级加密标准)。</p><p>2）<strong>分布式系统中应用</strong></p><p>负载均衡、数据分片（Mapreduce设计思想）、分布式存储等</p><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p>树其实是一种特殊的<code>图</code>，是一种无环连通图，是一种极大无环图，也是一种极小连通图。</p><p>从另一个角度看，树是一种递归的数据结构</p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>包括树的构建、遍历、删除等</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gprsbh1igpj30ye0hc1ee.jpg" alt="image-20210421233018284"></p><blockquote><p>如果树有 n 个顶点，那么其就有 n - 1 条边，这说明了树的顶点数和边数是同阶的。</p><p>任何一个节点到根节点存在<code>唯一</code>路径，路径的长度为节点所处的深度</p></blockquote><p>实际使用的树有可能会更复杂，比如使用在游戏中的碰撞检测可能会用到四叉树或者八叉树。以及 k 维的树结构 <code>k-d 树</code>等。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gro06z8x5bj306y06mdft.jpg" alt="img"></p><p>二叉树是节点度数不超过二的树，是树的一种特殊子集，有趣的是二叉树这种被限制的树结构却能够表示和实现所有的树</p><ul><li>二叉树构建</li></ul><p>1）链式存储</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gprsjj29roj312w0qwe67.jpg" alt="image-20210421233803644"></p><p>2）基于数组的顺序存储</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gprsnic8hyj312a0liat9.jpg" alt="image-20210421234153502"></p><p>如果<strong>某棵二叉树是一棵完全二叉树，那用数组存储无疑是最节省内存的</strong>一种方式。因为数组的存储方式并不需要像链式存储法那样，要存储额外的左右子节点的指针。这也是为什么完全二叉树会单􏰁拎出来的原因，也是为什么完全二叉树要求最后一层的子节点<strong>都靠左</strong>的原因。</p><ul><li>遍历</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gprtep5idfj31e40j8hdt.jpg" alt="image-20210422000801073"></p><p>时间复杂度O(n)，参考递归时间复杂度分析：f(n)=2*f(n/2)+1,且f(1)=1—-&gt;O(n)</p><p>层序遍历【结合队列】</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gv2l8wn7w2j60k80d60t202.jpg" alt="image-20211004002912647"></p><blockquote><p>层序遍历是广度优先，BFS,需用到队列</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BiTreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        self.data = data</span><br><span class="line">        self.left = <span class="literal">None</span>  <span class="comment"># 左孩子</span></span><br><span class="line">        self.right = <span class="literal">None</span>  <span class="comment"># 右孩子</span></span><br><span class="line"></span><br><span class="line">a =BiTreeNode(<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">b =BiTreeNode(<span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">c =BiTreeNode(<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">d =BiTreeNode(<span class="string">&#x27;D&#x27;</span>)</span><br><span class="line">e =BiTreeNode(<span class="string">&#x27;E&#x27;</span>)</span><br><span class="line">f =BiTreeNode(<span class="string">&#x27;F&#x27;</span>)</span><br><span class="line">g =BiTreeNode(<span class="string">&#x27;G&#x27;</span>)</span><br><span class="line"></span><br><span class="line">e.right= g</span><br><span class="line">e.left = a</span><br><span class="line">a.right = c</span><br><span class="line">c.left=b</span><br><span class="line">c.right=d</span><br><span class="line">g.right=f</span><br><span class="line"></span><br><span class="line">root =e</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(root.left.right.data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 二叉树前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pre_order</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="keyword">if</span> root: <span class="comment"># 非空</span></span><br><span class="line">        pre_order(root.left)</span><br><span class="line">        pre_order(root.right)</span><br><span class="line">        <span class="built_in">print</span>(root.data, end= <span class="string">&quot; &quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">level_order</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;层次遍历&quot;&quot;&quot;</span></span><br><span class="line">    queue = deque()</span><br><span class="line">    queue.append(root)</span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(queue)&gt;<span class="number">0</span>:  <span class="comment">#只要队不空</span></span><br><span class="line">        node = queue.popleft()</span><br><span class="line">        <span class="built_in">print</span>(node.data, end= <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> node.left:</span><br><span class="line">            queue.append(node.left)</span><br><span class="line">        <span class="keyword">if</span> node.right:</span><br><span class="line">            queue.append(node.right)</span><br><span class="line">level_order(root)</span><br></pre></td></tr></table></figure><ul><li>二叉树删除</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BiTreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,data</span>):</span></span><br><span class="line">        self.data = data</span><br><span class="line">        self.lchild= <span class="literal">None</span></span><br><span class="line">        self.rchild =<span class="literal">None</span></span><br><span class="line">        self.parent = <span class="literal">None</span>  <span class="comment"># 删除操作需要用到</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BST</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;二叉搜索树类&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, li=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.root =<span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> li:</span><br><span class="line">            <span class="keyword">for</span> val <span class="keyword">in</span> li:</span><br><span class="line">                self.insert_no_rec(val)</span><br><span class="line">                <span class="comment"># self.root = self.insert(self.root, val)</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self, node, val</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;注意递归形式时候要注意返回&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:  <span class="comment"># 空</span></span><br><span class="line">            node = BiTreeNode(val)</span><br><span class="line">        <span class="keyword">elif</span> val&lt;node.data:</span><br><span class="line">            node.lchild = self.insert(node.lchild, val)</span><br><span class="line">            node.lchild.parent = node</span><br><span class="line">        <span class="keyword">elif</span> val&gt;node.data:</span><br><span class="line">            node.rchild = self.insert(node.rchild, val)</span><br><span class="line">            node.rchild.parent= node</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert_no_rec</span>(<span class="params">self, val</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;非递归插入&quot;&quot;&quot;</span></span><br><span class="line">        p =self.root</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p:  <span class="comment"># 空树</span></span><br><span class="line">            self.root = BiTreeNode(val)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> val &lt;p.data: <span class="comment"># 插左子树</span></span><br><span class="line">                <span class="keyword">if</span> p.lchild:</span><br><span class="line">                    p = p.lchild</span><br><span class="line">                <span class="keyword">else</span>:  <span class="comment"># 左子树不存在</span></span><br><span class="line">                    p.lchild = BiTreeNode(val)</span><br><span class="line">                    p.lchild.parent = p</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">elif</span> val&gt;p.data:</span><br><span class="line">                <span class="keyword">if</span> p.rchild:</span><br><span class="line">                    p = p.rchild</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    p.rchild = BiTreeNode(val)</span><br><span class="line">                    p.rchild.parent=p</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">query</span>(<span class="params">self, node, val</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;递归查找&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> val&lt;node.data:</span><br><span class="line">            self.query(node.lchild)</span><br><span class="line">        <span class="keyword">elif</span> val&gt;node.data:</span><br><span class="line">            self.query(node.rchild)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">query_no_rec</span>(<span class="params">self, val</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;非递归查找&quot;&quot;&quot;</span></span><br><span class="line">        p = self.root</span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            <span class="keyword">if</span> val&gt;p.data:</span><br><span class="line">                p = p.rchild</span><br><span class="line">            <span class="keyword">elif</span> val&lt;p.data:</span><br><span class="line">                p = p.lchild</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> p</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__remove_node_1</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;情况1：node 是叶子节点</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node.parent:  <span class="comment"># 是根</span></span><br><span class="line">            self.root = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">elif</span> node.parent.lchild ==node:  <span class="comment"># node 是它父亲的左孩子</span></span><br><span class="line">            node.parent.lchild=<span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            node.parent.rchild = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__remove_node21</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;情况2：node只有一个左孩子&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node.parent:  <span class="comment"># 是根节点</span></span><br><span class="line">            self.root = node.lchild</span><br><span class="line">            node.lchild.parent =<span class="literal">None</span></span><br><span class="line">        <span class="keyword">elif</span> node == node.parent.lchild: <span class="comment"># 左孩子</span></span><br><span class="line">            node.parent.lchild = node.lchild</span><br><span class="line">            node.lchild.parent = node.parent</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            node.parent.rchild = node.lchid</span><br><span class="line">            node.lchild.parent = node.parent</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__remove_node22</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;情况2：node只有一个右孩子&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node.parent:  <span class="comment"># 判断根节点</span></span><br><span class="line">            self.root = node.rchild</span><br><span class="line">            node.rchild.parent =<span class="literal">None</span></span><br><span class="line">        <span class="keyword">elif</span> node == node.parent.lchild: <span class="comment"># node 是左孩子</span></span><br><span class="line">            node.parent.lchild = node.rchild</span><br><span class="line">            node.rchild.parent = node.parent</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            node.parent.rchild = node.rchild</span><br><span class="line">            node.rchild.parent = node.parent</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">self, val</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.root: <span class="comment"># 不是空树</span></span><br><span class="line">            node = self.query_no_rec(val)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:  <span class="comment"># node 不存在</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node.lchild <span class="keyword">and</span> <span class="keyword">not</span> node.rchild: <span class="comment"># 1.叶子节点</span></span><br><span class="line">                self.__remove_node_1(node)</span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> node.rchild:  <span class="comment"># 2.1 只有一个左孩子</span></span><br><span class="line">                self.__remove_node21(node)</span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> node.lchild:  <span class="comment"># 2.2 只有一个右孩子</span></span><br><span class="line">                self.__remove_node22(node)</span><br><span class="line">            <span class="keyword">else</span>:  <span class="comment"># 3. 两个孩子都有</span></span><br><span class="line">                min_node = node.rchild</span><br><span class="line">                <span class="keyword">while</span> min_node.lchild:  <span class="comment"># 查找右孩子的最小值</span></span><br><span class="line">                    min_node = min_node.lchild</span><br><span class="line">                node.data = min_node.data</span><br><span class="line">                <span class="comment"># 删除 min_node，只存在两种情况：</span></span><br><span class="line">                <span class="comment"># 1) 是叶子节点</span></span><br><span class="line">                <span class="comment"># 2）只有右孩子</span></span><br><span class="line">                <span class="keyword">if</span> min_node.rchild:</span><br><span class="line">                    self.__remove_node22(min_node)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    self.__remove_node_1(min_node)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 二叉树后序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post_order</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> root:  <span class="comment"># 非空</span></span><br><span class="line">            self.post_order(root.lchild)</span><br><span class="line">            self.post_order(root.rchild)</span><br><span class="line">            <span class="built_in">print</span>(root.data, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pre_order</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> root:  <span class="comment"># 非空</span></span><br><span class="line">            <span class="built_in">print</span>(root.data, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">            self.pre_order(root.lchild)</span><br><span class="line">            self.pre_order(root.rchild)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">in_order</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;中序遍历&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            self.in_order(root.lchild)</span><br><span class="line">            <span class="built_in">print</span>(root.data, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">            self.in_order(root.rchild)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">li = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1000</span>))</span><br><span class="line">random.shuffle(li)</span><br><span class="line"></span><br><span class="line">tree= BST([<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">7</span>])</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;中序遍历：&#x27;</span>)</span><br><span class="line">tree.in_order(tree.root)</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line">tree.delete(<span class="number">4</span>)</span><br><span class="line">tree.in_order(tree.root)</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line">tree.delete(<span class="number">8</span>)</span><br><span class="line">tree.in_order(tree.root)</span><br></pre></td></tr></table></figure><p>中序遍历：<br>1 2 3 4 5 6 7 8 9<br>1 2 3 5 6 7 8 9<br>1 2 3 5 6 7 9 </p><h3 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h3><p><strong>二叉查找树要求，在树中的任意一个节点，其左子树中的每个节 点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值。</strong></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqh6wj75snj31a80em4fd.jpg" alt="image-20210422233911033"></p><p><strong>中序遍历二叉查找树，可以输出有 序的数据序列，时间复杂度是</strong> O(n)<strong>，非常高效</strong>。因此，二叉查找树也叫作二叉排序树。</p><blockquote><p>代码</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BiTreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,data</span>):</span></span><br><span class="line">        self.data = data</span><br><span class="line">        self.lchild= <span class="literal">None</span></span><br><span class="line">        self.rchild =<span class="literal">None</span></span><br><span class="line">        self.parent = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BST</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;二叉搜索树类&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, li=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.root =<span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> li:</span><br><span class="line">            <span class="keyword">for</span> val <span class="keyword">in</span> li:</span><br><span class="line">                self.insert_no_rec(val)</span><br><span class="line">                <span class="comment"># self.root = self.insert(self.root, val)</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self, node, val</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;注意递归形式时候要注意返回&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:  <span class="comment"># 空</span></span><br><span class="line">            node = BiTreeNode(val)</span><br><span class="line">        <span class="keyword">elif</span> val&lt;node.data:</span><br><span class="line">            node.lchild = self.insert(node.lchild, val)</span><br><span class="line">            node.lchild.parent = node</span><br><span class="line">        <span class="keyword">elif</span> val&gt;node.data:</span><br><span class="line">            node.rchild = self.insert(node.rchild, val)</span><br><span class="line">            node.rchild.parent= node</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert_no_rec</span>(<span class="params">self, val</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;非递归插入&quot;&quot;&quot;</span></span><br><span class="line">        p =self.root</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p:  <span class="comment"># 空树</span></span><br><span class="line">            self.root = BiTreeNode(val)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> val &lt;p.data: <span class="comment"># 插左子树</span></span><br><span class="line">                <span class="keyword">if</span> p.lchild:</span><br><span class="line">                    p = p.lchild</span><br><span class="line">                <span class="keyword">else</span>:  <span class="comment"># 左子树不存在</span></span><br><span class="line">                    p.lchild = BiTreeNode(val)</span><br><span class="line">                    p.lchild.parent = p</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">elif</span> val&gt;p.data:</span><br><span class="line">                <span class="keyword">if</span> p.rchild:</span><br><span class="line">                    p = p.rchild</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    p.rchild = BiTreeNode(val)</span><br><span class="line">                    p.rchild.parent=p</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 二叉树后序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post_order</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> root:  <span class="comment"># 非空</span></span><br><span class="line">            self.post_order(root.lchild)</span><br><span class="line">            self.post_order(root.rchild)</span><br><span class="line">            <span class="built_in">print</span>(root.data, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pre_order</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> root:  <span class="comment"># 非空</span></span><br><span class="line">            <span class="built_in">print</span>(root.data, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">            self.pre_order(root.lchild)</span><br><span class="line">            self.pre_order(root.rchild)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">in_order</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;中序遍历&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            self.in_order(root.lchild)</span><br><span class="line">            <span class="built_in">print</span>(root.data, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">            self.in_order(root.rchild)</span><br><span class="line"></span><br><span class="line">li = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1000</span>))</span><br><span class="line">random.shuffle(li)</span><br><span class="line"></span><br><span class="line">tree= BST([<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>])</span><br><span class="line"><span class="comment"># tree= BST(li)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;前序遍历：&#x27;</span>)</span><br><span class="line">tree.pre_order(tree.root)</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;中序遍历：&#x27;</span>)</span><br><span class="line">tree.in_order(tree.root)</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;后续遍历：&#x27;</span>)</span><br><span class="line">tree.post_order(tree.root)</span><br></pre></td></tr></table></figure><p>前序遍历：<br>4 2 1 3 6 5 7 9 8<br>中序遍历：<br>1 2 3 4 5 6 7 8 9<br>后续遍历：<br>1 3 2 5 8 9 7 6 4 </p><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p>为了避免复杂度的退化，引入<strong>平衡</strong>二叉查找树，红黑树就是其中的一种</p><p>在 1972 年由鲁道夫·贝尔发明，被称为”对称二叉 B 树”，它现代的名字源于 Leo J. Guibas 和 Robert Sedgewick 于 1978 年写的一篇论文。红黑树的结构复杂，但它的操作有着良好的最坏情况运行时间，并且在实践中高效：它可以在 O(logn) 时间内完成查找，插入和删除，这里的 n 是树中元素的数目</p><h3 id="B-树"><a href="#B-树" class="headerlink" title="B 树"></a>B 树</h3><p>数据库使用</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gv3ccp46mcj61500icwgk02.jpg" alt="image-20211004160702092"></p><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>堆其实是一种优先级队列，在很多语言都有对应的内置数据结构</p><p><code>需要满足下面两个条件</code>：</p><p>1.堆是一个完全二叉树;</p><p>2.堆中每一个节点的值都必须大于等于(或小于等于)其子树中每个节点的值。</p><p>由于堆是完全二叉树，所以用数组来存储会非常省空间，且单纯通过数组下标就可定位左右子节点和父节点</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1guzv2zvv9nj616o0hm42002.jpg" alt="IMG_9CBB656E4D45-1"></p><ul><li>堆排序</li></ul><p><code>sift</code> 函数处理的问题:</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvf86vmhhyj60xw0h4myl02.jpg" alt="image-20211014224948980"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sift</span>(<span class="params">li, low, high</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    向下调整实现</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param li: 列表</span></span><br><span class="line"><span class="string">    :param low: 堆的根节点位置</span></span><br><span class="line"><span class="string">    :param high: 堆的最后一个元素位置</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    i = low  <span class="comment"># i 指向根节点</span></span><br><span class="line">    j = <span class="number">2</span>*i+<span class="number">1</span>  <span class="comment"># j 开始是左孩子</span></span><br><span class="line">    tmp = li[low]  <span class="comment"># 把堆顶存起来</span></span><br><span class="line">    <span class="keyword">while</span> j&lt;=high: <span class="comment"># 只要j位置有数</span></span><br><span class="line">        <span class="keyword">if</span> j+<span class="number">1</span>&lt;=high <span class="keyword">and</span> li[j+<span class="number">1</span>]&gt;li[j]:  <span class="comment"># 右孩子有，且右孩子大</span></span><br><span class="line">            j = j+<span class="number">1</span>  <span class="comment"># j 换到右孩子分支</span></span><br><span class="line">        <span class="keyword">if</span> li[j]&gt;tmp:</span><br><span class="line">            li[i] = li[j]  <span class="comment"># 上去</span></span><br><span class="line">            i =j  <span class="comment"># 往下看一层</span></span><br><span class="line">            j = <span class="number">2</span>*i +<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            li[i]=tmp  <span class="comment"># 把 tmp 放到某一级领导的位置,此行代码可不写</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    li[i]= tmp  <span class="comment"># i到了叶子节点，需要将tmp 放过去</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heap_sort</span>(<span class="params">li</span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(li)</span><br><span class="line">    <span class="comment"># 建堆，此处为 大根堆</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>((n-<span class="number">2</span>)//<span class="number">2</span>, -<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">        <span class="comment"># i 表示建堆时候需要调整部分的根的下标</span></span><br><span class="line">        sift(li, i, n-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">        <span class="built_in">print</span>(i,<span class="string">&#x27;!!&#x27;</span>)</span><br><span class="line">        <span class="comment"># i指向待处理堆的最后一个元素</span></span><br><span class="line">        li[i], li[<span class="number">0</span>] = li[<span class="number">0</span>], li[i]</span><br><span class="line">        sift(li, <span class="number">0</span>, i-<span class="number">1</span>)  <span class="comment"># i-1 是新的high</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">li = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line">random.shuffle(li)</span><br><span class="line"><span class="built_in">print</span>(li)</span><br><span class="line">heap_sort(li)</span><br><span class="line"><span class="built_in">print</span>(li)</span><br></pre></td></tr></table></figure><p>过程：</p><p>1） 建堆</p><p>从最后一个非叶子节点开始，’农村包围城市‘</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1guzvcji4emj60u00ug7an02.jpg" alt="image-20211001160159720"></p><p>2）堆顶元素取回</p><p>3）向下调整</p><p>4）重复2）</p><blockquote><p>堆排序不稳定，建堆的时间复杂度为􏰰􏰣􏰤􏰲􏶸􏰰􏱘􏱴􏰲􏳋􏳌􏰕􏰖􏰗􏲌 O(n)</p></blockquote><ul><li>堆 的应用</li></ul><p>1）优先级队列</p><p>队列是先进先出，不过优先级队列则是优先级最高的，最先出队</p><p>一个堆，就可以看作一个优先级队列</p><p>后面的许多数据结构，如赫尔曼编码、图的最短路径、最小生成树算法等都要依赖它</p><p>如，合并有序小文件</p><blockquote><p>假设我们有 100 个小文件，每个文件的大小是 100MB，每个文件中存储的都是有序的字符串。我们希望将这些 100 个小文件合并成一个有序的大文件。这里就会用到优先级队列。</p></blockquote><p>通过建立堆(大小为文件个数)，通过不停地 ‘堆顶写入–删除—插入’ 来实现复杂度O(log n)，其中n 表示堆中数据个数</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gr20z3neoij61140t27aq02.jpg" alt="image-20210531232612740"></p><p>2） 求Top K</p><p>需一直维护一个大小为K的小顶堆，复杂度 nlog(K)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sift</span>(<span class="params">li, low, high</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    向下调整实现</span></span><br><span class="line"><span class="string">    小根堆</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param li: 列表</span></span><br><span class="line"><span class="string">    :param low: 堆的根节点位置</span></span><br><span class="line"><span class="string">    :param high: 堆的最后一个元素位置</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    i = low  <span class="comment"># i 指向根节点</span></span><br><span class="line">    j = <span class="number">2</span>*i+<span class="number">1</span>  <span class="comment"># j 开始是左孩子</span></span><br><span class="line">    tmp = li[low]  <span class="comment"># 把堆顶存起来</span></span><br><span class="line">    <span class="keyword">while</span> j&lt;=high: <span class="comment"># 只要j位置有数</span></span><br><span class="line">        <span class="keyword">if</span> j+<span class="number">1</span>&lt;=high <span class="keyword">and</span> li[j+<span class="number">1</span>] &lt; li[j]:  <span class="comment"># 右孩子有，且右孩子小</span></span><br><span class="line">            j = j+<span class="number">1</span>  <span class="comment"># j 换到右孩子分支</span></span><br><span class="line">        <span class="keyword">if</span> li[j]&lt;tmp:</span><br><span class="line">            li[i] = li[j]  <span class="comment"># 上去</span></span><br><span class="line">            i =j  <span class="comment"># 往下看一层</span></span><br><span class="line">            j = <span class="number">2</span>*i +<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            li[i]=tmp  <span class="comment"># 把 tmp 放到某一级领导的位置,此行代码可不写</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    li[i]= tmp  <span class="comment"># i到了叶子节点，需要将tmp 放过去</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">topk</span>(<span class="params">li, k</span>):</span></span><br><span class="line">    heap = li[:k]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>((k-<span class="number">2</span>)//<span class="number">2</span>, -<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">        sift(heap, i, k-<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 比较</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k, <span class="built_in">len</span>(li)):</span><br><span class="line">        <span class="keyword">if</span> li[i]&gt;heap[<span class="number">0</span>]:</span><br><span class="line">            heap[<span class="number">0</span>]= li[i]</span><br><span class="line">            sift(heap,<span class="number">0</span> ,k-<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># k个值堆排序，出数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">        heap[i], heap[<span class="number">0</span>] = heap[<span class="number">0</span>], heap[i]</span><br><span class="line">        sift(heap, <span class="number">0</span>, i-<span class="number">1</span>)  <span class="comment"># i-1 是新的high</span></span><br><span class="line">    <span class="keyword">return</span> heap</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">li = list(range(1000))</span><br><span class="line">random.shuffle(li)</span><br><span class="line">print(li)</span><br><span class="line">topk_li = topk(li,10)</span><br><span class="line">print(topk_li)</span><br><span class="line">[999, 998, 997, 996, 995, 994, 993, 992, 991, 990]</span><br></pre></td></tr></table></figure><ol start="3"><li>有一个10亿搜索关键词的日志文件，如何获取Top10最热门的搜索关键词？</li></ol><p>方法1： MapReduce</p><p>方法2： 单机，可使用内存 1G</p><p>初始方案：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gr34pbvpvwj31580fq0yh.jpg" alt="image-20210601222103242"></p><p>但是，字典占据空间太大，内存不够</p><p>改进：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gr35ejvcjpj31je0lawr8.jpg" alt="image-20210601224517136"></p><h3 id="Trie-树"><a href="#Trie-树" class="headerlink" title="Trie 树"></a>Trie 树</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gro179xlf0j30al06q74c.jpg" alt="img"></p><p>Trie <strong>树的本质，就是利用字符串之间的公共前缀，将重复的前缀合并在一起</strong>。</p><p>Trie 树只是不适合精确匹配查找，这种问题更适合用散列表或者红黑树来解决。Trie 树比较适 合的是查找前缀匹配的字符串，也就是类似开篇问题的那种场景。</p><p>关于 Trie 的应用场景，希望你能记住 8 个字：<strong>一次建树，多次查询</strong>。</p><ul><li>应用</li></ul><p>搜索引擎关键词提示，底层最基本的原理就是 Trie 树</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1grmtz93bvej31560t8wqs.jpg" alt="image-20210618232114437"></p><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><p>图与树类似，区别在于图没有子结点或父结点，因此也没有根结点。图由结点和边构成，且任何结点可以有多个入边或出边。<br>图是最灵活的数据结构，几乎可以表示所有类型的数据。例如，图非常适合描述社交网络，其中结点代表人，边代表人与人之间的友谊。</p><ul><li>基本概念</li></ul><p>顶点：图中的元素</p><p>边：顶点与顶点之间建立的关系</p><p>度：每个用户有多少个好友， 对应到图中，就叫做顶点的<strong>度</strong>(degree)，就是跟顶点相连接的边的条数。</p><p>权重：边表示关系的重要程度</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gr35zdekfmj30mm0awdhq.jpg" alt="image-20210601230517752"></p><ul><li>存储</li></ul><p>1）邻接矩阵</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gr360ayorxj31340ms76f.jpg" alt="image-20210428232731364"></p><p>2）邻接表：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqh6wzd1jdj315c0t0b29.jpg" alt="image-20210428232950016"></p><ul><li>搜索</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyzb5fx8rpj30qg0cgt9y.jpg" alt="image-20220202174431733"></p><p>DFS: 栈，更省内存</p><p>BFS：队列，更快可能</p><p>e.g. 迷宫问题</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gv1fzbloegj614q0fgjtb02.jpg" alt="image-20211003004126297"></p><p>code 两种思路: DFS、BFS</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">maze= [</span><br><span class="line">    [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>],  <span class="comment"># 5</span></span><br><span class="line">    [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">]</span><br><span class="line">maze1 = copy.deepcopy(maze)</span><br><span class="line">maze2 = copy.deepcopy(maze)</span><br><span class="line"></span><br><span class="line">dirs = [</span><br><span class="line">    <span class="keyword">lambda</span> x,y:(x,y+<span class="number">1</span>),</span><br><span class="line">    <span class="keyword">lambda</span> x,y:(x+<span class="number">1</span>,y),</span><br><span class="line">    <span class="keyword">lambda</span> x,y:(x,y-<span class="number">1</span>),</span><br><span class="line">    <span class="keyword">lambda</span> x,y:(x-<span class="number">1</span>,y),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_path</span>(<span class="params">path</span>):</span></span><br><span class="line">    cur_node = path[-<span class="number">1</span>]</span><br><span class="line">    real_path = []</span><br><span class="line">    <span class="keyword">while</span> cur_node[<span class="number">2</span>] != -<span class="number">1</span>:</span><br><span class="line">        real_path.append(cur_node[<span class="number">0</span>:<span class="number">2</span>])</span><br><span class="line">        cur_node = path[cur_node[<span class="number">2</span>]]</span><br><span class="line">    real_path.append(cur_node[<span class="number">0</span>:<span class="number">2</span>])  <span class="comment"># 把起点放进去</span></span><br><span class="line">    real_path.reverse()  <span class="comment"># 翻转</span></span><br><span class="line">    <span class="keyword">for</span> node <span class="keyword">in</span> real_path:</span><br><span class="line">        <span class="built_in">print</span>(node,end=<span class="string">&#x27;&gt;&gt;&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maze_path_queue</span>(<span class="params">x1,y1,x2,y2</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    队列实现，广度优先</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param x1:</span></span><br><span class="line"><span class="string">    :param y1:</span></span><br><span class="line"><span class="string">    :param x2:</span></span><br><span class="line"><span class="string">    :param y2:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># a = maze1</span></span><br><span class="line">    queue = deque()</span><br><span class="line">    queue.append((x1,y1,-<span class="number">1</span>))</span><br><span class="line">    path_record_pop = []  <span class="comment"># 记录出队的点,便于输出最终路径</span></span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        cur_node = queue.popleft()</span><br><span class="line">        path_record_pop.append(cur_node)</span><br><span class="line">        <span class="keyword">if</span> cur_node[<span class="number">0</span>]==x2 <span class="keyword">and</span> cur_node[<span class="number">1</span>]==y2:</span><br><span class="line">            print_path(path_record_pop)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">dir</span> <span class="keyword">in</span> dirs:</span><br><span class="line">            next_node = <span class="built_in">dir</span>(cur_node[<span class="number">0</span>], cur_node[<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">if</span> maze1[next_node[<span class="number">0</span>]][next_node[<span class="number">1</span>]]==<span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 记录next节点来自哪里</span></span><br><span class="line">                queue.append((next_node[<span class="number">0</span>], next_node[<span class="number">1</span>], <span class="built_in">len</span>(path_record_pop)-<span class="number">1</span>))</span><br><span class="line">                maze1[next_node[<span class="number">0</span>]][next_node[<span class="number">1</span>]] =<span class="string">&#x27;♨&#x27;</span> <span class="comment"># 标记为走过</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;没有路&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maze_path</span>(<span class="params">x1,y1,x2,y2</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    迷宫路径</span></span><br><span class="line"><span class="string">    采用栈，深度优先搜索 DSF，回溯法</span></span><br><span class="line"><span class="string">    一条路走到黑</span></span><br><span class="line"><span class="string">    缺点：不能保证是最短路径</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    0 0 0 0</span></span><br><span class="line"><span class="string">    1 1 1 [1]-&gt;(1,3)</span></span><br><span class="line"><span class="string">    0 1 0 1</span></span><br><span class="line"><span class="string">    :param x1: 起点位置，行</span></span><br><span class="line"><span class="string">    :param y1:</span></span><br><span class="line"><span class="string">    :param x2: 终点位置</span></span><br><span class="line"><span class="string">    :param y2:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    stack = []</span><br><span class="line">    stack.append((x1,y1))</span><br><span class="line">    maze2[x1][y1] = <span class="string">&#x27;♨&#x27;</span>  <span class="comment"># 标记为已走过</span></span><br><span class="line">    <span class="keyword">while</span> stack:  <span class="comment"># 非空</span></span><br><span class="line">        a =maze2</span><br><span class="line">        current_node = stack[-<span class="number">1</span>]  <span class="comment"># 当前节点</span></span><br><span class="line">        <span class="keyword">if</span> current_node==(x2,y2): <span class="comment"># 走到终点</span></span><br><span class="line">            <span class="keyword">for</span> p <span class="keyword">in</span> stack:</span><br><span class="line">                <span class="built_in">print</span>(p, end=<span class="string">&#x27;-&gt;&#x27;</span>)</span><br><span class="line">            <span class="built_in">print</span>()</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">dir</span> <span class="keyword">in</span> dirs:</span><br><span class="line">            next_node = <span class="built_in">dir</span>(current_node[<span class="number">0</span>], current_node[<span class="number">1</span>])</span><br><span class="line">            <span class="comment"># 如果下一个节点能走</span></span><br><span class="line">            <span class="keyword">if</span> maze2[next_node[<span class="number">0</span>]][next_node[<span class="number">1</span>]]==<span class="number">0</span>:</span><br><span class="line">                stack.append(next_node)</span><br><span class="line">                maze2[next_node[<span class="number">0</span>]][next_node[<span class="number">1</span>]] = <span class="string">&#x27;♨&#x27;</span>  <span class="comment"># 标记为已走过</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>: <span class="comment"># 回退，注意这里必须写成for-else 语句, break执行则此步不执行</span></span><br><span class="line">            stack.pop()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;没有路&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">start_end = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;深度优先：&#x27;</span>)</span><br><span class="line">maze_path(start_end[<span class="number">0</span>],start_end[<span class="number">1</span>],start_end[<span class="number">2</span>],start_end[<span class="number">3</span>])</span><br><span class="line">maze2[start_end[<span class="number">0</span>]][start_end[<span class="number">1</span>]]=<span class="string">&#x27;■&#x27;</span></span><br><span class="line">maze2[start_end[<span class="number">2</span>]][start_end[<span class="number">3</span>]]=<span class="string">&#x27;☆&#x27;</span></span><br><span class="line">df1 = pd.DataFrame(maze2)</span><br><span class="line">df2 =pd.DataFrame(maze)</span><br><span class="line">df_ = pd.DataFrame([[<span class="string">&#x27;|&#x27;</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(maze))])</span><br><span class="line"><span class="built_in">print</span>(pd.concat([df1,df_, df2],axis=<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;----&#x27;</span>*<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;广度优先：&#x27;</span>)</span><br><span class="line">maze_path_queue(start_end[<span class="number">0</span>],start_end[<span class="number">1</span>],start_end[<span class="number">2</span>],start_end[<span class="number">3</span>])</span><br><span class="line">maze1[start_end[<span class="number">0</span>]][start_end[<span class="number">1</span>]]=<span class="string">&#x27;■&#x27;</span></span><br><span class="line">maze1[start_end[<span class="number">2</span>]][start_end[<span class="number">3</span>]]=<span class="string">&#x27;☆&#x27;</span></span><br><span class="line">df1 = pd.DataFrame(maze1,index=<span class="literal">None</span>)</span><br><span class="line">df2 =pd.DataFrame(maze)</span><br><span class="line">df_ = pd.DataFrame([[<span class="string">&#x27;|&#x27;</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(maze))])</span><br><span class="line"><span class="built_in">print</span>(pd.concat([df1,df_, df2],axis=<span class="number">1</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>具体执行结果差异如下：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gv20xsmyf6j61tm0tu43t02.jpg" alt="image-20211003124633168"></p><ul><li>戴克斯特拉算法</li></ul><p>寻找结点之间的最短路径是最著名的图问题</p><p>戴克斯特拉算法如下：</p><blockquote><ol><li>设来源节点的距离值为 0，其余节点的距离值为最大值；</li><li>选择并固定距离值最小的非固定节点；</li><li>依次松弛起点为当前节点的所有边，跳过终点已被固定的边，更新路径长度；</li><li>重复（2）～（4）至所有节点都被固定。</li></ol></blockquote><p>贪心+ 广度优先思想</p><p><a href="https://www.92python.com/view/364.html">https://www.92python.com/view/364.html</a></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gz0cka51yoj30q411c0x8.jpg" alt="image-20220203151715859"></p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>掌握程度:轻松写出二叉树遍历、八皇后、背包问题、DFS 的递归代码</p><ul><li>递归的理解</li></ul><p>递归表示函数在定义中调用自身</p><p>递归包括两个过程 ，去的过程叫’递‘，回来的过程叫’归‘，自顶向下。</p><p> 所谓递归，就是有去有回。</p><ul><li>特点</li></ul><p>1）调用自身</p><p>2）结束条件</p><p>3）子问题拆分</p><p><strong>编写递归代码的关键是，只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用 关系，不要试图用人脑去分解递归的每个步骤</strong>。</p><p>递归要警惕堆栈溢出和重复计算(👇)</p><ul><li>递归函数的非递归化</li></ul><p><a href="https://blog.csdn.net/bobbypollo/article/details/79891556">理解递归的本质：递归与栈</a></p><p>采用数据栈</p><blockquote><p>我们知道递归函数存在的最大问题是，当递归次数足够大时，会导致函数栈溢出而死机，函数栈的大小一般是一个固定值，对于linux来说一般默认是8M。</p><p> 因此，编程老司机会教导我们，不得用递归函数！但递归函数的代码实现实在是简洁啊，不让用？臣妾做不到啊！</p><p> 那么问题来了，所有递归函数都能非递归化吗？答案是肯定的。</p><p> 本质上讲，对于同一个问题，如果必然要用广义递归的方案来处理，那么狭义递归函数只不过是其中的一种实现方式，如果放弃狭义递归函数的话，我们不得不借助一个额外的数据结构：栈。</p><p> 如此看来，无论如何都要用到栈，只不过要么让编译器来维护一个栈（函数栈），要么让程序狗来维护一个栈（数据栈）。</p></blockquote><p> 这两个栈的区别如下：</p><table><thead><tr><th></th><th align="left">函数栈</th><th align="left">数据栈</th></tr></thead><tbody><tr><td>位置</td><td align="left">进程的stack区</td><td align="left">进程的heap区</td></tr><tr><td>大小限制</td><td align="left">小（8M？）</td><td align="left">能分配到很大</td></tr><tr><td>每个栈“元素”所需空间</td><td align="left">比较大，因为要存储函数上下文</td><td align="left">可以设计到很小，比如只存储一个指针</td></tr><tr><td>栈开销</td><td align="left">大</td><td align="left">可以做的很小</td></tr><tr><td>代码简易程度/可维护性</td><td align="left">简洁易读</td><td align="left">相对更复杂</td></tr></tbody></table><ul><li>应用举例：找最终推荐人</li></ul><p>一般来说，我们会通过数据库来记录这种推荐关系。在数据库表中，我们可以记录两行数据，其中 actor_id 表示用户 id，referrer_id 表示推荐人 id。</p><table><thead><tr><th>actor_id</th><th>referrer_id</th></tr></thead><tbody><tr><td>B</td><td>A</td></tr><tr><td>C</td><td>B</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">long findRootReferrerId(long actorId) &#123;</span><br><span class="line">  Long referrerId = select referrer_id from [table] where actor_id = actorId;  # 通过这个缩小规模</span><br><span class="line">  if (referrerId == null) return actorId;   # 终止条件</span><br><span class="line">  return findRootReferrerId(referrerId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用户 C 的“最终推荐人”为用户 A</p><ul><li>汉诺塔问题</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1guxwwotvuuj60ga05t3yd02.jpg" alt="img"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hanoi</span>(<span class="params">n,a,b,c</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    汉诺塔问题</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    n 个盘子 从a经过b移动到c</span></span><br><span class="line"><span class="string">    步骤：</span></span><br><span class="line"><span class="string">    1 (n-1)个从a--&gt;c--&gt;b</span></span><br><span class="line"><span class="string">    2 n a--&gt;c</span></span><br><span class="line"><span class="string">    3 n-1 从b--&gt;a--&gt;c</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param n:</span></span><br><span class="line"><span class="string">    :param a:</span></span><br><span class="line"><span class="string">    :param b:</span></span><br><span class="line"><span class="string">    :param c:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> n&gt;<span class="number">0</span>:  <span class="comment"># 终止条件</span></span><br><span class="line">        hanoi(n-<span class="number">1</span>, a,c,b)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;moving from <span class="subst">&#123;a&#125;</span>--&gt;<span class="subst">&#123;c&#125;</span>&#x27;</span>)</span><br><span class="line">        hanoi(n-<span class="number">1</span>, b, a,c)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">hanoi(<span class="number">3</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li>最大公约数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fraction</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,a,b,</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;a:分子， b:分母&quot;&quot;&quot;</span></span><br><span class="line">        self.a = a</span><br><span class="line">        self.b = b</span><br><span class="line">        x = self.gcd1(self.a, self.b)</span><br><span class="line">        self.a = self.a/x</span><br><span class="line">        self.b = self.b/x</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gcd1</span>(<span class="params">self, a, b</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        最大公约数，辗转相除法</span></span><br><span class="line"><span class="string">        :param a:</span></span><br><span class="line"><span class="string">        :param b:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> b == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> a</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.gcd1(b, a % b)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gcd</span>(<span class="params">self, a, b</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;最大公约数&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">while</span> b &gt; <span class="number">0</span>:</span><br><span class="line">            r = a % b</span><br><span class="line">            a = b</span><br><span class="line">            b = r</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">zgs</span>(<span class="params">self,a,b</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;最小公倍数&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> a*b/self.gcd1(a,b)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&#x27;<span class="subst">&#123;self.a:<span class="number">.0</span>f&#125;</span>/<span class="subst">&#123;self.b:<span class="number">.0</span>f&#125;</span>&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__add__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">        <span class="comment"># a/b+c/d</span></span><br><span class="line">        a= self.a</span><br><span class="line">        b= self.b</span><br><span class="line">        c= other.a</span><br><span class="line">        d = other.b</span><br><span class="line">        denominator =self.zgs(b,d)  <span class="comment"># 通分后分母</span></span><br><span class="line">        numerator = a*(denominator/b)+c*(denominator/d)  <span class="comment"># 分子</span></span><br><span class="line">        <span class="keyword">return</span> Fraction(numerator, denominator)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># f = Fraction(30,15)</span></span><br><span class="line"><span class="comment"># print(f)</span></span><br><span class="line">a =Fraction(<span class="number">1</span>,<span class="number">3</span>)</span><br><span class="line">b =Fraction(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(a+b)</span><br><span class="line"><span class="number">5</span>/<span class="number">6</span></span><br></pre></td></tr></table></figure><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>按照复杂度分为：</p><table><thead><tr><th>排序算法</th><th>时间复杂度</th><th>是否基于比较</th></tr></thead><tbody><tr><td>冒泡、插入、选择</td><td>O(n^2)</td><td>✅</td></tr><tr><td>快排，归并</td><td>O(nlog(n))</td><td>✅</td></tr><tr><td>桶，计数，基数</td><td>O(n）</td><td>❌</td></tr></tbody></table><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gv090z6225j61bs0tsgr202.jpg" alt="image-20211001235515892"></p><ul><li>原地排序</li></ul><p>指空间复杂度O(1)的排序算法</p><ul><li>排序稳定性</li></ul><p>指的是待排序序列中有值相等的元素，经过排序后，<strong>相等元素之间原有的先后顺序不变</strong>，则称<strong>稳定</strong>的排序算法，否则就叫作不稳定的排序算法</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpev7b92qvj31ct0u07wi.jpg" alt="image-20210410191801301"></p><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><blockquote><p>思想：通过比较相邻元素，交换位置，每一轮将最值元素通过’冒泡‘浮到边界位置</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1guyfat4mp4j60w20eot9q02.jpg" alt="image-20210930100111313"></p><p>代码实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span>(<span class="params">li</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(li)-<span class="number">1</span>):  <span class="comment"># 趟数，第i趟</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(li)-i-<span class="number">1</span>):  <span class="comment"># 箭头</span></span><br><span class="line">            <span class="keyword">if</span> li[j]&gt;li[j+<span class="number">1</span>]:</span><br><span class="line">                li[j], li[j+<span class="number">1</span>] = li[j+<span class="number">1</span>], li[j]</span><br><span class="line">        <span class="built_in">print</span>(li)</span><br></pre></td></tr></table></figure><p>改进：</p><p>如果某趟没有发生交换，说明已经排好序了，提前终止</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span>(<span class="params">li</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(li)-<span class="number">1</span>):</span><br><span class="line">        exchange = <span class="literal">False</span>  <span class="comment"># 添加标志位</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(li)-i-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> li[j]&gt;li[j+<span class="number">1</span>]:</span><br><span class="line">                li[j], li[j+<span class="number">1</span>] = li[j+<span class="number">1</span>], li[j]</span><br><span class="line">                exchange=<span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> exchange:</span><br><span class="line">            <span class="keyword">return</span></span><br></pre></td></tr></table></figure><ul><li>复杂度分析：</li></ul><p>属于原地排序；</p><p>由于元素相等时候不进行交换，故为<strong>稳定的；</strong></p><p>复杂度O(n^2）</p><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gynntfko8kj31960jytan.jpg" alt="image-20220123155600173"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span>(<span class="params">li</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(li)):  <span class="comment"># 摸到的牌下标</span></span><br><span class="line">        j = i-<span class="number">1</span>  <span class="comment"># 手里牌</span></span><br><span class="line">        tmp = li[i]  <span class="comment"># 摸到的牌</span></span><br><span class="line">        <span class="keyword">while</span> li[j]&gt;tmp <span class="keyword">and</span> j&gt;=<span class="number">0</span>:</span><br><span class="line">            li[j+<span class="number">1</span>] = li[j]</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        li[j+<span class="number">1</span>] = tmp  <span class="comment"># 注意这里写到 j+1</span></span><br></pre></td></tr></table></figure><ul><li>复杂度分析：</li></ul><p>属于原地排序；</p><p>由于元素相等时候不进行移动，故为<strong>稳定的；</strong></p><p>2个for循环，复杂度O(n^2）</p><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>希尔排序是插入排序的变形，思路是不断分组——插入排序，直到gap 变为1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort_gap</span>(<span class="params">li, gap</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;只需要将插入排序的 1--&gt;gap&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(gap,<span class="built_in">len</span>(li)):  <span class="comment"># 摸到的牌下标</span></span><br><span class="line">        j = i-gap  <span class="comment"># 手里牌</span></span><br><span class="line">        tmp = li[i]  <span class="comment"># 摸到的牌</span></span><br><span class="line">        <span class="keyword">while</span> li[j]&gt;tmp <span class="keyword">and</span> j&gt;=<span class="number">0</span>:</span><br><span class="line">            li[j+gap] = li[j]</span><br><span class="line">            j -= gap</span><br><span class="line">        li[j+gap] = tmp</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shell_sort</span>(<span class="params">li</span>):</span></span><br><span class="line">    gap = <span class="built_in">len</span>(li)//<span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> gap&gt;=<span class="number">1</span>:</span><br><span class="line">        insert_sort_gap(li, gap)</span><br><span class="line">        gap //= <span class="number">2</span></span><br></pre></td></tr></table></figure><ul><li>复杂度</li></ul><p><a href="https://en.wikipedia.org/wiki/Shellsort">https://en.wikipedia.org/wiki/Shellsort</a></p><p>和选取的 gap 有关</p><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>每轮找到最值元素，然后交换</p><p>不稳定</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_sort</span>(<span class="params">li</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(li)-<span class="number">1</span>):  <span class="comment"># 趟数</span></span><br><span class="line">        min_loc = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>,<span class="built_in">len</span>(li)):</span><br><span class="line">            <span class="keyword">if</span> li[j]&lt;li[min_loc]:</span><br><span class="line">                min_loc =j</span><br><span class="line">        li[min_loc], li[i] = li[i], li[min_loc]  <span class="comment"># 交换</span></span><br></pre></td></tr></table></figure><ul><li>综合比较</li></ul><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpfsqje6ajj31gw0mqx6q.jpg" alt="image-20210411143808882"></p><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>发明人是冯诺依曼，时间 1945年</p><p>归并和快排背后 使用的都是分治思想，而分治算法一般都是用递归实现的。</p><p><strong>分治是一种解决问题的处理思想， 递归是一种编程技巧</strong>，这二者并不冲突。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpfusgjj5vj311t0u0npe.jpg" alt="image-20210411154915840"></p><p>代码：【注意合并过程，代码有打印】</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">递归实现：</span></span><br><span class="line"><span class="string">递推公式： merge_sort(p,r) = merge(merge_sort(p,q),merge_sort(q+1, r))</span></span><br><span class="line"><span class="string">终止条件： p&gt;=r</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">li = [<span class="number">11</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span>(<span class="params">li, p, r</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">if</span> p&gt;=r: <span class="keyword">return</span></span><br><span class="line">    mid = (p+r)//<span class="number">2</span>   <span class="comment"># 中间位置</span></span><br><span class="line">    merge_sort(li, p, mid)</span><br><span class="line">    merge_sort(li, mid+<span class="number">1</span>, r)</span><br><span class="line">    merge(li, p, mid, r)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">li, p, mid, r</span>):</span></span><br><span class="line">    tmp = []  <span class="comment"># 申请临时数组，存放merge 结果</span></span><br><span class="line">    i= p</span><br><span class="line">    j = mid+<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i&lt;=mid <span class="keyword">and</span> j&lt;=r:</span><br><span class="line">        <span class="keyword">if</span> li[i]&lt;=li[j]:  <span class="comment"># ‘=’保证是稳定的</span></span><br><span class="line">            tmp.append(li[i])</span><br><span class="line">            i +=<span class="number">1</span> </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            tmp.append(li[j])</span><br><span class="line">            j +=<span class="number">1</span></span><br><span class="line">    <span class="comment"># while 执行完肯定有一部分没数了</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> i&lt;=mid: <span class="comment"># 说明这部分还没取完</span></span><br><span class="line">        tmp.append(li[i])</span><br><span class="line">        i +=<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> j&lt;=r: <span class="comment"># 说明这部分还没取完</span></span><br><span class="line">        tmp.append(li[j])</span><br><span class="line">        j +=<span class="number">1</span></span><br><span class="line">    li[p:r+<span class="number">1</span>] = tmp</span><br><span class="line">    <span class="built_in">print</span>(tmp)</span><br><span class="line">    </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;原始序列<span class="subst">&#123;li&#125;</span>&#x27;</span>)</span><br><span class="line">merge_sort(li, <span class="number">0</span>, <span class="built_in">len</span>(li)-<span class="number">1</span>)</span><br><span class="line">li</span><br><span class="line">----</span><br><span class="line">原始序列[<span class="number">11</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>]</span><br><span class="line">[<span class="number">8</span>, <span class="number">11</span>]</span><br><span class="line">[<span class="number">3</span>, <span class="number">9</span>]</span><br><span class="line">[<span class="number">3</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">11</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">7</span>]</span><br><span class="line">[<span class="number">2</span>, <span class="number">5</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">7</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">11</span>]   <span class="comment"># 注意合并过程与⤴️图一致</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>复杂度分析：</li></ul><p>空间复杂度O(n), 不属于原地排序；</p><p><strong>稳定的</strong>， 可由<code>if li[i]&lt;=li[j]: tmp.append(li[i])</code> 保证</p><p>复杂度O(nlg(n)）</p><h3 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h3><p>快排，也是采用分治思想</p><p>代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 递推公式：</span></span><br><span class="line"><span class="comment"># quick_sort(p…r) = quick_sort(p…q-1) + quick_sort(q+1… r)</span></span><br><span class="line"><span class="comment"># 终止条件：</span></span><br><span class="line"><span class="comment"># p &gt;= r</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span>(<span class="params">li, p, r</span>):</span></span><br><span class="line">    <span class="keyword">if</span> p&lt;r:</span><br><span class="line">        q = partition(li, p, r)   <span class="comment"># 获分区点</span></span><br><span class="line">        quick_sort(li, p, q-<span class="number">1</span>)</span><br><span class="line">        quick_sort(li, q+<span class="number">1</span>, r)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span>(<span class="params">li, p, r</span>):</span></span><br><span class="line">    pivot = li[p]  <span class="comment"># 选队首为比较点</span></span><br><span class="line">    <span class="keyword">while</span> p&lt;r:</span><br><span class="line">        <span class="keyword">while</span> li[r]&gt;=pivot <span class="keyword">and</span> p&lt;r:  <span class="comment"># 从右边找，比 pivot小的</span></span><br><span class="line">            r -= <span class="number">1</span></span><br><span class="line">        li[p] = li[r]  <span class="comment"># 写空位</span></span><br><span class="line">        <span class="keyword">while</span> li[p] &lt;=pivot <span class="keyword">and</span> p&lt;r:</span><br><span class="line">            p += <span class="number">1</span></span><br><span class="line">        li[r] = li[p]</span><br><span class="line">    li[p] = pivot  <span class="comment"># p/r相遇,归位</span></span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">li = [<span class="number">13</span>,<span class="number">11</span>,<span class="number">25</span>,<span class="number">7</span>,<span class="number">19</span>,<span class="number">3</span>]      </span><br><span class="line">quick_sort(li, <span class="number">0</span>, <span class="built_in">len</span>(li)-<span class="number">1</span>)</span><br><span class="line">li</span><br></pre></td></tr></table></figure><p>关于<code>def partition(li, p, r)   # 获分区点</code>函数的解释：</p><p>黑框内为待替换位置，也是最终的返回位置，随着递推，p、r越来越接近。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpg0782djyj314w0rekef.jpg" alt="image-20210411185628255"></p><p>快排时间复杂度：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">T(1) = C；   n=1时，只需要常量级的执行时间，所以表示为C。</span><br><span class="line">T(n) = 2*T(n/2) + n； n&gt;1</span><br></pre></td></tr></table></figure><p>T(n) = O(nlogn)</p><ul><li>快排与归并 的比较</li></ul><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpg0ev9ov4j31do0ti4qq.jpg" alt="image-20210411190349148"></p><p>可以发现，归并排序的处理过程是<strong>由下到上</strong>的，先处理子问题，然后再合并。而快排正好相反，它的处 理过程是<strong>由上到下</strong>的，先分区，然后再处理子问题。归并排序虽然是稳定的、时间复杂度为 O(nlogn) 的 排序算法，但是它是非原地排序算法。我们前面讲过，归并之所以是非原地排序算法，主要原因是合并 函数无法在原地执行。快速排序通过设计巧妙的原地分区函数，可以实现原地排序，解决了归并排序占 用太多内存的问题。</p><blockquote><p>问题：O(n) 时间复杂度内求无序数组中的第 K 大元素。</p><p>利用快排，经过一次快排，得到A[0,1,…,p-1], A[p], A[p+1,…,n-1]</p><p>然后根据K与p大小关系，进行递归，每次减半</p><p>复杂度：n+n/2+…+1=O(n)</p><p>代码：参见力扣：<a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">https://leetcode-cn.com/problems/kth-largest-element-in-an-array/</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="comment">#  [3,2,1,5,6,4] 和 k = 3</span></span><br><span class="line">        <span class="comment"># &quot;采用快排思想&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">li, p, r</span>):</span></span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">            q = partition(li, p,r)</span><br><span class="line">            <span class="keyword">if</span> q+<span class="number">1</span>==k:</span><br><span class="line">                <span class="keyword">return</span> li[q]</span><br><span class="line">            <span class="keyword">elif</span> q+<span class="number">1</span>&gt;k:</span><br><span class="line">                <span class="keyword">return</span> helper(li, p, q-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> helper(li, q+<span class="number">1</span>, r)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">partition</span>(<span class="params">li, p, r</span>):</span></span><br><span class="line">            pivot = li[p]  <span class="comment"># 选队首为比较点</span></span><br><span class="line">            <span class="keyword">while</span> p&lt;r:</span><br><span class="line">                <span class="keyword">while</span> li[r]&lt;=pivot <span class="keyword">and</span> p&lt;r:</span><br><span class="line">                    r -= <span class="number">1</span></span><br><span class="line">                li[p] = li[r]</span><br><span class="line">                <span class="keyword">while</span> li[p] &gt;=pivot <span class="keyword">and</span> p&lt;r:</span><br><span class="line">                    p += <span class="number">1</span></span><br><span class="line">                li[r] = li[p]</span><br><span class="line">            li[p] = pivot  <span class="comment"># p/r相遇,得到</span></span><br><span class="line">            <span class="keyword">return</span> p</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> helper(nums, <span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span>)</span><br></pre></td></tr></table></figure></blockquote><h3 id="复杂度O-n-排序"><a href="#复杂度O-n-排序" class="headerlink" title="复杂度O(n)排序"></a>复杂度O(n)排序</h3><p>它们均不涉及元素之间的比较操作</p><ul><li>计数排序</li></ul><p>计数排序其实是桶排序的一种特殊情况</p><p>时间复杂度：O(n+K)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">counting_sort</span>(<span class="params">li</span>):</span></span><br><span class="line">    max_num = <span class="built_in">max</span>(li)</span><br><span class="line">    count_li = [<span class="number">0</span>] * (max_num + <span class="number">1</span>)  <span class="comment"># 计数列表</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> li:</span><br><span class="line">        count_li[num] += <span class="number">1</span></span><br><span class="line">    li.clear()</span><br><span class="line">    <span class="keyword">for</span> i,v <span class="keyword">in</span> <span class="built_in">enumerate</span>(count_li):</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(v):</span><br><span class="line">            li.append(i)</span><br></pre></td></tr></table></figure><p>缺点：</p><p>1）当数列最大、最小值差距过大时</p><p>意味着，空间的极大浪费</p><p>2）小数</p><ul><li>桶排序</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gv089dd00cj60o209k0tf02.jpg" alt="image-20211001232844068"></p><ul><li>基数排序</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gv08qbo2ndg60s40fywic02.gif" alt="img"></p><ul><li>比较</li></ul><p>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p><p><strong>基数排序：</strong>根据键值的每位数字来分配桶；</p><p><strong>计数排序：</strong>每个桶只存储单一键值；</p><p><strong>桶排序：</strong>每个桶存储一定范围的数值；</p><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1guxyd2a1mmj60xg0c4dgf02.jpg" alt="image-20210930001510344"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span>(<span class="params">li, val</span>):</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = <span class="built_in">len</span>(li)-<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:  <span class="comment"># 候选区有值</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">        mid = (left+right)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> li[mid]==val:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">elif</span> li[mid]&gt;val:  <span class="comment"># 待查找的值在 mid 左侧</span></span><br><span class="line">            right = mid-<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>: <span class="comment"># 待查找的值在 mid 右侧</span></span><br><span class="line">            left = mid+<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">----------</span><br><span class="line">li = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>))</span><br><span class="line"><span class="built_in">print</span>(binary_search(li, <span class="number">3</span>))</span><br></pre></td></tr></table></figure><p>时间复杂度：O(lgn)</p><p>递归和非递归代码参见：<a href="https://github.com/flitdu/consult/blob/main/jupyter/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.ipynb"><strong>二分查找.ipynb</strong> </a></p><ul><li>适用场景</li></ul><p>二分查找只能用<strong>在插入、删除操作不频繁，一次排序多次查找的场景中</strong>。针对动态变化的数据集合，二分查找将不再适用。那针对动态数据集合，如何在其中快速查找某个数据呢?别急，等到二叉树 那一节我会详细讲。</p><ul><li>二分查找变形</li></ul><ol><li>变体一:查找第一个值等于给定值的元素</li><li>变体二:查找最后一个值等于给定值的元素</li><li>变体三:查找第一个 ≥ 给定值的元素</li><li>变体四:查找最后一个 ≤ 给定值的元素</li></ol><p>参见：<a href="https://github.com/flitdu/consult/blob/main/jupyter/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.ipynb"><strong>二分查找.ipynb</strong> </a></p><h2 id="字符串匹配"><a href="#字符串匹配" class="headerlink" title="字符串匹配"></a>字符串匹配</h2><h3 id="BF算法"><a href="#BF算法" class="headerlink" title="BF算法"></a>BF算法</h3><p>Brute Force, 也即暴力匹配算法，复杂度为O（mn），其中m为模式串长度，n 为主串长度，n&gt;m</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gpwd1fyt1sj30vk0eqwzb.jpg" alt="image-20210425222923858"></p><h3 id="RK-算法"><a href="#RK-算法" class="headerlink" title="RK 算法"></a>RK 算法</h3><p>RK 算法的全称叫 Rabin-Karp 算法，是由它的两位发明者 Rabin 和 Karp 的名字来命名的。</p><p>是BF算法的升级版</p><p>RK 算法的思路是这样的：我们通过哈希算法对主串中的 n-m+1 个子串分别求哈希值，然后逐个与模式串的哈希值比较大小。如果某个子串的哈希值与模式串相等，那就说明对应的子串和模式串匹配了(这 里先不考虑哈希冲突的问题，后面我们会讲到)。因为哈希值是一个数字，数字之间比较是否相等是非 常快速的，所以模式串和子串比较的效率就提高了。</p><p>整体复杂度：O(n)</p><h3 id="BM-算法"><a href="#BM-算法" class="headerlink" title="BM 算法"></a>BM 算法</h3><h2 id="四种算法思想"><a href="#四种算法思想" class="headerlink" title="四种算法思想"></a>四种算法思想</h2><p>贪心 算法、分治算法、回溯算法、动态规划，更加确切地说，它们应该是算法思想，并不是具体的算法，常用来指导我们设计具体的算法和编码等。</p><h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><p>应用领域：</p><ul><li><p>深度优先搜索</p></li><li><p>正则表达式匹配</p></li><li><p>编译原理中的语法分析</p></li><li><p>数独</p></li><li><p>0-1背包</p></li><li><p>图的着色</p></li><li><p>旅行商问题</p></li><li><p>全排列</p></li><li><p>N皇后问题</p></li></ul><p>参考：<a href="https://www.bilibili.com/video/av374837176/">合格程序员必会，回溯法解八皇后，看了这个动画，你就全明白了，C++实现</a></p><p>笼统地讲，回溯算法很多时候都应用在“搜索”这类问题上。不过这里说的搜索，并不是􏰃义的指我们前 面讲过的图的搜索算法，而是在一组可能的解中，搜索满足期望的解。</p><p>回溯有点类似枚举，非常适合用递归实现。某次尝试出现错误后回到之前的时刻，重新尝试，类似于《蝴蝶效应》</p><h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><p>贪心算法有很多经典的应用，比如霍夫曼编码(Huffman Coding)、Prim 和 Kruskal 最小生成树算法、还有 Dijkstra 单源最短路径算法</p><ul><li>找零问题</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">t = [<span class="number">100</span>, <span class="number">50</span>, <span class="number">20</span>, <span class="number">5</span>, ]  <span class="comment"># 可以找的零钱面值</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change</span>(<span class="params">t, n</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;贪心思路&quot;&quot;&quot;</span></span><br><span class="line">    m = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(t))]  <span class="comment"># 保存对应钱数的张数</span></span><br><span class="line">    <span class="keyword">for</span> i,money <span class="keyword">in</span> <span class="built_in">enumerate</span>(t):</span><br><span class="line">        m[i] = n//money</span><br><span class="line">        n %= money</span><br><span class="line">    <span class="keyword">return</span> m,n</span><br><span class="line"><span class="built_in">print</span>(change(t, <span class="number">136</span>))</span><br><span class="line">([<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>], <span class="number">1</span>)</span><br></pre></td></tr></table></figure><ul><li>活动安排</li></ul><p>使得举办的活动数最多，i 为活动序号，s活动开始时间，f结束时间【注意这里结束时间 f 要有序】</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gv3ey3lsi6j617e05st9602.jpg" alt="image-20211004173646149"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">activities = [(<span class="number">1</span>,<span class="number">4</span>), (<span class="number">3</span>,<span class="number">5</span>), (<span class="number">0</span>,<span class="number">6</span>),</span><br><span class="line">              (<span class="number">5</span>,<span class="number">7</span>), (<span class="number">3</span>,<span class="number">9</span>), (<span class="number">5</span>,<span class="number">9</span>),</span><br><span class="line">              (<span class="number">6</span>,<span class="number">10</span>), (<span class="number">8</span>,<span class="number">11</span>), (<span class="number">8</span>,<span class="number">12</span>),</span><br><span class="line">              (<span class="number">2</span>,<span class="number">14</span>), (<span class="number">12</span>,<span class="number">16</span>)]  <span class="comment"># 活动（开始时间，结束时间）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">activity_selection</span>(<span class="params">a</span>):</span></span><br><span class="line">  <span class="string">&quot;&quot;&quot;贪心思路：选择活动最先结束的&quot;&quot;&quot;</span></span><br><span class="line">    res = [a[<span class="number">0</span>]]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(a)):</span><br><span class="line">        <span class="keyword">if</span> a[i][<span class="number">0</span>]&gt;=res[-<span class="number">1</span>][<span class="number">1</span>]:<span class="comment"># 当前活动的开始时间 &gt; 最后一个入选活动的结束时间</span></span><br><span class="line">            <span class="comment"># 不冲突</span></span><br><span class="line">            res.append(a[i])</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"><span class="built_in">print</span>(activity_selection(activities))</span><br></pre></td></tr></table></figure><p>[(1, 4), (5, 7), (8, 11), (12, 16)]</p><ul><li>霍夫曼编码</li></ul><p>贪心思想：出现频率多的字符，用稍微短一些的字符编码；出现频率少的字符，用长一些的编码。霍夫曼编码要求各个字符的编码之间，不会出现某个编码是 另一个编码前缀的情况。</p><p>具体实现：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqck0ezmfoj316s0u07wj.jpg" alt="image-20210509223800911"></p><p>所以，最终的编码为</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqck1wrsyqj30zk0jqx0x.jpg" alt="image-20210509224139300"></p><h3 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h3><p>分治算法核心思想：分而治之 ，也就是将原问题划分成 n 个 规模较小，并且结构与原问题相似的子问题，<strong>递归</strong>地解决这些子问题，然后再合并其结果，就得到原问 题的解。</p><p><strong>分治算法子问题之间没有相关性，这一点是跟动态规划的明显区别</strong></p><ul><li>股票最佳交易</li></ul><p>e.g. </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[7,1,5,3,6,4]</span><br><span class="line">输出：5   </span><br><span class="line">在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        采用分治法求解</span></span><br><span class="line"><span class="string">        分为3种情况：</span></span><br><span class="line"><span class="string">        1） 前半段买入与卖出</span></span><br><span class="line"><span class="string">        2） 后半段买入与卖出</span></span><br><span class="line"><span class="string">        3） 前半段买入，后半段卖出</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">best</span>(<span class="params">prices</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(prices)==<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            mid = <span class="built_in">len</span>(prices)//<span class="number">2</span></span><br><span class="line">            former = prices[:mid]  <span class="comment"># 前半段股票</span></span><br><span class="line">            latter = prices[mid:]  <span class="comment"># 后半段股票</span></span><br><span class="line">            case3 = <span class="built_in">max</span>(latter) - <span class="built_in">min</span>(former)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(best(former), best(latter), case3)</span><br><span class="line">        <span class="keyword">return</span> best(prices)</span><br></pre></td></tr></table></figure><ul><li>MapReduce</li></ul><p>MapReduce 本质就是分治思想</p><p>一台机器过于低效，那我们就把任务拆分到多台机器上来处理。如果拆分之后的小任务之间互不干扰，独立计算，最后再将结果合并。这不就是分治思想吗?</p><p>尽管 MapReduce 的模型非常简单，但是在 Google 内部应用非常广泛。它除了可以用来处理这种数据 与数据之间存在关系的任务，比如 MapReduce 的经典例子，统计文件中单词出现的频率。除此之外， 它还可以用来处理数据与数据之间没有关系的任务，比如对网⻚分析、分词等，每个网⻚可以􏰂立的分 析、分词，而这两个网⻚之间并没有关系。网⻚几十亿、上百亿，如果单机处理，效率低下，我们就可 以利用 MapReduce 提供的高可靠、高性能、高容错的并行计算框架，并行地处理这几十亿、上百亿的 网⻚。</p><p>我们也时常感叹 Google 的创新能力如此之强，总是在引领技术的发展。实际上，创新并非离我们很 远，创新的源泉来自对事物本质的认识。无数优秀架构设计的思想来源都是基础的数据结构和算法，这 本身就是算法的一个魅力所在。</p><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><ul><li>一个模型三个特征</li></ul><p>“<strong>一个模型</strong>”， 它指的是动态规划适合解决的问题的模型，即 “<strong>多阶段决策最优解模型</strong>”。</p><p>我们一般是用动态规划来解决最优问题。而解决问题的过程，需要经历多个决策阶段。每个决策阶段都 对应着一组状态。然后我们寻找一组决策序列，经过这组决策序列，能够产生最终期望求解的最优值。</p><p>什么是“<strong>三个特征</strong>”?它们分别是<strong>最优子结构</strong>、<strong>无后效性</strong>和<strong>重复子问题</strong>。</p><ul><li>两种方法</li></ul><p><strong>状态转移表法：</strong></p><p>e.g. 最长公共子序列</p><p>比如，‘ABCBDAB’ 与 ‘BDCABA’ 的最长公共子序列：‘BCBA’</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gv46j4vhdtj61180e6gnf02.jpg" alt="image-20211005093111583"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lcs_length</span>(<span class="params">x,y</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;最长公共子序列&quot;&quot;&quot;</span></span><br><span class="line">    m = <span class="built_in">len</span>(x)</span><br><span class="line">    n = <span class="built_in">len</span>(y)</span><br><span class="line">    c = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m+<span class="number">1</span>)]  <span class="comment"># (m+1)行，（n+1）列</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,m+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> x[i-<span class="number">1</span>]==y[j-<span class="number">1</span>]:  <span class="comment"># 最后数值匹配，同时删除一个</span></span><br><span class="line">                c[i][j] = c[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                c[i][j] = <span class="built_in">max</span>(c[i-<span class="number">1</span>][j], c[i][j-<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> c:   <span class="comment"># 打印矩阵</span></span><br><span class="line">        <span class="built_in">print</span>(k)</span><br><span class="line">    <span class="keyword">return</span> c[m][n]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(lcs_length(<span class="string">&#x27;ABCBDAB&#x27;</span>, <span class="string">&#x27;BDCABA&#x27;</span>))</span><br><span class="line"></span><br><span class="line">[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>]</span><br><span class="line"><span class="number">4</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>方案输出</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lcs</span>(<span class="params">x,y</span>):</span></span><br><span class="line">    m = <span class="built_in">len</span>(x)</span><br><span class="line">    n =<span class="built_in">len</span>(y)</span><br><span class="line">    c = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>)]  <span class="comment"># (m+1)行，（n+1）列</span></span><br><span class="line">    arrow = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>)]  <span class="comment"># 记录箭头，1：左上方，2：上方，3：左方</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,m+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> x[i-<span class="number">1</span>]==y[j-<span class="number">1</span>]:  <span class="comment"># 最后数值匹配，同时删除一个</span></span><br><span class="line">                c[i][j] = c[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span></span><br><span class="line">                arrow[i][j] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># c[i][j] = max(c[i-1][j], c[i][j-1])</span></span><br><span class="line">                <span class="keyword">if</span> c[i-<span class="number">1</span>][j]&gt;c[i][j-<span class="number">1</span>]:  <span class="comment"># 来自上</span></span><br><span class="line">                    c[i][j] = c[i-<span class="number">1</span>][j]</span><br><span class="line">                    arrow[i][j] = <span class="number">2</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    c[i][j] = c[i][j-<span class="number">1</span>]</span><br><span class="line">                    arrow[i][j] = <span class="number">3</span></span><br><span class="line">    <span class="keyword">return</span> c[m][n], arrow</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lcs_trace_back</span>(<span class="params">x,y</span>):</span></span><br><span class="line">    c,arrow = lcs(x,y)</span><br><span class="line">    i = <span class="built_in">len</span>(x)</span><br><span class="line">    j =<span class="built_in">len</span>(y)</span><br><span class="line">    res =[]</span><br><span class="line">    <span class="keyword">while</span> i&gt;<span class="number">0</span> <span class="keyword">and</span> j&gt;<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> arrow[i][j]==<span class="number">1</span>:</span><br><span class="line">            res.append(x[i-<span class="number">1</span>])</span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> arrow[i][j]==<span class="number">2</span>:  <span class="comment"># 来自上方</span></span><br><span class="line">            i -=<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            j -=<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">reversed</span>(res)), c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(lcs_trace_back(<span class="string">&#x27;ABCBDAB&#x27;</span>, <span class="string">&#x27;BDCABA&#x27;</span>))</span><br><span class="line">(<span class="string">&#x27;BDAB&#x27;</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure><p><strong>状态转移方程法：</strong></p><p>e.g. 钢条切割</p><p>钢条长度与价格关系：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gv3myqgi5dj60w404c0t202.jpg" alt="image-20211004221412330"></p><blockquote><p>思路：</p></blockquote><p>下面代码从递归一步步进化到DP，注意体会：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">p = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">17</span>,<span class="number">17</span>,<span class="number">20</span>,<span class="number">24</span>,<span class="number">30</span>,<span class="number">32</span>,<span class="number">34</span>,<span class="number">35</span>,<span class="number">37</span>,<span class="number">40</span>,<span class="number">42</span>,<span class="number">45</span>,<span class="number">50</span>,<span class="number">51</span>,<span class="number">53</span>,<span class="number">54</span>,<span class="number">55</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;p长度：<span class="subst">&#123;<span class="built_in">len</span>(p)&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cut_rod_recursion</span>(<span class="params">p, n</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    递推公式： r_n = max(p_n, r1+r_&#123;n-1&#125;, r2+r_&#123;n-2&#125;, ..., r_&#123;n-1&#125;+r1)</span></span><br><span class="line"><span class="string">            r_n： 表示 长度n 的钢材的最优价格</span></span><br><span class="line"><span class="string">    :param p: 完整长度n 钢材对应的价格（不切割）</span></span><br><span class="line"><span class="string">    :param n:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> n==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        res = p[n]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">            res = <span class="built_in">max</span>(res, cut_rod_recursion(p, n-i)+cut_rod_recursion(p,i))</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="meta">@cal_time</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_cut_rod_recursion1</span>(<span class="params">p,n</span>):</span></span><br><span class="line">    <span class="keyword">return</span> cut_rod_recursion1(p,n)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cut_rod_recursion1</span>(<span class="params">p,n</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;递归改进递推公式</span></span><br><span class="line"><span class="string">    只切一侧，仍能够得到全部情况</span></span><br><span class="line"><span class="string">    递推公式：</span></span><br><span class="line"><span class="string">            r_n = max(p_n, r1+r_&#123;n-1&#125;, r2+r_&#123;n-2&#125;, ..., r_&#123;n-1&#125;+r1)</span></span><br><span class="line"><span class="string">    替换为：---&gt;</span></span><br><span class="line"><span class="string">            r_n = max(p_i+r_&#123;n-i&#125;), for i in [1,n]</span></span><br><span class="line"><span class="string">    复杂度：O(2^N)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> n==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        res= <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">            res = <span class="built_in">max</span>(res, p[i]+cut_rod_recursion1(p, n-i))</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@cal_time</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cut_rod_dp</span>(<span class="params">p,n</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;动态规划，自底向上</span></span><br><span class="line"><span class="string">    r_n = max(p_i+r_&#123;n-i&#125;), for i in [1,n]</span></span><br><span class="line"><span class="string">    复杂度：O(N*N)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    r = [<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">        res= <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, i+<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># i 对应 递推公式的 n</span></span><br><span class="line">            res = <span class="built_in">max</span>(res, p[j]+r[i-j])</span><br><span class="line">        r.append(res)</span><br><span class="line">    <span class="keyword">return</span> r[n]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(test_cut_rod_recursion1(p,<span class="number">20</span>))</span><br><span class="line"><span class="built_in">print</span>(cut_rod_dp(p,<span class="number">20</span>))</span><br><span class="line">------------------------------------</span><br><span class="line">p长度：<span class="number">23</span></span><br><span class="line">test_cut_rod_recursion1 running time：<span class="number">0.46545886993408203</span>secs</span><br><span class="line"><span class="number">60</span></span><br><span class="line">cut_rod_dp running time：<span class="number">5.078315734863281</span>e-05secs</span><br><span class="line"><span class="number">60</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>切割方案输出</p></blockquote><p>递推公式:<br>$$<br>r_n = max_{}(p_i+r_{n-i}),  1\leq i \leq n<br>$$<br>需要单独开一个s列表，记录最优解对应的不切割长度</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gv3pgvgz4qj311u08amyn.jpg" alt="image-20211004234050160"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">p = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">17</span>,<span class="number">17</span>,<span class="number">20</span>,<span class="number">21</span>,<span class="number">23</span>,<span class="number">24</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">27</span>,<span class="number">28</span>,<span class="number">30</span>,<span class="number">33</span>,<span class="number">36</span>,<span class="number">39</span>,<span class="number">40</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cut_rod_extend</span>(<span class="params">p,n</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;同时输出切分方案&quot;&quot;&quot;</span></span><br><span class="line">    r =[<span class="number">0</span>]</span><br><span class="line">    s = [<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">        res_r = <span class="number">0</span>  <span class="comment"># 价格最大值</span></span><br><span class="line">        res_s = <span class="number">0</span>  <span class="comment"># 价格最大值对应的方案的左边不切割 部分长度</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, i + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> p[j] + r[i - j]&gt;res_r:</span><br><span class="line">                res_r = p[j] + r[i - j]</span><br><span class="line">                res_s = j</span><br><span class="line">        r.append(res_r)</span><br><span class="line">        s.append(res_s)</span><br><span class="line">    <span class="keyword">return</span> r[n],s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cut_rod_solution</span>(<span class="params">p,n</span>):</span></span><br><span class="line">    <span class="comment"># 返回切割方案，以及最优价格 </span></span><br><span class="line">    r,s = cut_rod_extend(p,n)</span><br><span class="line">    ans = []  <span class="comment"># 切割方案存放</span></span><br><span class="line">    <span class="keyword">while</span> n&gt;<span class="number">0</span>:</span><br><span class="line">        ans.append(s[n])</span><br><span class="line">        n -= s[n]</span><br><span class="line">    <span class="keyword">return</span> ans, r, s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(cut_rod_solution(p, <span class="number">20</span>))</span><br><span class="line">([<span class="number">2</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>], <span class="number">56</span>, [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br></pre></td></tr></table></figure><p>​    </p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><p><a href="https://blog.fundebug.com/2018/08/27/code-interview-data-structure/">代码面试需要知道的8种数据结构(附面试题及答案链接)</a></p></li><li><p><a href="https://www.bilibili.com/video/BV1uA411N7c5?p=1">清华大学博士讲解Python数据结构与算法（完整版）全套100节</a><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gv18apj01qj61hy0u0dm402.jpg" alt="image-20200815171822878"></p></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/008eGmZEgy1gp84xlwx77j30u01tau05.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="编程" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>⭐️并发编程【未看完】</title>
    <link href="http://example.com/2021/03/25/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    <id>http://example.com/2021/03/25/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</id>
    <published>2021-03-24T16:00:00.000Z</published>
    <updated>2021-03-30T15:43:56.014Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="并发引入？"><a href="#并发引入？" class="headerlink" title="并发引入？"></a>并发引入？</h2><ul><li>提升程序运行速度</li><li>高级别+高薪必备</li></ul><h2 id="提速方法"><a href="#提速方法" class="headerlink" title="提速方法"></a>提速方法</h2><p><img src="https://i.loli.net/2021/03/28/DQof9OqpA1w62zv.png" alt="image-20210328164434462"></p><h2 id="python-中的支持"><a href="#python-中的支持" class="headerlink" title="python 中的支持"></a>python 中的支持</h2><p><img src="https://i.loli.net/2021/03/28/4QProBvHu5GXsFb.png" alt="image-20210328163529914"></p><ul><li>多线程Thread</li><li>多进程Process</li><li>多协程Coroutine</li></ul><h3 id="CPU-IO"><a href="#CPU-IO" class="headerlink" title="CPU/IO"></a>CPU/IO</h3><blockquote><p> CPU密集型（CPU-bound）</p></blockquote><p>任务的运行会受到CPU限制</p><p>也叫计算密集型，是指I/O在很短时间内就可以完成，CPU 需要大量的计算和处理，特点是CPU占有率相当高</p><p>如，压缩解压缩、加密解密、正则表达式搜索</p><blockquote><p>I/O密集型（I/O bound）</p></blockquote><p>指的是系统运作大部分状况是CPU在等I/O（磁盘）的读/写操作，CPU占有率低</p><p>如，文件处理程序、网络爬虫程序、读写数据库程序</p><h3 id="多线程、多进程、多协程对比"><a href="#多线程、多进程、多协程对比" class="headerlink" title="多线程、多进程、多协程对比"></a>多线程、多进程、多协程对比</h3><p><img src="https://i.loli.net/2021/03/28/3SWMluHdTJoNf89.png" alt="image-20210328171002727"></p><h3 id="python多进程、多线程模块"><a href="#python多进程、多线程模块" class="headerlink" title="python多进程、多线程模块"></a>python多进程、多线程模块</h3><ul><li>多进程</li></ul><p>不采用多进程</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time, sleep</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_task</span>(<span class="params">filename</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;开始下载%s...&#x27;</span> % filename)</span><br><span class="line">    time_to_download = randint(<span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line">    sleep(time_to_download)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s下载完成! 耗费了%d秒&#x27;</span> % (filename, time_to_download))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    start = time()</span><br><span class="line">    download_task(<span class="string">&#x27;Python从入门到住院.pdf&#x27;</span>)</span><br><span class="line">    download_task(<span class="string">&#x27;Peking Hot.avi&#x27;</span>)</span><br><span class="line">    end = time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;总共耗费了%.2f秒.&#x27;</span> % (end - start))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>更换为多进程：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> getpid</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time, sleep</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_task</span>(<span class="params">filename</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;启动下载进程，进程号[%d].&#x27;</span> % getpid())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;开始下载%s...&#x27;</span> % filename)</span><br><span class="line">    time_to_download = randint(<span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line">    sleep(time_to_download)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s下载完成! 耗费了%d秒&#x27;</span> % (filename, time_to_download))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    start = time()</span><br><span class="line">    p1 = Process(target=download_task, args=(<span class="string">&#x27;Python从入门到住院.pdf&#x27;</span>, ))</span><br><span class="line">    p1.start()</span><br><span class="line">    p2 = Process(target=download_task, args=(<span class="string">&#x27;Peking Hot.avi&#x27;</span>, ))</span><br><span class="line">    p2.start()  <span class="comment"># start方法用来启动进程</span></span><br><span class="line">    p1.join()    <span class="comment"># join方法表示等待进程执行结束</span></span><br><span class="line">    p2.join()</span><br><span class="line">    end = time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;总共耗费了%.2f秒.&#x27;</span> % (end - start))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><blockquote><p>我们也可以使用subprocess模块中的类和函数来创建和启动子进程，然后通过管道来和子进程通信，这些内容我们不在此进行讲解，有兴趣的读者可以自己了解这些知识。</p></blockquote><ul><li>多线程</li></ul><p>目前的多线程开发推荐使用threading模块</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time, sleep</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download</span>(<span class="params">filename</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;开始下载%s...&#x27;</span> % filename)</span><br><span class="line">    time_to_download = <span class="number">3</span></span><br><span class="line">    sleep(time_to_download)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s下载完成! 耗费了%d秒&#x27;</span> % (filename, time_to_download))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    start = time()</span><br><span class="line">    t1 = Thread(target=download, args=(<span class="string">&#x27;Python从入门到住院.pdf&#x27;</span>,))</span><br><span class="line">    t1.start()</span><br><span class="line">    t2 = Thread(target=download, args=(<span class="string">&#x27;Peking Hot.avi&#x27;</span>,))</span><br><span class="line">    t2.start()</span><br><span class="line">    t1.join()</span><br><span class="line">    t2.join()</span><br><span class="line">    end = time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;总共耗费了%.3f秒&#x27;</span> % (end - start))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>还可以通过继承<code>Thread</code>类的方式来创建自定义的线程类，然后再创建线程对象并启动线程</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time, sleep</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DownloadTask</span>(<span class="params">Thread</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, filename</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self._filename = filename</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;开始下载%s...&#x27;</span> % self._filename)</span><br><span class="line">        time_to_download = <span class="number">3</span></span><br><span class="line">        sleep(time_to_download)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s下载完成! 耗费了%d秒&#x27;</span> % (self._filename, time_to_download))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    start = time()</span><br><span class="line">    t1 = DownloadTask(<span class="string">&#x27;Python从入门到住院.pdf&#x27;</span>)</span><br><span class="line">    t1.start()</span><br><span class="line">    t2 = DownloadTask(<span class="string">&#x27;Peking Hot.avi&#x27;</span>)</span><br><span class="line">    t2.start()</span><br><span class="line">    t1.join()</span><br><span class="line">    t2.join()</span><br><span class="line">    end = time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;总共耗费了%.2f秒.&#x27;</span> % (end - start))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="如何选择技术"><a href="#如何选择技术" class="headerlink" title="如何选择技术"></a>如何选择技术</h3><p><img src="https://i.loli.net/2021/03/28/yM7DtzBcZkJNA4L.png" alt="image-20210328171157746"></p><h2 id="临界资源和锁"><a href="#临界资源和锁" class="headerlink" title="临界资源和锁"></a>临界资源和锁</h2><blockquote><p>临界资源</p></blockquote><p>因为多个线程可以共享进程的内存空间，因此要实现多个线程间的通信相对简单，大家能想到的最直接的办法就是设置一个全局变量，多个线程共享这个全局变量即可。但是当多个线程共享同一个变量（我们通常称之为“资源”）的时候，很有可能产生不可控的结果从而导致程序失效甚至崩溃。<u>如果一个资源被多个线程竞争使用，那么我们通常称之为“<strong>临界资源”</strong></u></p><p>对“临界资源”的访问需要加上保护，否则资源会处于“混乱”的状态。</p><p>e.g.</p><p>100个线程向同一个银行账户转账（转入1元钱）的场景，在这个例子中，<strong>银行账户就是一个临界资源</strong>，在没有保护的情况下我们很有可能会得到错误的结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self._balance = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deposit</span>(<span class="params">self, money</span>):</span></span><br><span class="line">        <span class="comment"># 计算存款后的余额</span></span><br><span class="line">        new_balance = self._balance + money</span><br><span class="line">        <span class="comment"># 模拟受理存款业务需要0.01秒的时间</span></span><br><span class="line">        sleep(<span class="number">0.01</span>)</span><br><span class="line">        <span class="comment"># 修改账户余额</span></span><br><span class="line">        self._balance = new_balance</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">balance</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._balance</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddMoneyThread</span>(<span class="params">Thread</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, account, money</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self._account = account</span><br><span class="line">        self._money = money</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        self._account.deposit(self._money)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    account = Account()</span><br><span class="line">    threads = []</span><br><span class="line">    <span class="comment"># 创建100个存款的线程向同一个账户中存钱</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">        t = AddMoneyThread(account, <span class="number">1</span>)</span><br><span class="line">        threads.append(t)</span><br><span class="line">        t.start()</span><br><span class="line">    <span class="comment"># 等所有存款的线程都执行完毕</span></span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">        t.join()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;账户余额为: ￥%d元&#x27;</span> % account.balance)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">账户余额为: ￥2元</span><br></pre></td></tr></table></figure><p>使用“锁”来保护对银行账户的操作，从而获得正确的结果:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread,Lock</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self._balance = <span class="number">0</span></span><br><span class="line">        self._lock = Lock()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deposit</span>(<span class="params">self, money</span>):</span></span><br><span class="line">        <span class="comment"># 先获取锁才能执行后续的代码</span></span><br><span class="line">        self._lock.acquire()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            new_balance = self._balance + money</span><br><span class="line">            sleep(<span class="number">0.01</span>)</span><br><span class="line">            self._balance = new_balance</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            <span class="comment"># 在finally中执行释放锁的操作保证正常异常锁都能释放</span></span><br><span class="line">            self._lock.release()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">balance</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._balance</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">账户余额为: ￥100元</span><br></pre></td></tr></table></figure><p>更多例子，参见：<a href="https://github.com/jackfrued/Python-100-Days/blob/master/Day01-15/13.%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B.md">进程和线程之应用案例</a></p><blockquote><p>例子1：将耗时间的任务放到线程中以获得更好的用户体验。</p></blockquote><blockquote><p>例子2：使用多进程对复杂任务进行“分而治之”。</p></blockquote><h2 id="python-GIL"><a href="#python-GIL" class="headerlink" title="python GIL"></a>python GIL</h2><h3 id="Python-为何慢"><a href="#Python-为何慢" class="headerlink" title="Python 为何慢"></a>Python 为何慢</h3><ul><li>动态类型语言，边解释边执行</li><li>GIL</li></ul><h3 id="GIL"><a href="#GIL" class="headerlink" title="GIL"></a>GIL</h3><p><img src="https://i.loli.net/2021/03/28/TXYwu8inc6Pbv1Z.png" alt="image-20210328175254300"></p><p><a href="https://www.dabeaz.com/python/UnderstandingGIL.pdf">https://www.dabeaz.com/python/UnderstandingGIL.pdf</a></p><h3 id="为何有GIL-？"><a href="#为何有GIL-？" class="headerlink" title="为何有GIL ？"></a>为何有GIL ？</h3><p><img src="https://i.loli.net/2021/03/28/HEBg5n4ok87VwWG.png" alt="image-20210328180022551"></p><h3 id="如何规避GIL"><a href="#如何规避GIL" class="headerlink" title="如何规避GIL?"></a>如何规避GIL?</h3><p><img src="https://i.loli.net/2021/03/30/JvMTSi9gwDoZmkR.png" alt="image-20210328180242946"></p><h2 id="多线程举例：爬虫"><a href="#多线程举例：爬虫" class="headerlink" title="多线程举例：爬虫"></a>多线程举例：爬虫</h2><ul><li>创建多线程</li></ul><p><img src="https://i.loli.net/2021/03/28/jVCh4HpUBdstmuo.png" alt="image-20210328185755984"></p><p>代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">@Time : 2021/3/28 7:07 下午</span></span><br><span class="line"><span class="string">@Author : Dufy</span></span><br><span class="line"><span class="string">@Email : 813540660@qq.com</span></span><br><span class="line"><span class="string">@File : multi-thread-crawl.py</span></span><br><span class="line"><span class="string">@Software: PyCharm </span></span><br><span class="line"><span class="string">Description :</span></span><br><span class="line"><span class="string">1) 多线程网页加速效果展示</span></span><br><span class="line"><span class="string">2)       </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">urls = [<span class="string">f&quot;https://www.cnblogs.com/#p<span class="subst">&#123;i&#125;</span>&quot;</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">50</span>+<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crawl</span>(<span class="params">url</span>):</span></span><br><span class="line">    r= requests.get(url)</span><br><span class="line">    <span class="built_in">print</span>(url, <span class="built_in">len</span>(r.text))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">single_thread</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;single thread begin&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line">        crawl(url)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;single thread end!!&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multi_thread</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;多线程&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;multi thread begin&quot;</span>)</span><br><span class="line">    threads = []</span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line">        threads.append(</span><br><span class="line">            threading.Thread(target=crawl, args=(url,))</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">for</span> thread <span class="keyword">in</span> threads:</span><br><span class="line">        thread.start()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> thread <span class="keyword">in</span> threads:</span><br><span class="line">        thread.join()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;multi thread end&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">    start = time.time()</span><br><span class="line">    single_thread()</span><br><span class="line">    end = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;单线程花费：<span class="subst">&#123;end-start&#125;</span> s&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    start = time.time()</span><br><span class="line">    multi_thread()</span><br><span class="line">    end = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;多线程花费：<span class="subst">&#123;end - start&#125;</span> s&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>单线程花费：8.063177108764648 s</p><p>多线程花费：0.9351308345794678 s</p><h2 id="生产者-消费者模式的多线程爬虫"><a href="#生产者-消费者模式的多线程爬虫" class="headerlink" title="生产者-消费者模式的多线程爬虫"></a>生产者-消费者模式的多线程爬虫</h2><h3 id="多组件的Pipeline技术架构"><a href="#多组件的Pipeline技术架构" class="headerlink" title="多组件的Pipeline技术架构"></a>多组件的Pipeline技术架构</h3><p>复杂 的事情一般都不会一下子做完，而是会分很多中间步骤一步步完成</p><p><img src="https://i.loli.net/2021/03/28/IaHfnRpmYDhkAVX.png" alt="image-20210328193156516"></p><h3 id="生产者-消费者爬虫架构"><a href="#生产者-消费者爬虫架构" class="headerlink" title="生产者-消费者爬虫架构"></a>生产者-消费者爬虫架构</h3><p><img src="https://i.loli.net/2021/03/30/fvC54j1qVMY3HTB.png" alt="image-20210328193514491"></p><h3 id="多线程数据通信-queue-Queue"><a href="#多线程数据通信-queue-Queue" class="headerlink" title="多线程数据通信 queue.Queue"></a>多线程数据通信 <code>queue.Queue</code></h3><p><img src="https://i.loli.net/2021/03/28/QiT7xXMBcEFSydW.png" alt="image-20210328194115592"></p><ul><li>post 方法：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">@Time : 2021/3/28 7:07 下午</span></span><br><span class="line"><span class="string">@Author : Dufy</span></span><br><span class="line"><span class="string">@Email : 813540660@qq.com</span></span><br><span class="line"><span class="string">@File : blog_crawl.py</span></span><br><span class="line"><span class="string">@Software: PyCharm </span></span><br><span class="line"><span class="string">Description :</span></span><br><span class="line"><span class="string">1) 基础版本展示</span></span><br><span class="line"><span class="string">2) post 方法 抓包</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># payload = &#123;&quot;CategoryType&quot;:&quot;SiteHome&quot;,&quot;ParentCategoryId&quot;:0,&quot;CategoryId&quot;:808,&quot;PageIndex&quot;:3,&quot;TotalPostCount&quot;:4000,&quot;ItemListActionName&quot;:&quot;AggSitePostList&quot;&#125;</span></span><br><span class="line">header = &#123;<span class="string">&#x27;accept&#x27;</span>: <span class="string">&#x27;text/plain, */*; q=0.01&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;accept-encoding&#x27;</span>: <span class="string">&#x27;gzip, deflate, br&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;accept-language&#x27;</span>: <span class="string">&#x27;zh-CN,zh;q=0.9,en;q=0.8&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;content-type&#x27;</span>: <span class="string">&#x27;application/json; charset=UTF-8&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;origin&#x27;</span>: <span class="string">&#x27;https://www.cnblogs.com&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;referer&#x27;</span>: <span class="string">&#x27;https://www.cnblogs.com/&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;user-agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.82, Safari/537.36&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;x-requested-with&#x27;</span>: <span class="string">&#x27;XMLHttpRequest&#x27;</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crawl</span>(<span class="params">url, page_index</span>):</span></span><br><span class="line">    r= requests.post(url,</span><br><span class="line">                     data = json.dumps(&#123;<span class="string">&quot;CategoryType&quot;</span>:<span class="string">&quot;SiteHome&quot;</span>,<span class="string">&quot;ParentCategoryId&quot;</span>:<span class="number">0</span>,<span class="string">&quot;CategoryId&quot;</span>:<span class="number">808</span>,<span class="string">&quot;PageIndex&quot;</span>:page_index,<span class="string">&quot;TotalPostCount&quot;</span>:<span class="number">4000</span>,<span class="string">&quot;ItemListActionName&quot;</span>:<span class="string">&quot;AggSitePostList&quot;</span>&#125;),</span><br><span class="line">                     headers = header)</span><br><span class="line">    <span class="comment"># print(r.text)</span></span><br><span class="line">    <span class="keyword">return</span> r.text</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse</span>(<span class="params">html</span>):</span></span><br><span class="line">    <span class="comment"># class =&quot;post-item-title&quot;</span></span><br><span class="line">    soup =  BeautifulSoup(html, <span class="string">&quot;html.parser&quot;</span>)</span><br><span class="line">    links = soup.find_all(<span class="string">&quot;a&quot;</span>, class_ =<span class="string">&quot;post-item-title&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> [(link[<span class="string">&#x27;href&#x27;</span>], link.get_text())<span class="keyword">for</span> link <span class="keyword">in</span> links]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    page_index = <span class="number">10</span></span><br><span class="line">    <span class="keyword">for</span> result <span class="keyword">in</span> parse(crawl(<span class="string">&#x27;https://www.cnblogs.com/AggSite/AggSitePostList&#x27;</span>, page_index)):</span><br><span class="line">        <span class="built_in">print</span>(result)</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p><code> links = soup.find_all(&quot;a&quot;, class_ =&quot;post-item-title&quot;)</code>来自于：</p></blockquote><p><img src="https://i.loli.net/2021/03/30/kAzKRuQPDY82JM6.png" alt="image-20210328194837397"></p><p>代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">@Time : 2021/3/29 9:58 下午</span></span><br><span class="line"><span class="string">@Author : Dufy</span></span><br><span class="line"><span class="string">@Email : 813540660@qq.com</span></span><br><span class="line"><span class="string">@File : producer-consumer-spider.py</span></span><br><span class="line"><span class="string">@Software: PyCharm </span></span><br><span class="line"><span class="string">Description :</span></span><br><span class="line"><span class="string">1)  生产者、消费者模式爬虫</span></span><br><span class="line"><span class="string">2)       </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"><span class="keyword">import</span> blog_crawl</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">url  =<span class="string">&#x27;https://www.cnblogs.com/AggSite/AggSitePostList&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_crawl</span>(<span class="params">url_queue:queue.Queue, html_queue:queue.Queue</span>):</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        index = url_queue.get()</span><br><span class="line">        html = blog_crawl.crawl(url,index)</span><br><span class="line">        html_queue.put(html)</span><br><span class="line">        <span class="built_in">print</span>(threading.current_thread().name, <span class="string">f&#x27;crawl<span class="subst">&#123;url&#125;</span>&#x27;</span>,</span><br><span class="line">              <span class="string">&#x27;url_queue.size=&#x27;</span>, url_queue.qsize())</span><br><span class="line">        time.sleep(random.randint(<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_parse</span>(<span class="params">html_queue:queue.Queue, fout</span>):</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        html = html_queue.get()</span><br><span class="line">        results = blog_crawl.parse(html)</span><br><span class="line">        <span class="keyword">for</span> result <span class="keyword">in</span> results:</span><br><span class="line">            fout.write(<span class="built_in">str</span>(result)+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(threading.current_thread().name, <span class="string">f&#x27;results.size&#x27;</span>, <span class="built_in">len</span>(results),</span><br><span class="line">                  <span class="string">&#x27;html_queue.size=&#x27;</span>, html_queue.qsize())</span><br><span class="line">        time.sleep(random.randint(<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">    url_queue = queue.Queue()</span><br><span class="line">    html_queue = queue.Queue()</span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">15</span>):</span><br><span class="line">        url_queue.put(index)</span><br><span class="line">    <span class="keyword">for</span> thread_num <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):  <span class="comment"># 生产者线程</span></span><br><span class="line">        t = threading.Thread(target=do_crawl,</span><br><span class="line">                             args=(url_queue, html_queue),</span><br><span class="line">                             name=<span class="string">f&#x27;crawl<span class="subst">&#123;thread_num&#125;</span>&#x27;</span>)</span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line">    fout = <span class="built_in">open</span>(<span class="string">&#x27;data.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)  <span class="comment"># 文件输出</span></span><br><span class="line">    <span class="keyword">for</span> thread_num <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>): <span class="comment"># 消费者线程</span></span><br><span class="line">        t = threading.Thread(target=do_parse,</span><br><span class="line">                             args=(html_queue, fout),</span><br><span class="line">                             name=<span class="string">f&#x27;parse<span class="subst">&#123;thread_num&#125;</span>&#x27;</span>)</span><br><span class="line">        t.start()</span><br></pre></td></tr></table></figure><p>结果写到 data.txt中</p><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>…..</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://www.bilibili.com/video/BV1bK411A7tV?p=6&spm_id_from=pageDriver">【2021最新版】Python 并发编程实战，用多线程、多进程、多协程加速程序运行</a><img src="https://i.loli.net/2021/03/30/6MqJLlXFEh5yYKR.png" alt="image-20210330220406017"></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;



&lt;h2 id=&quot;并发引入？&quot;&gt;&lt;a href=&quot;#并发引入？&quot; class=&quot;headerlink&quot; title=&quot;并发引入？&quot;&gt;&lt;/a&gt;并发引入？&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;提升程序运行速度&lt;/li&gt;
&lt;li&gt;高级别+高薪必</summary>
      
    
    
    
    <category term="编程" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>⭐️趣代码</title>
    <link href="http://example.com/2021/03/08/%E8%B6%A3%E4%BB%A3%E7%A0%81/"/>
    <id>http://example.com/2021/03/08/%E8%B6%A3%E4%BB%A3%E7%A0%81/</id>
    <published>2021-03-07T16:00:00.000Z</published>
    <updated>2021-05-10T15:36:21.169Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="python-小猪佩奇"><a href="#python-小猪佩奇" class="headerlink" title="python 小猪佩奇"></a>python 小猪佩奇</h2><blockquote><p><strong>说明</strong>：turtle是Python内置的一个非常有趣的模块，特别适合对计算机程序设计进行初体验的小伙伴，它最早是Logo语言的一部分，Logo语言是Wally Feurzig和Seymour Papert在1966发明的编程语言。</p></blockquote><p><img src="https://i.loli.net/2021/03/16/tYQwvuh32AMgrX6.png" alt="image-20210316232155572"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"><span class="keyword">import</span> turtle <span class="keyword">as</span> t</span><br><span class="line">t.pensize(<span class="number">4</span>) <span class="comment"># 设置画笔的大小</span></span><br><span class="line">t.colormode(<span class="number">255</span>) <span class="comment"># 设置GBK颜色范围为0-255</span></span><br><span class="line">t.color((<span class="number">255</span>,<span class="number">155</span>,<span class="number">192</span>),<span class="string">&quot;pink&quot;</span>) <span class="comment"># 设置画笔颜色和填充颜色(pink)</span></span><br><span class="line">t.setup(<span class="number">840</span>,<span class="number">500</span>) <span class="comment"># 设置主窗口的大小为840*500</span></span><br><span class="line">t.speed(<span class="number">10</span>) <span class="comment"># 设置画笔速度为10</span></span><br><span class="line"><span class="comment">#鼻子</span></span><br><span class="line">t.pu() <span class="comment"># 提笔</span></span><br><span class="line">t.goto(-<span class="number">100</span>,<span class="number">100</span>) <span class="comment"># 画笔前往坐标(-100,100)</span></span><br><span class="line">t.pd() <span class="comment"># 下笔</span></span><br><span class="line">t.seth(-<span class="number">30</span>) <span class="comment"># 笔的角度为-30°</span></span><br><span class="line">t.begin_fill() <span class="comment"># 外形填充的开始标志</span></span><br><span class="line">a=<span class="number">0.4</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">120</span>):</span><br><span class="line">   <span class="keyword">if</span> <span class="number">0</span>&lt;=i&lt;<span class="number">30</span> <span class="keyword">or</span> <span class="number">60</span>&lt;=i&lt;<span class="number">90</span>:</span><br><span class="line">       a=a+<span class="number">0.08</span></span><br><span class="line">       t.lt(<span class="number">3</span>) <span class="comment">#向左转3度</span></span><br><span class="line">       t.fd(a) <span class="comment">#向前走a的步长</span></span><br><span class="line">   <span class="keyword">else</span>:</span><br><span class="line">       a=a-<span class="number">0.08</span></span><br><span class="line">       t.lt(<span class="number">3</span>)</span><br><span class="line">       t.fd(a)</span><br><span class="line">t.end_fill() <span class="comment"># 依据轮廓填充</span></span><br><span class="line">t.pu() <span class="comment"># 提笔</span></span><br><span class="line">t.seth(<span class="number">90</span>) <span class="comment"># 笔的角度为90度</span></span><br><span class="line">t.fd(<span class="number">25</span>) <span class="comment"># 向前移动25</span></span><br><span class="line">t.seth(<span class="number">0</span>) <span class="comment"># 转换画笔的角度为0</span></span><br><span class="line">t.fd(<span class="number">10</span>)</span><br><span class="line">t.pd()</span><br><span class="line">t.pencolor(<span class="number">255</span>,<span class="number">155</span>,<span class="number">192</span>) <span class="comment"># 设置画笔颜色</span></span><br><span class="line">t.seth(<span class="number">10</span>)</span><br><span class="line">t.begin_fill()</span><br><span class="line">t.circle(<span class="number">5</span>) <span class="comment"># 画一个半径为5的圆</span></span><br><span class="line">t.color(<span class="number">160</span>,<span class="number">82</span>,<span class="number">45</span>) <span class="comment"># 设置画笔和填充颜色</span></span><br><span class="line">t.end_fill()</span><br><span class="line">t.pu()</span><br><span class="line">t.seth(<span class="number">0</span>)</span><br><span class="line">t.fd(<span class="number">20</span>)</span><br><span class="line">t.pd()</span><br><span class="line">t.pencolor(<span class="number">255</span>,<span class="number">155</span>,<span class="number">192</span>)</span><br><span class="line">t.seth(<span class="number">10</span>)</span><br><span class="line">t.begin_fill()</span><br><span class="line">t.circle(<span class="number">5</span>)</span><br><span class="line">t.color(<span class="number">160</span>,<span class="number">82</span>,<span class="number">45</span>)</span><br><span class="line">t.end_fill()</span><br><span class="line"><span class="comment">#头</span></span><br><span class="line">t.color((<span class="number">255</span>,<span class="number">155</span>,<span class="number">192</span>),<span class="string">&quot;pink&quot;</span>)</span><br><span class="line">t.pu()</span><br><span class="line">t.seth(<span class="number">90</span>)</span><br><span class="line">t.fd(<span class="number">41</span>)</span><br><span class="line">t.seth(<span class="number">0</span>)</span><br><span class="line">t.fd(<span class="number">0</span>)</span><br><span class="line">t.pd()</span><br><span class="line">t.begin_fill()</span><br><span class="line">t.seth(<span class="number">180</span>)</span><br><span class="line">t.circle(<span class="number">300</span>,-<span class="number">30</span>) <span class="comment"># 顺时针画一个半径为300,圆心角为30°的园</span></span><br><span class="line">t.circle(<span class="number">100</span>,-<span class="number">60</span>)</span><br><span class="line">t.circle(<span class="number">80</span>,-<span class="number">100</span>)</span><br><span class="line">t.circle(<span class="number">150</span>,-<span class="number">20</span>)</span><br><span class="line">t.circle(<span class="number">60</span>,-<span class="number">95</span>)</span><br><span class="line">t.seth(<span class="number">161</span>)</span><br><span class="line">t.circle(-<span class="number">300</span>,<span class="number">15</span>)</span><br><span class="line">t.pu()</span><br><span class="line">t.goto(-<span class="number">100</span>,<span class="number">100</span>)</span><br><span class="line">t.pd()</span><br><span class="line">t.seth(-<span class="number">30</span>)</span><br><span class="line">a=<span class="number">0.4</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">60</span>):</span><br><span class="line">   <span class="keyword">if</span> <span class="number">0</span>&lt;=i&lt;<span class="number">30</span> <span class="keyword">or</span> <span class="number">60</span>&lt;=i&lt;<span class="number">90</span>:</span><br><span class="line">       a=a+<span class="number">0.08</span></span><br><span class="line">       t.lt(<span class="number">3</span>) <span class="comment">#向左转3度</span></span><br><span class="line">       t.fd(a) <span class="comment">#向前走a的步长</span></span><br><span class="line">   <span class="keyword">else</span>:</span><br><span class="line">       a=a-<span class="number">0.08</span></span><br><span class="line">       t.lt(<span class="number">3</span>)</span><br><span class="line">       t.fd(a)</span><br><span class="line">t.end_fill()</span><br><span class="line"><span class="comment">#耳朵</span></span><br><span class="line">t.color((<span class="number">255</span>,<span class="number">155</span>,<span class="number">192</span>),<span class="string">&quot;pink&quot;</span>)</span><br><span class="line">t.pu()</span><br><span class="line">t.seth(<span class="number">90</span>)</span><br><span class="line">t.fd(-<span class="number">7</span>)</span><br><span class="line">t.seth(<span class="number">0</span>)</span><br><span class="line">t.fd(<span class="number">70</span>)</span><br><span class="line">t.pd()</span><br><span class="line">t.begin_fill()</span><br><span class="line">t.seth(<span class="number">100</span>)</span><br><span class="line">t.circle(-<span class="number">50</span>,<span class="number">50</span>)</span><br><span class="line">t.circle(-<span class="number">10</span>,<span class="number">120</span>)</span><br><span class="line">t.circle(-<span class="number">50</span>,<span class="number">54</span>)</span><br><span class="line">t.end_fill()</span><br><span class="line">t.pu()</span><br><span class="line">t.seth(<span class="number">90</span>)</span><br><span class="line">t.fd(-<span class="number">12</span>)</span><br><span class="line">t.seth(<span class="number">0</span>)</span><br><span class="line">t.fd(<span class="number">30</span>)</span><br><span class="line">t.pd()</span><br><span class="line">t.begin_fill()</span><br><span class="line">t.seth(<span class="number">100</span>)</span><br><span class="line">t.circle(-<span class="number">50</span>,<span class="number">50</span>)</span><br><span class="line">t.circle(-<span class="number">10</span>,<span class="number">120</span>)</span><br><span class="line">t.circle(-<span class="number">50</span>,<span class="number">56</span>)</span><br><span class="line">t.end_fill()</span><br><span class="line"><span class="comment">#眼睛</span></span><br><span class="line">t.color((<span class="number">255</span>,<span class="number">155</span>,<span class="number">192</span>),<span class="string">&quot;white&quot;</span>)</span><br><span class="line">t.pu()</span><br><span class="line">t.seth(<span class="number">90</span>)</span><br><span class="line">t.fd(-<span class="number">20</span>)</span><br><span class="line">t.seth(<span class="number">0</span>)</span><br><span class="line">t.fd(-<span class="number">95</span>)</span><br><span class="line">t.pd()</span><br><span class="line">t.begin_fill()</span><br><span class="line">t.circle(<span class="number">15</span>)</span><br><span class="line">t.end_fill()</span><br><span class="line">t.color(<span class="string">&quot;black&quot;</span>)</span><br><span class="line">t.pu()</span><br><span class="line">t.seth(<span class="number">90</span>)</span><br><span class="line">t.fd(<span class="number">12</span>)</span><br><span class="line">t.seth(<span class="number">0</span>)</span><br><span class="line">t.fd(-<span class="number">3</span>)</span><br><span class="line">t.pd()</span><br><span class="line">t.begin_fill()</span><br><span class="line">t.circle(<span class="number">3</span>)</span><br><span class="line">t.end_fill()</span><br><span class="line">t.color((<span class="number">255</span>,<span class="number">155</span>,<span class="number">192</span>),<span class="string">&quot;white&quot;</span>)</span><br><span class="line">t.pu()</span><br><span class="line">t.seth(<span class="number">90</span>)</span><br><span class="line">t.fd(-<span class="number">25</span>)</span><br><span class="line">t.seth(<span class="number">0</span>)</span><br><span class="line">t.fd(<span class="number">40</span>)</span><br><span class="line">t.pd()</span><br><span class="line">t.begin_fill()</span><br><span class="line">t.circle(<span class="number">15</span>)</span><br><span class="line">t.end_fill()</span><br><span class="line">t.color(<span class="string">&quot;black&quot;</span>)</span><br><span class="line">t.pu()</span><br><span class="line">t.seth(<span class="number">90</span>)</span><br><span class="line">t.fd(<span class="number">12</span>)</span><br><span class="line">t.seth(<span class="number">0</span>)</span><br><span class="line">t.fd(-<span class="number">3</span>)</span><br><span class="line">t.pd()</span><br><span class="line">t.begin_fill()</span><br><span class="line">t.circle(<span class="number">3</span>)</span><br><span class="line">t.end_fill()</span><br><span class="line"><span class="comment">#腮</span></span><br><span class="line">t.color((<span class="number">255</span>,<span class="number">155</span>,<span class="number">192</span>))</span><br><span class="line">t.pu()</span><br><span class="line">t.seth(<span class="number">90</span>)</span><br><span class="line">t.fd(-<span class="number">95</span>)</span><br><span class="line">t.seth(<span class="number">0</span>)</span><br><span class="line">t.fd(<span class="number">65</span>)</span><br><span class="line">t.pd()</span><br><span class="line">t.begin_fill()</span><br><span class="line">t.circle(<span class="number">30</span>)</span><br><span class="line">t.end_fill()</span><br><span class="line"><span class="comment">#嘴</span></span><br><span class="line">t.color(<span class="number">239</span>,<span class="number">69</span>,<span class="number">19</span>)</span><br><span class="line">t.pu()</span><br><span class="line">t.seth(<span class="number">90</span>)</span><br><span class="line">t.fd(<span class="number">15</span>)</span><br><span class="line">t.seth(<span class="number">0</span>)</span><br><span class="line">t.fd(-<span class="number">100</span>)</span><br><span class="line">t.pd()</span><br><span class="line">t.seth(-<span class="number">80</span>)</span><br><span class="line">t.circle(<span class="number">30</span>,<span class="number">40</span>)</span><br><span class="line">t.circle(<span class="number">40</span>,<span class="number">80</span>)</span><br><span class="line"><span class="comment">#身体</span></span><br><span class="line">t.color(<span class="string">&quot;red&quot;</span>,(<span class="number">255</span>,<span class="number">99</span>,<span class="number">71</span>))</span><br><span class="line">t.pu()</span><br><span class="line">t.seth(<span class="number">90</span>)</span><br><span class="line">t.fd(-<span class="number">20</span>)</span><br><span class="line">t.seth(<span class="number">0</span>)</span><br><span class="line">t.fd(-<span class="number">78</span>)</span><br><span class="line">t.pd()</span><br><span class="line">t.begin_fill()</span><br><span class="line">t.seth(-<span class="number">130</span>)</span><br><span class="line">t.circle(<span class="number">100</span>,<span class="number">10</span>)</span><br><span class="line">t.circle(<span class="number">300</span>,<span class="number">30</span>)</span><br><span class="line">t.seth(<span class="number">0</span>)</span><br><span class="line">t.fd(<span class="number">230</span>)</span><br><span class="line">t.seth(<span class="number">90</span>)</span><br><span class="line">t.circle(<span class="number">300</span>,<span class="number">30</span>)</span><br><span class="line">t.circle(<span class="number">100</span>,<span class="number">3</span>)</span><br><span class="line">t.color((<span class="number">255</span>,<span class="number">155</span>,<span class="number">192</span>),(<span class="number">255</span>,<span class="number">100</span>,<span class="number">100</span>))</span><br><span class="line">t.seth(-<span class="number">135</span>)</span><br><span class="line">t.circle(-<span class="number">80</span>,<span class="number">63</span>)</span><br><span class="line">t.circle(-<span class="number">150</span>,<span class="number">24</span>)</span><br><span class="line">t.end_fill()</span><br><span class="line"><span class="comment">#手</span></span><br><span class="line">t.color((<span class="number">255</span>,<span class="number">155</span>,<span class="number">192</span>))</span><br><span class="line">t.pu()</span><br><span class="line">t.seth(<span class="number">90</span>)</span><br><span class="line">t.fd(-<span class="number">40</span>)</span><br><span class="line">t.seth(<span class="number">0</span>)</span><br><span class="line">t.fd(-<span class="number">27</span>)</span><br><span class="line">t.pd()</span><br><span class="line">t.seth(-<span class="number">160</span>)</span><br><span class="line">t.circle(<span class="number">300</span>,<span class="number">15</span>)</span><br><span class="line">t.pu()</span><br><span class="line">t.seth(<span class="number">90</span>)</span><br><span class="line">t.fd(<span class="number">15</span>)</span><br><span class="line">t.seth(<span class="number">0</span>)</span><br><span class="line">t.fd(<span class="number">0</span>)</span><br><span class="line">t.pd()</span><br><span class="line">t.seth(-<span class="number">10</span>)</span><br><span class="line">t.circle(-<span class="number">20</span>,<span class="number">90</span>)</span><br><span class="line">t.pu()</span><br><span class="line">t.seth(<span class="number">90</span>)</span><br><span class="line">t.fd(<span class="number">30</span>)</span><br><span class="line">t.seth(<span class="number">0</span>)</span><br><span class="line">t.fd(<span class="number">237</span>)</span><br><span class="line">t.pd()</span><br><span class="line">t.seth(-<span class="number">20</span>)</span><br><span class="line">t.circle(-<span class="number">300</span>,<span class="number">15</span>)</span><br><span class="line">t.pu()</span><br><span class="line">t.seth(<span class="number">90</span>)</span><br><span class="line">t.fd(<span class="number">20</span>)</span><br><span class="line">t.seth(<span class="number">0</span>)</span><br><span class="line">t.fd(<span class="number">0</span>)</span><br><span class="line">t.pd()</span><br><span class="line">t.seth(-<span class="number">170</span>)</span><br><span class="line">t.circle(<span class="number">20</span>,<span class="number">90</span>)</span><br><span class="line"><span class="comment">#脚</span></span><br><span class="line">t.pensize(<span class="number">10</span>)</span><br><span class="line">t.color((<span class="number">240</span>,<span class="number">128</span>,<span class="number">128</span>))</span><br><span class="line">t.pu()</span><br><span class="line">t.seth(<span class="number">90</span>)</span><br><span class="line">t.fd(-<span class="number">75</span>)</span><br><span class="line">t.seth(<span class="number">0</span>)</span><br><span class="line">t.fd(-<span class="number">180</span>)</span><br><span class="line">t.pd()</span><br><span class="line">t.seth(-<span class="number">90</span>)</span><br><span class="line">t.fd(<span class="number">40</span>)</span><br><span class="line">t.seth(-<span class="number">180</span>)</span><br><span class="line">t.color(<span class="string">&quot;black&quot;</span>)</span><br><span class="line">t.pensize(<span class="number">15</span>)</span><br><span class="line">t.fd(<span class="number">20</span>)</span><br><span class="line">t.pensize(<span class="number">10</span>)</span><br><span class="line">t.color((<span class="number">240</span>,<span class="number">128</span>,<span class="number">128</span>))</span><br><span class="line">t.pu()</span><br><span class="line">t.seth(<span class="number">90</span>)</span><br><span class="line">t.fd(<span class="number">40</span>)</span><br><span class="line">t.seth(<span class="number">0</span>)</span><br><span class="line">t.fd(<span class="number">90</span>)</span><br><span class="line">t.pd()</span><br><span class="line">t.seth(-<span class="number">90</span>)</span><br><span class="line">t.fd(<span class="number">40</span>)</span><br><span class="line">t.seth(-<span class="number">180</span>)</span><br><span class="line">t.color(<span class="string">&quot;black&quot;</span>)</span><br><span class="line">t.pensize(<span class="number">15</span>)</span><br><span class="line">t.fd(<span class="number">20</span>)</span><br><span class="line"><span class="comment">#尾巴</span></span><br><span class="line">t.pensize(<span class="number">4</span>)</span><br><span class="line">t.color((<span class="number">255</span>,<span class="number">155</span>,<span class="number">192</span>))</span><br><span class="line">t.pu()</span><br><span class="line">t.seth(<span class="number">90</span>)</span><br><span class="line">t.fd(<span class="number">70</span>)</span><br><span class="line">t.seth(<span class="number">0</span>)</span><br><span class="line">t.fd(<span class="number">95</span>)</span><br><span class="line">t.pd()</span><br><span class="line">t.seth(<span class="number">0</span>)</span><br><span class="line">t.circle(<span class="number">70</span>,<span class="number">20</span>)</span><br><span class="line">t.circle(<span class="number">10</span>,<span class="number">330</span>)</span><br><span class="line">t.circle(<span class="number">70</span>,<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line">t.mainloop()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="跑马灯"><a href="#跑马灯" class="headerlink" title="跑马灯"></a>跑马灯</h2><p>在屏幕上显示跑马灯文字</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    content = <span class="string">&#x27;北京欢迎你为你开天辟地…………&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 清理屏幕上的输出</span></span><br><span class="line">        os.system(<span class="string">&#x27;cls&#x27;</span>)  <span class="comment"># os.system(&#x27;clear&#x27;)</span></span><br><span class="line">        <span class="built_in">print</span>(content)</span><br><span class="line">        <span class="comment"># 休眠200毫秒</span></span><br><span class="line">        time.sleep(<span class="number">0.2</span>)</span><br><span class="line">        content = content[<span class="number">1</span>:] + content[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">北京欢迎你为你开天辟地…………</span><br><span class="line">京欢迎你为你开天辟地…………北</span><br><span class="line">欢迎你为你开天辟地…………北京</span><br><span class="line">迎你为你开天辟地…………北京欢</span><br><span class="line">你为你开天辟地…………北京欢迎</span><br><span class="line">为你开天辟地…………北京欢迎你</span><br><span class="line">你开天辟地…………北京欢迎你为</span><br><span class="line">开天辟地…………北京欢迎你为你</span><br><span class="line">天辟地…………北京欢迎你为你开</span><br><span class="line">辟地…………北京欢迎你为你开天</span><br><span class="line">地…………北京欢迎你为你开天辟</span><br><span class="line">…………北京欢迎你为你开天辟地</span><br><span class="line">………北京欢迎你为你开天辟地…</span><br><span class="line">……北京欢迎你为你开天辟地……</span><br><span class="line">…北京欢迎你为你开天辟地………</span><br></pre></td></tr></table></figure><h2 id="产生验证码"><a href="#产生验证码" class="headerlink" title="产生验证码"></a>产生验证码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_code</span>(<span class="params">code_len=<span class="number">4</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    生成指定长度的验证码</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param code_len: 验证码的长度(默认4个字符)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :return: 由大小写英文字母和数字构成的随机验证码</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    all_chars = <span class="string">&#x27;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;</span></span><br><span class="line">    last_pos = <span class="built_in">len</span>(all_chars) - <span class="number">1</span></span><br><span class="line">    code = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(code_len):</span><br><span class="line">        index = random.randint(<span class="number">0</span>, last_pos)</span><br><span class="line">        code += all_chars[index]</span><br><span class="line">    <span class="keyword">return</span> code</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    <span class="built_in">print</span>(generate_code())</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">o4ep</span><br><span class="line">KSYN</span><br><span class="line">Mye1</span><br><span class="line">kP8d</span><br><span class="line">87X8</span><br><span class="line">rpAH</span><br><span class="line">VC6y</span><br><span class="line">fOeQ</span><br><span class="line">7yl9</span><br><span class="line">TOCP</span><br></pre></td></tr></table></figure><h2 id="走迷宫"><a href="#走迷宫" class="headerlink" title="走迷宫"></a>走迷宫</h2><p><a href="https://www.cnblogs.com/Radium1209/p/10415341.html">https://www.cnblogs.com/Radium1209/p/10415341.html</a></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqdr8pkl42j30sk0ootn2.jpg" alt="image-20210510233606678"></p><p>出自【1】<a name='toc1'></a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="">参考1</a><a href="#toc1">🔼</a></li><li></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;python-小猪佩奇&quot;&gt;&lt;a href=&quot;#python-小猪佩奇&quot; class=&quot;headerlink&quot; title=&quot;python 小猪佩奇&quot;&gt;&lt;/a&gt;python 小猪佩奇&lt;/h2&gt;&lt;blockquote&gt;</summary>
      
    
    
    
    <category term="编程" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>⭐️阅读摘要</title>
    <link href="http://example.com/2021/02/27/%E3%80%90%E9%9A%8F%E7%AC%94%E3%80%91%E9%98%85%E8%AF%BB%E6%91%98%E8%A6%81/"/>
    <id>http://example.com/2021/02/27/%E3%80%90%E9%9A%8F%E7%AC%94%E3%80%91%E9%98%85%E8%AF%BB%E6%91%98%E8%A6%81/</id>
    <published>2021-02-26T16:00:00.000Z</published>
    <updated>2022-01-23T07:32:56.108Z</updated>
    
    <content type="html"><![CDATA[<p>思辨！！</p><span id="more"></span><h2 id="系列化文章"><a href="#系列化文章" class="headerlink" title="系列化文章"></a>系列化文章</h2><ul><li>计算的极限</li></ul><p><a href="https://fwjmath.wordpress.com/recommended-list/">https://fwjmath.wordpress.com/recommended-list/</a></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxg437sw93j314a0u0ae6.jpg" alt="image-20210406234554525"></p><ul><li><a href="https://mp.weixin.qq.com/s/WiWG2gPlVytxHwjdQsSQhA">数据分析入门-06-数据科学边界：数据 不能 解决什么</a></li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxg4lgvlvqj314u0k8myd.jpg" alt="image-20211217001105981"></p><p>我们现在已经走过了很久的历程,终于完成了这个系列的写作,今天是我们的收官之作,我们聊点轻松的,今天没有公式,没有代码.</p><p> ….<a href="http://mp.weixin.qq.com/s?__biz=MzA3ODYwMjY1MQ==&mid=2667353002&idx=1&sn=14cf7ea0d5eb156ce072ca116b5f4077&chksm=84487b5eb33ff24819b3865af5211b32b605aa514f83920751c0e78137f3a18ba15107d26747&scene=21#wechat_redirect">0 如何构建学科体系</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzA3ODYwMjY1MQ==&mid=2667353017&idx=1&sn=e9e10c6ba0e0a8dd7b1daad85b897590&chksm=84487b4db33ff25b5ef14385909927172bf6776819e527ec453d944875c2d70856dfaf630c72&scene=21#wechat_redirect">1 数据世界观</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzA3ODYwMjY1MQ==&mid=2667353035&idx=1&sn=646741d487a07db24c3d1432485557e8&chksm=84487b3fb33ff229c14275d38954956914b38c25dffa96d36cbafff797a766d67e04835ba03e&scene=21#wechat_redirect">2 数据分析整体框架</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzA3ODYwMjY1MQ==&mid=2667353051&idx=1&sn=6f72e8a96bc65596b0ead79942ba62f8&chksm=84487b2fb33ff2399a8ca44ce6f71cf4c120e306df36d6ff9ff07f7466a39cacf46f8ff45404&scene=21#wechat_redirect">3 问题分析/数据预处理/数据预分析</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzA3ODYwMjY1MQ==&mid=2667353059&idx=1&sn=ceb07596442286e1136b7a88bf36cf67&chksm=84487b17b33ff2015fe4ab290cf707b13d8e893c211b1261c0d6bcb4a56a9bbb3c37a5553cb4&scene=21#wechat_redirect">4 数据分析核心:建模</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzA3ODYwMjY1MQ==&mid=2667353075&idx=1&sn=a5a6e2adaa7e7de12c435fb6c676bb3c&chksm=84487b07b33ff2119ab006282ed59fa67b65160771772f543ab83601310d7327d610c16f7cf6&scene=21#wechat_redirect">5 模型空间概述</a></p><p>6 数据科学边界(这篇文章) …</p><h2 id="谈职业"><a href="#谈职业" class="headerlink" title="谈职业"></a>谈职业</h2><ul><li><p>很多人建议，寻找人生方向时，你应该听从自己的内心，寻找真正热爱的事情。我现在觉得，更现实的建议应该是，寻找你愿意忍受的痛苦。 <strong>你在哪一个方向上，愿意心甘情愿地、经年累月地吃苦，具有最大的忍耐，“虽九死其尤未悔”，那就是你应该选择的方向。</strong></p><p>你能在某件事上赢过别人，原因很可能不是你比他强，也不是你比他更热爱这个事业，而是你比他更抗打击。生活虐你千百遍，等到别人都放弃的时候，你还没有放弃。</p><p><a href="https://github.com/ruanyf/weekly/blob/master/docs/issue-147.md">科技爱好者周刊（第 147 期）：寻找你愿意忍受的痛苦</a></p></li><li><p>CTO 干什么？（英文）</p><p>作者原本是一个6人小公司的工程师，后来因为公司业务快速扩张，他被提拔成工程总监（CTO）。他花了三年时间，才搞明白什么是 CTO 的职责，分成产品、流程、人员三部分。</p><p>CTO 干什么？: <em><a href="https://www.hashtagcoder.dev/blog/director-of-engineering">https://www.hashtagcoder.dev/blog/director-of-engineering</a></em></p></li><li><p>诸葛越：关于算法工程师职业发展的思考</p><p><a href="https://mp.weixin.qq.com/s/mV-oXdWRe3Jcs9OJnXbEbw">https://mp.weixin.qq.com/s/mV-oXdWRe3Jcs9OJnXbEbw</a></p></li><li><p><a href="https://cloud.tencent.com/developer/article/1140927">IT工程师的“五个等级”，你处在哪一级？</a></p></li></ul><p>第五级：能独立解决问题，完成工程工作。</p><p>第四级：能指导和带领其他人一同完成更有影响力的工作。</p><p>第三级：能独立设计和实现产品，并且在市场上获得成功。</p><p>第二级：能设计和实现别人不能做出的产品，也就是说他的作用很难取代。</p><p>第一级：开创一个产业。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxj1txm9zsj30rm0fita3.jpg" alt="image-20211219125201229"></p><h2 id="技术发展"><a href="#技术发展" class="headerlink" title="技术发展"></a>技术发展</h2><ul><li><p>在计算机图形渲染领域，光线追踪技术往往被视为该领域的「圣杯」，因为它可以为虚拟世界带来接近现实的光影效果。</p><p>而人工心脏，同样也是医疗界的圣杯之一。毕竟人造器官本就是一件看似不可能的事情，而心脏，更是人体最重要的部分。</p></li><li><p><strong>另外对于想在计算机行业长期发展的朋友来说，夯实计算机体系基础知识其实是非常非常重要的。</strong></p><p><strong>基础往往决定了上层建筑，楼房再高，地基不稳最后也白搭。</strong>这些基础知识包括：算法、计算机网络、计算机组成原理、计算机编译原理、操作系统、数据库等等。</p></li><li><p>IPU芯片–飞越舒适区布局未来（IPU for AI）</p><p><a href="http://news.modernweekly.com/lead/35601">http://news.modernweekly.com/lead/35601</a></p><p>关于 IPU</p><blockquote><p>我们想制造一台超高性能的计算机，利用低精度来处理数据</p><p>也就是说，Graphcore正在为计算机开发的大脑将<strong>像人类一样处理信息</strong>，而不是通过大量的数字运算来模拟人类</p><p>与成熟的CPU（中央处理器）、GPU（图形处理器）相比，人工智能应该需要一块专属芯片——这个想法让全球创业企业看到了挑战巨头的机会。</p></blockquote></li><li><p>工业软件——这是中国与西方差距最大的一个行业，重要程度堪比芯片！为什么被忽略了？</p><p><a href="https://zhuanlan.zhihu.com/p/94093479">https://zhuanlan.zhihu.com/p/94093479</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/gJ_xfexfhIMXr4Cz7sonnw">14亿人的战争：中国人用了30年望见计算力的珠峰</a></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxg437bde3j31fw0u00vn.jpg" alt="image-20200428000557978"></p></li><li><p><a href="https://mp.weixin.qq.com/s/mb0YFqqjQNkJ58D9r60r8w">中国为什么一定要搞新基建？到2030年你就都明白了！</a></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxg436mjtfj30oe0dqq55.jpg" alt="img"></p></li></ul><h2 id="商业-经济"><a href="#商业-经济" class="headerlink" title="商业/经济"></a>商业/经济</h2><ul><li><p>有一种普遍的误解，认为免费提供产品就无法产生任何收入。事实上，免费有时候不是定价策略，而是一种定位策略，尝试通过免费吸引用户，然后将产品定位在正确的受众群体面前。等有了用户以后，出售增值功能自然就成为最合适的扩展策略。</p><p>– <a href="https://www.chrisfrantz.com/how-to-kill-a-unicorn/">《免费增值是产品启动的有效方式》</a></p></li><li><p><a href="https://www.youtube.com/watch?v=bBC-nXj3Ng4&ab_channel=3Blue1Brown">有没有想过比特币（和其他加密货币）是如何工作的？</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/DOzYTawRE_-QBldvlgWR9g">重读《盐铁论》：国营垄断与民营经济，历代争斗的结局都是怎样？</a></p></li><li></li></ul><h2 id="好奇"><a href="#好奇" class="headerlink" title="好奇"></a>好奇</h2><ul><li><a href="https://www.ifanr.com/1315222">未来的电池，可能是用病毒做的 | 近未来㉘</a></li></ul><h2 id="思维"><a href="#思维" class="headerlink" title="思维"></a>思维</h2><ul><li><p>“<strong>找到解决方案非常容易，最难的是找到要解决什么问题</strong>。”——印证了爱因斯坦“了解了问题，解决方案就会浮现”的智慧，这一点在今天极为重要，因为我们生活在问题不是那么明显而解决方案并不那么复杂的时代。</p></li><li><p>旅行不是为了看到不同的事物，而是为了学会不同地看待事物。</p><p>（You don’t travel to see different things, you travel to see things differently.）</p><p>– <a href="https://m.facebook.com/HanksWorldWide/photos/pb.160385744474061.-2207520000.1564413746./238546423324659/">Ben Davenpor</a>，风险投资家</p></li><li><p>面向对象编程的哲学思想是，通过对语言建模来适应问题，而不是对问题建模来适应语言。</p><p>– 《C prime plus》教材</p></li><li><p><a href="https://www.youtube.com/watch?v=q5TSmPlXkrY&ab_channel=ForChineseSpeakersTV">周孝正：中国社会问题分析（完整版）</a></p></li><li><p>归零。（归零：航天系统专有名词，就是要把搞清问题机理、问题现象可稳定重复复现、更改措施有效、同时进行举一反三、其他产品是否有类似问题，杜绝此类问题再次发生）</p></li><li><p>科学素养</p></li></ul><p>包括：科学知识+科学思维</p><p>什么是 科学思维？<a href="https://www.youtube.com/watch?v=h3qbHqnrBGY&ab_channel=%E7%A7%91%E5%AD%A6%E5%A3%B0%E9%9F%B3">汪诘2021年末重磅演讲：《科普视频创作的“术”与“道”》</a></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxr2xd1nd1j31m00l2wjy.jpg" alt="image-20211226113419556"></p><p><a href="http://www.guob.org/course/comss2.pdf">科学思维含有以下3方面</a>：</p><p>理论思维（公理、规则、结论）→推理：数学 </p><p>实验思维（重现、自洽、预见）→实验：物理 </p><p>计算思维（设计、模拟、仿真、挖掘）→使自动：计算机</p><p>（1）理论思维：理论源于数学，理论思维支撑着所有的 学科领域。正如数学一样，定义是理论思维的灵魂， 定理和证明是它的精髓。公理化方法是最重要的理论 思维方法。 </p><p>（2）实验思维：实验思维的先驱是意大利科学家伽利略， 被人们誉为“近代科学之父”。与理论思维不同，实验思维往往需要借助于某些特定的设备，并用它们来 获取数据以供以后的分析。 </p><p>（3）计算思维：计算思维是运用计算机科学的基础概念 进行问题求解、系统设计以及人类行为理解的涵盖了 计算机科学之广度的一系列思维活动。</p><ul><li>计算思维</li></ul><p><a href="http://www.wrsa.net/content_39111506.htm">《留学生》：美国计算机科学家周以真 使计算思维成为常识</a></p><p>计算思维是运用计算机科学的基础概念进行问题求解、系统设计以及人类行为理解等涵盖计算机科学之广度的一系列思维活动。</p><p>一般来说，计算思维中最重要的几个思维过程是<strong>抽象、分解以及组合</strong>。所谓“抽象”，是指忽略所有不相关的复杂细节，而只专注于问题关键部分的能力。你会注意到，我刚刚并没有提及“锅是啥颜色的”，“厨房有多热”，因为这些都是不相关的细节。</p><p>“分解”能让我们将问题分割成一个一个小的部分，我们将这些小部分各个击破，最终通过“组合”将各部分重整起来，形成一个针对原问题的解决方案。</p><p>实际上，计算思维是一种思考方式，是用计算机所能有效执行的方式来对问题进行表述并提出解决方案——这里所说的“计算机”既可以指机器，也可以指人。换句话说，计算思维也是一种解决问题的方式。</p><ul><li><a href="http://www.catb.org/~esr/faqs/smart-questions.html">如何以聪明的方式提问（Eric Steven Raymond）</a>）</li><li><a href="http://www.web699250.com/forum.php?mod=viewthread&tid=16424&extra=page=1"><strong>wj第072封信 为什么对“巧合”要保持警惕？</strong></a></li></ul><p><strong>划重点</strong></p><p>1、如果你理解了巧合背后的规则，就会发现有些我们以为是“巧合”的事情，背后其实有着必然性。 2、在对事情做出判断的时候，最重要的其实还不是你给出的判断本身，而是你所使用的判断方法。 3、在做判断时，事实要优先于我们的猜测。但在得不到事实之前，我们要依靠理性和常识去思考和做出判断。 4、面对那些好得难以置信的事情，记住要想一想，好运气背后是否另有原因。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br></pre></td><td class="code"><pre><span class="line">设为首页收藏本站开启辅助访问切换到窄版</span><br><span class="line">终生学习社</span><br><span class="line">用户名</span><br><span class="line">自动登录 找回密码</span><br><span class="line">密码</span><br><span class="line">登录 立即注册</span><br><span class="line">快捷导航</span><br><span class="line">论坛</span><br><span class="line">请输入搜索内容</span><br><span class="line">帖子</span><br><span class="line">搜索</span><br><span class="line">热搜:活动交友discuz</span><br><span class="line">终生学习社»论坛›订阅专栏›吴军·硅谷来信 3›wj第072封信 为什么对“巧合”要保持警惕？ ...</span><br><span class="line">返回列表发新帖</span><br><span class="line">查看: 331|回复: 0</span><br><span class="line">打印 上一主题 下一主题wj第072封信 为什么对“巧合”要保持警惕？ [复制链接]</span><br><span class="line">admin</span><br><span class="line"></span><br><span class="line">1万</span><br><span class="line"></span><br><span class="line">主题</span><br><span class="line">1万</span><br><span class="line"></span><br><span class="line">帖子</span><br><span class="line">4万</span><br><span class="line"></span><br><span class="line">积分</span><br><span class="line">管理员</span><br><span class="line"></span><br><span class="line">Rank: 9Rank: 9Rank: 9</span><br><span class="line"></span><br><span class="line">积分46302</span><br><span class="line">发消息</span><br><span class="line">电梯直达</span><br><span class="line">跳转到指定楼层楼主</span><br><span class="line"> 发表于 2021-1-25 20:06:17 | 只看该作者 回帖奖励</span><br><span class="line">播放 加速 减速</span><br><span class="line">当前速度:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">这里是吴军的《硅谷来信》第3季，这封信我们今天来谈一谈巧合这件事。在线版唯一充值微信：web699250。</span><br><span class="line">网络上有一个段子，说明太祖朱元璋是一位化学巨匠，因为明朝的皇室，很多人的名字中都包含一些今天的人才知道的化学物质。</span><br><span class="line">比如，明朝有个王爷叫朱慎镭，镭字就是居里夫人发现的那个放射性元素镭；还有一个王爷叫朱均钚，这个钚是核武器的重要原料，也是20世纪才发现的化学元素；另外还有个王爷叫朱悦烯，烯就是近两年热度很高的那种新材料，石墨烯的烯。如果你去翻一翻明代藩王世系表，还能找到很多这样的名字。</span><br><span class="line">可是这些元素和物质，大部分都是20世纪才被发现，才有了名称，明朝的皇室们是怎么未卜先知，找到这些字来做名字的呢？这就和朱元璋留下的一条规矩有关。</span><br><span class="line"></span><br><span class="line">不是巧合的巧合</span><br><span class="line"></span><br><span class="line">朱元璋是一个特别细致、特别爱替子孙后代操心的人。朱元璋小时候出身穷困，甚至做过乞丐，所以特别担心子孙后代的生计，于是立了一个规矩，规定明朝皇室后代，都不必从事生产劳动养活自己，每年从朝廷领生活费就好。</span><br><span class="line">另外，朱元璋的本名叫做朱重八，他父亲名字叫朱五四，爷爷叫朱初一，这些名字都是从出生日期取出来的，显示着朱元璋的家庭处于平民中的最下层。登基做了皇帝之后，朱元璋自然不能再允许自己的后代中有可能再出现这样的名字，于是他又立了一条规矩，把子孙后代名字该怎么起都给规定好了。</span><br><span class="line">朱元璋先是给每个儿子甚至侄子都写了一首诗，孙辈往后的名字，名字中的第二个字要从这首诗里面取。第三个字不好定死，但朱元璋也立了规矩，第三个字的偏旁要按金木水火土五行的相生关系来起。</span><br><span class="line">比如朱元璋的儿子这一辈，名字都是木字旁，比如太子朱标和燕王朱棣；那么到孙子辈，因为五行木生火，第三个字就应该是火字旁。比如太子的儿子，建文帝朱允炆，炆字就是火字旁；朱棣的儿子，明仁宗朱高炽，炽字也是火字旁。</span><br><span class="line">但是，朱元璋没有考虑到一个问题，就是子孙后辈的人数增长的速度非常快，是一种指数增长。到了嘉靖年间，朱氏子孙就已经有接近两万人了。这么多人，都要按朱元璋定的规矩取名字，字是不够用的。特别是中国人还有一条传统，叫做避讳，自己祖辈名字中用过的字，后辈是不能再用的。</span><br><span class="line">于是到了明朝中期，包含金木水火土的汉字基本都给朱家用光了。再往后，朱家的王爷们只好自己造字，发明了一堆极其生僻的汉字，除了给自己做名字用，再也没有别的用处了。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">那么这些字又是怎么变成新发现的化学元素和化学物质的呢？这就要提到清朝末年的一位中国化学家和翻译家，徐寿。当时他和在江南制造局工作的一个英国人傅兰雅一起，翻译了很多西方科技书籍。</span><br><span class="line">当翻译到化学著作时，徐寿遇到了一个难点，就是很多化学元素和物质的学名，中国过去大多是没有的，需要起名字。为了规范化，徐寿就定了三条标准：</span><br><span class="line">第一，中国古代已经有的名称继续使用，比如金银铜铁等等，再比如水银，古文中叫做汞，也属于这一类。</span><br><span class="line">第二，前人翻译西方著作时发明的外来词，合适的可以继续使用，但根据徐寿后面第三条翻译规则做出一些修订。</span><br><span class="line">比如之前，氧气、氮气和氢气这三种物质，在翻译中根据它们的特性名字起了名字：氧气原本是“养气”，养是滋养的养；氮气原本是淡气，淡是寡淡的淡，因为氮气在大气中含量高，“冲淡”了氧气的含量；氢气原本是“轻气”，轻重的轻。徐寿沿用了这三个名字，同时根据它们是气体的特性，把字改成了气字头的三个字“氧氮氢”。</span><br><span class="line">第三条翻译规则，就是根据元素的的性质和拉丁文读音寻找合适的汉字。例如，金属元素就使用金字旁的字，常态为液体的元素可以使用三点水偏旁的字，非金属元素和物质则使用石字旁的字。</span><br><span class="line">于是，在徐寿的规则下，很多化学元素的名字和物质名就和明朝朱氏子孙的名字重叠了。</span><br><span class="line">所以，并不是朱元璋和明朝皇室未卜先知，而是他们起名在先，徐寿等人使用这些字在后。表面上是一个巧合，背后其实自有原因。</span><br><span class="line">而且如果我们深入一步思考，就会发现这甚至称不上是一个巧合，可以说有一定的必然性。</span><br><span class="line">原因很简单，化学元素目前有一百多个，加上一些专有名词，大概需要用到一百五六十个汉字，其中一大半都和金属有关。这里面只有金银铜铁等一小部分是已经有了对应汉字的，其他都要新找一个字来命名。而汉字中，金字旁的字总共也就一百多个，其中很多都是明朝皇室在起名时造出来的生僻字。因此，化学元素名称和朱家人的名字高度重合，可以说是一种必然。</span><br><span class="line">可见，如果你理解了巧合背后的规则，就会发现有些我们以为是“巧合”的事情，背后其实有着必然性。</span><br><span class="line"></span><br><span class="line">用概率来判断巧合与必然</span><br><span class="line"></span><br><span class="line">通常我们在认知中，怎么判断一件事是巧合还是必然呢？最好用的工具就是概率论。</span><br><span class="line">比如抛硬币。假如你把一个硬币抛了10次，全是正面朝上。这是巧合吗？我们怎么来判断这样一件事呢？</span><br><span class="line">这时，重要的其实不是你给出的回答，而是你所使用的判断方法。</span><br><span class="line">有的人回答说，肯定有问题，但他的依据只是自己的直觉或者日常经验。这个回答就是没有意义的。</span><br><span class="line">有的人会回答说，很正常啊，每次硬币朝上朝下的概率都是1/2，十次正面和五次正面五次反面都一样啊，没什么区别，很正常。这里好像比用直觉更进了一步，但仍然是错误的思考。</span><br><span class="line">为什么这么说？因为这个回答其实混淆了一个概念，就是究竟什么叫做“一种结果”。实际上，在这个问题中我们所说“一种结果”，在最准确的意义上指的是概率中的“原子事件”，也就是不可以再分的最小的随机事件。</span><br><span class="line">比如，十次硬币全都是正面，这是一种结果，也确实是一个“原子事件”。但五次正面五次反面，却并不是一个原子事件，因为其中还包含了“1-5次是正面，6-10次是反面”“单数次是正面，双数次是反面”等等许多种情况，具体来说，里面其实包含了252种原子事件。</span><br><span class="line">所以十次正面朝上和五次正面五次反面并不一样，十次正面朝上的概率是1/1024，而五次正面五次反面的概率则是252/1024。相比之下，10次正面朝上确实是一个小概率事件，如果它发生了，这并不能看作是一种完全“正常”的情况。这时候我们就要想一想，背后恐怕有一种力量促使它在发生，而不是简单地将它归结为偶然性。</span><br><span class="line">我们可以进一步地通过数学方法去尝试判断，这个硬币有问题的可能性是多大。简单来说就是做两个假设。第一个假设是硬币本身没有问题，是均匀的；第二个假设是硬币是有问题的，怎么扔都是正面朝上。接下来就是根据观察的结果来验证哪一个假设是对的，这在统计中有一套专门的方法。</span><br><span class="line">更细节的过程这里就不展开了，我们可以给出一个结论：一枚硬币抛10次，如果连续10次都是正面朝上，这个硬币作了假的概率是99.7%，没有作假的概率只有0.3%。</span><br><span class="line">也就是说，对于硬币抛10次10次都是正面这个问题，经过理性的思考后的回答应该是，有99.7%的概率，这不是一个巧合，而是硬币本身有问题。</span><br><span class="line">这里特别需要提醒的是，这是我们在“不知道硬币有没有问题”的前提之下，作出的假设和验证，也就是说我们并不知道事实如何。如果在此之前，我们就确认了事实是这枚硬币就是正常硬币，那么我们就要承认，即使只有0.3%的可能性，但这个巧合确实发生了。</span><br><span class="line">也就是说，在做判断时，事实要优先于我们的猜测。但在得不到事实之前，我们要依靠理性和常识去思考和做出判断。</span><br><span class="line"></span><br><span class="line">对巧合保持警惕</span><br><span class="line"></span><br><span class="line">理性的判断在抛硬币的例子里已经讲得很清楚了，常识的判断又是什么样呢？我之前和你讲过一个故事，有人为了吸引他人投资，同时给几千人发不同的邮件，预测股票的走势，第一次预测之后，他再继续给收到了正确预测邮件的人发第二次预测。这样下来，几千个人里面，总会有少数几个人收到的邮件连续10次预测都是对的。这少数的几个人恐怕会把发邮件的人看成是股神。</span><br><span class="line">但实际上，如果真的遇到连续10次都正确这样的小概率事件，我们首先应该想到的是，极大概率背后一定是有什么原因。</span><br><span class="line">我们不妨做两个假设，一个是此人真的是股神，第二个假设是对方是骗子。这时候常识就可以派得上用场，你应该想到两点：第一，对方会给你发，也就会给别人发，实际上你不知道他失败了多少次。第二，如果真的是股神，有赚大钱的本事，为什么不自己去投资发财，要花时间来说服你呢？有了常识，我们就足够识破骗子的把戏。</span><br><span class="line">今天，人们接触到的信息更丰富，骗子的手法也越来越花样百出。很多人讲，现在的骗子防不胜防。其实我们只要记住一点：面对那些好得难以置信的事情，想一想好运气背后是否另有原因。</span><br><span class="line">收藏家马未都先生讲过这样一个故事，一个古董爱好者，有一天让人带着到乡下去淘古董。走过一片田地看见几个人在挖地，正巧一个人一锹土掀到他脚下，随着土挖出一个汝窑瓷器。汝窑瓷器是今天世界上最值钱的瓷器之一，一共只有60多件传世，每一件的来历都清清楚楚，绝大多数都在大博物馆手里。</span><br><span class="line">这位老兄运气实在是太好，恰巧从那里路过，恰巧几个农民就挖出一个汝窑瓷器，甚至就掀到了他脚下。这位老兄想买下这件汝窑瓷器，和几个农民讨价还价，最后用自己一辈子全部的积蓄买了下来。</span><br><span class="line">回去后他找马未都先生鉴定，马先生怕他太伤心，不敢说是假货，只和他说这东西“不真”。这位老兄怎么也不肯相信自己上了当，明明是亲眼看见那农民碰巧从地里挖出来的。马先生讲，汝窑瓷器全世界60多件，绝大多数都是从古代收藏家手里一代代留下来的，只有个别几件是考古出土的，出土的地方也往往是旧宫殿遗址这一类的地方，不会是田间地头。很多大收藏家花了一辈子时间也不可得的东西，怎么正好有一件，就在你当时当日经过那个地方的时候被挖了出来。显然，这样的巧合背后，极大概率另有原因。</span><br><span class="line">相比之下，这个古董爱好者被人盯上，被特意做了个局蒙骗的概率，要远远大于他在田间地头碰巧就得到一件稀世珍品的概率。</span><br><span class="line"></span><br><span class="line">小结</span><br><span class="line"></span><br><span class="line">说到这里，你大概也能理解，为什么这封信的标题讲“面对巧合要保持警惕”。面对这类情况，也就是所谓的“超级好运气”，我自己通常的做法是只当它没有发生，我没有看见。不去肖想额外的所得，也就不会有所失，我只需要获得我应得的就好。</span><br><span class="line">反过来，对于一些超级坏运气，也不能简单归结为运气坏，有很大概率背后是另有原因，我们需要找到这个原因，才能在之后避免“坏运气”。</span><br><span class="line">好了，这封信就说到这里，我们下一封信再见。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">划重点</span><br><span class="line"></span><br><span class="line">1、如果你理解了巧合背后的规则，就会发现有些我们以为是“巧合”的事情，背后其实有着必然性。 2、在对事情做出判断的时候，最重要的其实还不是你给出的判断本身，而是你所使用的判断方法。 3、在做判断时，事实要优先于我们的猜测。但在得不到事实之前，我们要依靠理性和常识去思考和做出判断。 4、面对那些好得难以置信的事情，记住要想一想，好运气背后是否另有原因。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">用户留言</span><br><span class="line"></span><br><span class="line">甜小姐</span><br><span class="line">116 赞</span><br><span class="line"></span><br><span class="line">1，  人性。 我看很多香港那些讲千术的电影，那些人是利用所谓的“巧合”来达到骗人和获取钱财的目的，更准确地说，是利用人性。有坏的人性，比如“贪婪”，马路上突然出现一笔横财，又很巧地出现了失主来寻找，还很巧地出现了另一个见者有份的人，于是就开始捡钱分钱骗钱的千局，各种调包，真钱假钱等等，利用的就是当事人想占小便宜的心态。当有利益可占时，就算他平时头脑清醒，知道可能会有诈，此刻他也会相信这是真的的。人倾向于相信他希望是真的的事情。 还有的利用是好的人性，比如“情感、义气”。我们以前有个行长都上过当，对方假扮老朋友，恰巧我们行长正好有个朋友也姓王（这种一般就是利用大概率数据行骗，比如王是个很常见的姓），然后我们行长一听朋友有难，又碍于面子不好意思核对真实，非常仗义就一笔钱汇出去了。骗子也知道你这样的职位人有钱，不差这几千块钱。但是还是很难以想象的，因为是一个资深的金融工作从业者。所以受骗的，不只是那些糊涂的老年人，骗子对人性的把控相当准确。   面对贪婪，始终要记得的是，天下没有免费的馅饼，也没有那么多巧合降临在我们身上，背后必定有诈。踏踏实实挣来的，才是让人花的安心的钱财。面对情感，再深，也不能冲动，不能慌了手脚，要镇定要核实清楚。我有时碰到骗子，其实我一开始不知道他是骗子，我以为是真的，但是我是个好奇的人，我的思维习惯就是要弄明白怎么回事。于是，我就问了一大堆问题，骗子被我问得烦死了，编不下去了，最后就把电话挂了。我还纳闷呢，这不是还没解决，怎么就不说了，然后再细细一想，原来是骗子。   2，  认知。除了这些人为制造的巧合，还有很多我们的认知为我们制造的巧合。比如类似于“幸存者偏见”。当你处于某种状态的时候，你就会特别关注某个和自己相关联的现象，然后发现到处都是，从而误以为是巧合。其实平时也一直有，只是你没有注意。比如，你在想某个人的时候，他正好打电话过来，是巧合吗？那是你忽略了更多次数的“”你在想他，他没有打电话过来的”场景，还有“他打电话过来，但是你没在想他的场景”。特殊性往往会集中人们的注意力，从而忽略了其他的普遍现象，从而得出巧合的结论。 看到过一句话， 你赚的每一分钱都是你对世界的认知； 你亏的每一分钱都是你对世界认知的不足； 你永远不可能真正赚到超出你的认知以外的钱。6小时前作者回复谢谢你的分享6小时前</span><br><span class="line"></span><br><span class="line">左星星</span><br><span class="line">84 赞</span><br><span class="line"></span><br><span class="line">这节课让我想到了前段时间的一条新闻，一位六十多岁的大妈，日子过得不错，只是感情生活很平淡。有一次她在网上遇到了演员靳东，两人聊得挺好，大妈感到自己坠入了爱河，决心跟丈夫离婚，非靳东不嫁…… 那个“靳东”当然是假的，大妈的可悲之处并不在于被骗，而在于她为什么居然能相信，靳东应该娶她呢？ 其实我们不应该去笑话大妈，我们每个人或许都有『奇迹思维』。这不是说这个世界不存在奇迹，世界上有时候就是会发生奇迹，比如买彩票中了亿万大奖。我说的是人们总是不能很好地评估和珍惜奇迹的稀有程度。 爷爷奶奶那一辈人有一个特别朴素的观点，你得有付出才能有回报。而考虑到能量转化过程中的损耗，回报常常会小于付出。特别好的东西需要巨大的付出。 物理学中有个能量守恒定律，这个世界不会凭空“多”出来一个什么东西。每一件事物都一定是从别处移动过来、或者从别的东西转化而成的。 你这里多一个，别处就得少一个，你用了，别人就没有了。 你面对突然天降的横财，就要用能量守恒定律去分析一下，你付出了什么？哪里是不是少了一点什么？这一切符合自然规律吗？ 此前，有个朋友向我推荐一款理财产品，说是投资一个鳄鱼养殖场，鳄鱼皮专供奢侈品公司生产名贵挎包，保证年化收益率10%，还可以签订保底合同。 我想了想还是拒绝了，我想到了罗辑思维里的一段话：“你永远赚不到超出你认知范围外的钱，除非你靠运气。但是，靠运气赚到的钱，最后往往又会靠实力亏掉。”8小时前作者回复四十年前中国有关假张俞事件，情况类似。6小时前</span><br><span class="line"></span><br><span class="line">李博典</span><br><span class="line">42 赞</span><br><span class="line"></span><br><span class="line">吴军老师好： 感谢老师今日来信，用多个案例与理性思考去更细致解释“巧合”。面对“巧合”，如何判断偶然性的巧合与必然性的巧合很重要。极小概率下的事实，我们必须要承认，这种巧合，确实是存在，也确实是可遇不可求。但更多的是无法确定事实的“巧合”，就需要依靠理性与常识去思考与判断。 老师已用多个案例分析阐明大多数的的“巧合”都是有一定的危机，我们面对这些“巧合”应该保持警惕。老师说的：不去肖想，只取自己应得部分就好。我感觉说得很对，这种思考也算是一种巧合，也是必然的思考模式。面对现实生活中的方方面面，首先要对自己做到不去贪心，你就可以避免很多诈骗。这个思想从小都会被灌输，后来从影视剧，各类书籍，都能感受到其中教导我们的都是这种思考模式。 记得20年前的深圳，很多地方都还是处于待开发状态，到处都是鱼龙混杂的人。那时候寒暑假来到深圳与父母团聚，父母都会告诫我们，不是自己的东西不能要，即使在路上看到钱都别去捡，外面的世界太多太多骗子，没有足够的判断能力，你们能做的就是不能贪心，对陌生人始终保持警惕，不可轻信外人的话。 记得当时父亲也说过一个案例，他朋友和一个陌生人在路边同时看到一块手表，同时想捡起来，后来磋商一块分了，因为是手表，不知道价格几何，就辗转多次最后把手表卖了，两人各分了几百块钱。但后来又因为他的贪心，不知道怎么的最后还是被骗了几千块钱（具体怎么被骗忘了）。他们骗子的套路是一套一套的，我们这些不能识别判断的人，首先要做到的就是不去贪心，不是自己的不要就是了，起码没损失。 祝老师安康。 学生：李博典 2021.01.25 01:309小时前作者回复谢谢你的分享6小时前</span><br><span class="line"></span><br><span class="line">海绵</span><br><span class="line">38 赞</span><br><span class="line"></span><br><span class="line">我们可以通过渡边淳一著的《钝感力》这本书，来谈谈“巧合”的概念。 其实，我们可以观察自己周围那些取得成功的人，不一定是能力非常卓越的人，但大多是情绪比较稳定的人，他（她）们当然有才能，但在这些才能背后，一定隐藏着有益的钝感力（这个“钝感”指的是“不敏感”）。 ○善于情绪管理 对外界的批评保持钝感而不气馁、还能保持镇定的情绪，相比较遇事急躁、动不动就发脾气的人，肯定前者的升职几率更大，没有一个管理者会希望自己的下属是一个不定时的炸弹。 ○勇于坚持的力量 孤独奋斗的人经常会陷入一时的失败情绪而不能自拔，怀疑自己、怀疑一切甚至怀疑到运气上，但钝感的人会有不断试错的决心，在实践中继续找寻正确的方向。 事实证明，努力找到方向并在一个行业勤耕的人，最终都会有所收获，这是勇于坚持的力量。 所以说，我们看为什么有的人一直那么“巧合”的顺风顺水，不能只关注表面风光，要挖掘其背后具有哪些值得我们学习的品质。 如果说，才能是最基本的必备指标，那么有益的“钝感力”，可能就是能够让才能发扬光大的催化剂。8小时前作者回复渡边淳一著的《钝感力》这本书，～～～这本书最近很热6小时前</span><br><span class="line"></span><br><span class="line">涂立文</span><br><span class="line">27 赞</span><br><span class="line"></span><br><span class="line">信中提到一个古董爱好者购买一个假汝窑瓷器，除了出现在田地间地点不对之外，还有两点可疑，一是汝窑瓷器在这田地里怎么得以完整保存，以及何以农民随意挖掘都没有损坏。二是普通农民哪知汝窑瓷器价值连城，大概率能卖几千上万他也觉得是飞来横财了，不至于真要古董爱好者花一生积蓄才出手。 《水浒传》里，有人跟在林冲背后叫卖宝刀（这是真宝刀），正常来说也不可能普通人在普通闹市街头卖真宝刀，还冲你叫卖，但林冲也是上了“巧合”的当，因此改变了人生。 面对巧合要保持警惕： 1.天上不会掉馅饼，掉了自己脑袋太小也接不住。 2.不要有贪念。 3.重点：学会换位思考。 例如，有人向你推销价值10万元的古董，说急需用钱5000元贱卖给你。 你站在卖家角度想一想：他什么事真的急着现在卖这点钱？不能等等或没有别的方式了吗？如果还有别的卖高价的可能性，就是有问题。 谢谢吴老师！10小时前作者回复林冲的故事很典型6小时前</span><br><span class="line"></span><br><span class="line">Allelujah 朱磊</span><br><span class="line">35 赞</span><br><span class="line"></span><br><span class="line">这是一段我哥和银行理财产品经理之间的对话： “你好，我们机构有年化利率XX%的保底理财产品，请问您要购买多少金额的呢？” “没钱。” “不需要很大额的资金，最低投入金额只需要XXXX元就可以了，这个收益率真的很难得。” “真的没钱。要不这样吧，你借钱给我买，赚了算我的，亏了算你的。” “滴滴滴…”10小时前</span><br><span class="line"></span><br><span class="line">Scenery</span><br><span class="line">30 赞</span><br><span class="line"></span><br><span class="line">万维钢老师曾经把迷信总结为四句话：在没有道理的地方寻找道理，在没有意义的地方找到意义，在没有规律的地方发现规律，在没有因果的地方强加因果。这样的迷信何尝不是『巧合事件』本身。 世上的万事万物都有联系，一次巧合或许是巧合，两次以上的巧合就可能是预谋。当人们对事情了解的越少，就越想要创造出一个模式或者编造一个故事来进行解释，而且还会觉得，如果自己这样做了，就更容易成功。 面对巧合 ①对自己严格要求，避免“巧合事件”。比如在公司，遇到一些倒霉事，有些员工会说，“为什么偏偏发生在我的身上”，觉得这是一种巧合，就给自己找解释来说明本是自己的错误。但很多时候我们反过来想，是啊，为什么每次出现问题都是你呢。正面问题，那一定是自己做的不够好，应该反思自己，避免以后再出现这样的『巧合』。 ②对外界严格警惕，永远相信没有什么事是无缘无故发生的，天下也不会有掉馅饼的事，但会有“碰瓷”。一些高级的碰瓷者先自残式的给自己造成伤害，然后趁司机不注意制造自己被车辆碾压或碰撞的假象，并对“目标司机”进行勒索。面对这种巧合，我们一定多留点心眼，实在不行直接报警。3小时前</span><br><span class="line"></span><br><span class="line">舒适蜗蜗</span><br><span class="line">26 赞</span><br><span class="line"></span><br><span class="line">谢谢吴老师分享和启发！ 今天的讲授让我从理性角度重新认识了“巧合”这件事儿，天上不会掉馅饼幸好砸中了我。记得吴老师原来也讲过，运气是个常量。我确实也相信这样的说法。我觉得如果好运气就是这么巧合地选中了我，比如我中了彩票，估计我会很不踏实，我得拿出来做一份对社会有益的事业，回馈社会，才能抵消已经获得的这份好运，从而给未来保留获得新的好运的机会。 关于巧合，我原来有件事儿一直没想通，后来慢慢总结出了其中的奥妙，不知对不对！我举个例子:常言道，这人啊，经不起念叨，一念叨就见面。我偶尔也亲身经历这种事儿，特别是有一次，我脑子里正在想一位几年都没见面的人，想着想着，瞬间我的手机响了，天啊，是这个人给我打的电话！我真是惊讶到不行。那几天，我经常和别人讲这个神奇的经历。 后来，我渐渐发现，是不是我过于大惊小怪了。我经常都会在脑海里考虑到某些事儿、想到某些人，而我脑子里想到的人，在接下来的时刻都没有和我遇见或给我打电话啊。而我这样不停地想张三、李四、王五等人，早晚会发生一次这样的“巧合”，所以这应该是个大概率事件，而这种“巧合”不幸被我歪曲成了一个神奇的事！ 所以我还是坚信:天上不会掉馅饼，脚踏实地靠自己，他买他的比特币，我就傻傻做宽基。 祝吴老师和同学们新的一周顺利！9小时前作者回复很赞赏你的心态6小时前</span><br><span class="line"></span><br><span class="line">小熊</span><br><span class="line">25 赞</span><br><span class="line"></span><br><span class="line">太喜欢吴军老师这封信啦，尤其是汝窑瓷器的故事，越嚼越百感交集。虽然为例子里的人难过，但是自己又不厚道的笑出声来，惭愧惭愧。 而关于“好运气”的思考角度，吴军老师提出的“概率论”概念，绝对是要无时无刻回荡在心中，保护自己不受骗的不二法宝。在这个基础上，还有两个思考，可以在自己心里出现“要不要赌一把，万一我真的好运气呢”的想法时，作为思考的参考： 首先，从吴军老师67封信聊到的“风险”角度上看，花太大成本去赌“好运气”，会让自己进入无法控制的风险区。毕竟“好运气”是极小概率事件，如果穷尽所能去赌这个“好运气”，没赌上，可能会完全失去过去很多年的积累。从规避风险的角度上看，如果一个“赌局”的成本高于可承受范围内，即使“看起来还挺可能的”，也还是不要参与的好。 其次，从刘润老师商学院课程中聊到的“心理账户”角度上看，我们即使遇到了“好运气”，因为并没有在追求中作出任何有实质性的努力，这部分的钱，恐怕会被归入自己和身边人“意外所得”这个心理账户：自己和身边人对这个钱没有很强的所有权感，钱因此很容易被花掉（或者被某些人要走/借了不还/帮忙花干净）。也因此，在美国跟踪中奖者的研究中，因为花钱习惯和人际关系被这个”好运气“打乱，鲜少有人最后有善终。这么说来，即使“好运气”不是骗局，也不是每个人，都有处理这个意外的能力的。 结合二者来说，与其汲汲追求小概率的“好运气”，还不如让自己的资源和精力，集中到提升自己能力、赚“自己可以妥善安排的钱”。7小时前作者回复你理解了我的意思～～～ 结合二者来说，与其汲汲追求小概率的“好运气”，还不如让自己的资源和精力，集中到提升自己能力、赚“自己可以妥善安排的钱”。6小时前</span><br><span class="line"></span><br><span class="line">凡五</span><br><span class="line">24 赞</span><br><span class="line"></span><br><span class="line">打从疫情以来，留学生群体内的“杀猪盘”猖獗了不少，有些“杀猪盘”类似于PUA，被骗几十万的都有。 “杀猪盘”是放长线钓大鱼型，他们会和你聊很久，也很懂人心，恨不得每个都是心理学大师，一点点瓦解你的防备。 有不少人觉得自己很幸运，能在网上找到这样的“知己”，殊不知这只是一套组合拳里的一部分。有的“杀猪盘”甚至把别墅豪车什么的，一条龙全给你备好，入世未深的学生/总想着自己可以撞大运的人们，就这么上当了。 而且这个“行业”发展还特快，“分支”可多了，人设从高富帅白富美到平平无奇普通人。 我有一个同学，偶然认识一个“网友”，聊得那是一拍即合，真的把对方当做了好朋友，聊了几个月，那人突然来了一句 — 你需要代写吗？7小时前作者回复偶然认识一个“网友”，聊得那是一拍即合，～～～这样的巧合就有问题6小时前</span><br><span class="line"></span><br><span class="line">李岳洋</span><br><span class="line">19 赞</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">为什么对“巧合”要保持警惕<span class="comment"># 因为近似的正确好过精确的错误。 模糊的正确，好过正确的模糊。 为什么呢？ 因为一个正确的方法得到一个错误的结果，比用一个错误的方法得到一个正确的结果要好得多。 每个人遇到问题的时候，因为解决问题的“高频方式”不同，所以也有了不同的“高频问题”。 比如：牛市总结出来的经验通常可以在熊市帮自己亏更多钱。 看书，学习，思考都是在提升成功的概率，提升运气的运气，而好过一直平庸的轮回。 ●如何提升运气的运气？我来个例子。 2020年参加公司组织“1024程序员欢乐节”，我和一个健身的哥们参加“二人三足”绑腿跑的节目。 赛前，我们开始商讨战略： 1、不第一组参加，作为第二组在旁边先演练下，做好准备。 2、先迈出绑的脚为1，未被绑的脚为2，121212，拉齐认知。 3、把绳子绑高一些，快到膝盖处，这样被限制的程度小一些。 4、拆解如何转弯最快——最后以我未被绑的脚为中心，他一步跨过来。 5、站在起跑线的时候，我机智的想到：把被绑住的脚后撤一步，这样可以比别人提前“半步”。 最终我们赢得了第一名，奖品“榨汁机”。 为什么我们得奖了，因为我们的目标就不一样，有的是参与，有的是为了得奖，我们是为了奔着第一名的奖品去的，并且通过一个一个小步骤提升“运气的运气”，做成了。4小时前</span></span></span><br><span class="line"></span><br><span class="line">Hanskeng 尹桂政</span><br><span class="line">18 赞</span><br><span class="line"></span><br><span class="line">用理性的思维去思考问题，需要一定的理论指导，不过在真实生活中却是非常的好用，就比如说公司地下停车场停车的问题，如果公司有十个车位，在八点上班，在8点5分的时候，你能拿到车位的概率是多少？ 考虑这种问题，需要我们了解泊松概率，然后根据小概率事件发生的期望和分布图去推断特定的场景。 真实生活中，我们可以修炼把决策树思维用得如同呼吸、吃饭一样平常，用以指导自己的行为。这样我们每一步做事都是理性的，不会偏差太多的。但在某些事情上，我倒不推荐什么事情都去用概率指导行动，毕竟，一些艺术性的抉择不是靠概率得出的。11小时前</span><br><span class="line"></span><br><span class="line">伪装</span><br><span class="line">15 赞</span><br><span class="line"></span><br><span class="line">小的时候最喜欢听那些“巧合”的故事，无巧不成书嘛，但是越长大就越是明白，这个世界没有白来的好处，所有的“巧合”背后都有一个代价，即便是这个巧合没有欺骗，就是你运气好，但是你依旧要为此付出代价。 还在上学的时候，我在走了没有一千遍，也有八百遍的宿舍楼门口捡了五百块钱，没有等到失主，就自己昧下了，过了一个月的好生活，那时候我一个月的生活费才两百就够了，一下翻了三倍多，真是有点花天酒地的感觉。 代价很快就来了，接下来的一年里，我不得不面对月月花超生活费的后果，父母虽然多给了一些，但是也没多多少，又因为思想保守不准我出去打工，那一年里总是被“钱不够”折磨，直到我想明白了，钱不是自己的千万不要去碰这个道理，而这也成为了我此后坚持原则。6小时前作者回复谢谢你分享自己亲身经历6小时前</span><br><span class="line"></span><br><span class="line">日光微夏</span><br><span class="line">15 赞</span><br><span class="line"></span><br><span class="line">天上不会掉馅饼，当一切都发生得太过巧合，就有可能是套路，我们要用常识去分辨其中的真伪，若非机缘，就是预谋。 我很喜欢苏轼的一句话：且夫天地之间，物各有主，苟非吾之所有，虽一毫而莫取。 任何东西都是有成本的，我们想要的得靠我们自己去争取！8小时前</span><br><span class="line"></span><br><span class="line">林染</span><br><span class="line">13 赞</span><br><span class="line"></span><br><span class="line">如果你理解了巧合背后的规则，就会发现有些我们以为是“巧合”的事情，背后其实有着必然性。 重要的其实不是你给出的回答，而是你所使用的判断方法。 在做判断时，事实要优先于我们的猜测。但在得不到事实之前，我们要依靠理性和常识去思考和做出判断。 面对那些好得难以置信的事情，想一想好运气背后是否另有原因。 不去肖想额外的所得，也就不会有所失，我只需要获得我应得的就好。9小时前</span><br><span class="line"></span><br><span class="line">KING</span><br><span class="line">13 赞</span><br><span class="line"></span><br><span class="line">保持一个合理的警惕性，其实骗子的招式再多；你只要终止和控制自己的贪欲和贪婪的心，任由他巧舌如簧我自岿然不动。记住天上不会掉馅饼，反而有可能会掉铅球；自己自然而然就会警惕多了。10小时前</span><br><span class="line"></span><br><span class="line">Masir</span><br><span class="line">12 赞</span><br><span class="line"></span><br><span class="line">感谢老师来信~ 天下没有免费的午餐！ 正如老师所讲，每次有好运来临的时候都需要警惕。因为上帝的公平的，它给了你一面，必然会拿走另一面。 也许你的好运最后要用同等的痛苦来抵消！ 最好的态度是通过自己的努力换来同等的收获，这才是人生的意义！10小时前</span><br><span class="line"></span><br><span class="line">任勇</span><br><span class="line">11 赞</span><br><span class="line"></span><br><span class="line">吴军老师，您好： 2019年春节期间，“疟疾抗癌”事件在网络上爆红，中科院广州生物医药与健康研究院的陈小平研究员，在中科院SELF论坛一场公开演讲里介绍了他的研究工作：利用疟原虫成功治疗晚期癌症患者。这项成果起源于他早年学习期间，偶然发现世界范围内疟疾发病率和癌症死亡率的地理分布图，似乎存在负相关的关系，萌生了“疟疾也许能治癌”的初步想法。 他展示的疟疾发病率与全球肿瘤死亡率的分布图中，非洲，南亚，东南亚等疟疾高发地区的癌症总死亡率具有相关性，但是在他的演讲中对两个问题没有很好的答案，一个是这些疟疾高发地区，是全球的贫困落后地区，经济落后，生活环境恶劣，医疗水平低，人均寿命非常低，这些地区癌症总死亡率低是不是因为平均寿命低呢？另外一个问题是，在疟疾高发地区，人民普遍服用抗疟药，以青蒿素、奎宁为主的这些治疗疟疾的药物，是不是也有一定的治疗癌症作用呢？这个巧合的背后，如果还存在很多未解的疑问，因为这个巧合得出的结论，肯定是一个不正确不严谨的结论。 今天来信得到： 1，如果你了解巧合背后的规则，就会发现有些我们以为是“巧合”的事情，背后其实有着必然性。 2，判断一个事情是不是巧合，重要的不是你给出的答案，而是所使用的的判断方法，概率论是最好用的工具。 3，在做判断时，事实要优先于我们的猜测，但在得不到事实之前，我们要依靠理性和常识去思考和做出判断。 4，面对那些好的难以置信的事情，想一想好运气背后是否另有原因； 5，对于一些超级坏运气，不能简单的归结为运气坏，有很大概率是另有原因，我们需要找到这个原因，才能在之后避免“坏运气”。 感谢吴军老师！ 祝： 冬安！ 任勇9小时前作者回复谢谢你的分享，这和过去吃鲨鱼软骨6小时前</span><br><span class="line"></span><br><span class="line">伪装</span><br><span class="line">10 赞</span><br><span class="line"></span><br><span class="line">“巧合”其实无处不在，我们每一个人的出生都是一个堪称奇迹的“巧合”，但这是一个“自然巧合”，是这个世界演化过程中的偶然，不必然出现，但是出现了就是必然的结果。 我们是把“自然巧合”当成这个世界的一些基础认知来看的，毕竟我们每个人出生都不必去追溯那亿万分之一的概率，刮风下雨只看结果就行，天气预报也未必就能准了。 但是“人为巧合”却是最能够迷惑我们，甚至是我们最需要警惕的东西，一旦你面对极度有诱惑的“人为巧合”时，你最需要的是保持平常心，问问自己何德何能，能够遇到这等好事，后面是不是有一个大坑在等你去跳？ 面对“人为巧合”，只要你有一点概率思维，有点数据思维，都可以以最快的速度发现其中的问题，甚至可以辨明哪些是真的机会，哪些是披着机会外衣的危险。6小时前作者回复刮风下雨只看结果就行，天气预报也未必就能准了。～～有些事确实只看结果就行6小时前</span><br><span class="line"></span><br><span class="line">日辰之龙</span><br><span class="line">9 赞</span><br><span class="line"></span><br><span class="line">说一个反过来的案例，就是对于一些超级坏运气，也不能简单归结为运气坏的情况。这个反面案例也非常值得在做投资的同学记住，这是本人花“学费”交出来的。 我在一个朋友的股权基金里投过4个项目，其中3个都是不成功的，另一个还在“孵化”中。对于项目失败的原因，表面上看：一个是企业投资后挪用了资金，一个是碰上疫情经营受挫，一个是股东矛盾影响发展。在和管理人反复了解沟通后，给了我这么一个解释：“股权投资本来就是高风险、高收益的事，投项目10个里能成功1～2个，这是行业是普遍现象。所以，你的项目不成功也是正常的，因为你的运气不好，刚好在2%的成功概率之外。” 乍一听，特别有道理，一点毛病都没有。其它一起投资的朋友都点头数说：“嗯，看来是我运气不好，那要再多投几个项目，比如10个，这样就能有成功的概率，一个成功后就能把其他成本都收回来了。” 正如老师所说，有很大概率背后是另有原因，我们需要找到这个原因，才能在之后避免“坏运气”。 当时我总是觉得这个听起来“很有道理的”理由，总有哪里不对劲，就在得到学习了大量的投资课后，终于理清了思路。 1、管理人的2%成功项目的成功原因是“CEO的个人资源好”，有朋友的关系牵线+管理人的敏锐度分析。 2、至于基金的后期管理，那基本是没有的。因为第一不是大股东没有说话权；第二因为投资金额对公司总股本来说没那么大，连一个董事席位也没有；第三没有产业对接，仅靠一些人脉资源的介绍，对企业只能是锦上添花，还是没有说话权。 3、如果主要是“我运气不好”的因素，那买彩票做投资就好了，为什么还要找人“管理”？ 4、继续投10个项目一定有2%成功的概率吗？我想大概率是“没有可能”，所以就停止一切这类的投资行为，理由很简单： ①管理人个人资源好的项目，那在他心里会有较大把握，这类项目一定是给那些对他关系重要的人，而这个人肯定不是我。 ②后期管理形同虚设，是目前股权投资的普遍现象，还美其名约“不能限制创业者的创业激情”。搞得人性的贪婪在资本市场里都能治愈一样，这就是一个掩耳盗铃的逻辑。 ③既然是投资就是股东，但是股东的作用是不一样的，一类是“财务投资”，一类是“产业投资”。前者就是“只出钱不出力”，后者是“又出钱又出力”，所以前者失败的概率一定比后者高。 ④如果项目失败了，管理人获得了经验，但是学费却是我交的………那还不如自己做这类投资，即使交了学费还学习了知识。6小时前作者回复谢谢你分享自己的情况6小时前</span><br><span class="line">以上留言由 作者 筛选显</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">收藏收藏</span><br><span class="line">回复举报</span><br><span class="line">返回列表发新帖</span><br><span class="line">高级模式</span><br><span class="line">BColorImageLinkQuoteCodeSmilies</span><br><span class="line">您需要登录后才可以回帖 登录 | 立即注册</span><br><span class="line">本版积分规则发表回复 回帖后跳转到最后一页</span><br><span class="line">终生学习社</span><br><span class="line"></span><br><span class="line">GMT+8, 2021-2-17 21:00 , Processed in 0.069306 second(s), 17 queries .</span><br><span class="line"></span><br><span class="line">Powered by Discuz! X3.4</span><br><span class="line"></span><br><span class="line">© 2001-2017 Comsenz Inc.</span><br></pre></td></tr></table></figure><h2 id="地理"><a href="#地理" class="headerlink" title="地理"></a>地理</h2><ul><li><a href="https://www.sohu.com/a/232540474_505355">解密中国地图里暗藏的天机，看完后发现历史和地理统统白学了！</a></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li></li><li></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;思辨！！&lt;/p&gt;</summary>
    
    
    
    <category term="随笔" scheme="http://example.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="阅读" scheme="http://example.com/tags/%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
</feed>
