<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="baidu-site-verification" content="1EB8XoOl0C"><meta name="google-site-verification" content="K7thEgdLm0UfRWJ5MGdF7sCcjClSzAlxFLPv2Oz5CGM"><title> ⭐️数据结构与算法（基础篇） · Hexo</title><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="description" content="⭐️数据结构与算法（基础篇） - John Doe"><meta name="keywords"><meta name="author" content="John Doe"><link rel="short icon" href="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/favicon.ico"><link rel="stylesheet" href="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/bubuzou.css"><link rel="search" type="application/opensearchdescription+xml" href="http://example.com/atom.xml" title="Hexo"><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='//unpkg.com/valine/dist/Valine.min.js'></script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head><body><header><div class="header row"> <a href="/" class="logo-link"><img src="/images/logo.png"></a><ul id="nav_list" class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" data-hover="博文" class="nav-list-link">博文</a></li><li class="nav-list-item"><a href="/archives/" target="_self" data-hover="归档" class="nav-list-link">归档</a></li><li class="nav-list-item"><a href="/about/" target="_self" data-hover="关于" class="nav-list-link">关于</a></li></ul><div class="search"><a id="search_btn" href="#search"></a></div><div id="nav_btn" class="nav-btn"><span></span><span></span><span></span></div></div></header><div class="row scroll-con"><section class="container"><!-- for archive page--><div id="postAr" class="post"><article class="post-block"><h1 class="post-title">⭐️数据结构与算法（基础篇）</h1><div class="post-info">2021-04-02</div><div class="post-content"><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp84xlwx77j30u01tau05.jpg" alt="img"></p>
<span id="more"></span>



<h2 id="学习路线"><a href="#学习路线" class="headerlink" title="学习路线"></a>学习路线</h2><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp85qs1hz5j31400u019a.jpg" alt="img"></p>
<h3 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h3><ul>
<li><input checked="" disabled="" type="checkbox"> 复杂度分析</li>
<li><input checked="" disabled="" type="checkbox"> 数组</li>
<li><input checked="" disabled="" type="checkbox"> 栈</li>
<li><input checked="" disabled="" type="checkbox"> 队列</li>
<li><input checked="" disabled="" type="checkbox"> 链表</li>
<li><input checked="" disabled="" type="checkbox"> 递归</li>
<li><input checked="" disabled="" type="checkbox"> 排序</li>
<li><input checked="" disabled="" type="checkbox"> 二分查找</li>
</ul>
<h3 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h3><ul>
<li><input checked="" disabled="" type="checkbox"> 散列表</li>
<li><input checked="" disabled="" type="checkbox"> 二叉树</li>
<li><input checked="" disabled="" type="checkbox"> 堆</li>
<li><input checked="" disabled="" type="checkbox"> 堆排序</li>
<li><input checked="" disabled="" type="checkbox"> 字符串匹配</li>
<li><input checked="" disabled="" type="checkbox"> Trie🌲</li>
<li><input checked="" disabled="" type="checkbox"> 图的表示</li>
</ul>
<h3 id="第三阶段"><a href="#第三阶段" class="headerlink" title="第三阶段"></a>第三阶段</h3><ul>
<li><input checked="" disabled="" type="checkbox"> 四种算法思想</li>
<li><input checked="" disabled="" type="checkbox"> 跳表</li>
</ul>
<h3 id="第四阶段"><a href="#第四阶段" class="headerlink" title="第四阶段"></a>第四阶段</h3><ul>
<li><input disabled="" type="checkbox"> 红黑树</li>
<li><input checked="" disabled="" type="checkbox"> 哈希算法</li>
<li><input disabled="" type="checkbox"> BM/KMP/AC自动机</li>
</ul>
<h2 id="数据结构、算法概念"><a href="#数据结构、算法概念" class="headerlink" title="数据结构、算法概念"></a>数据结构、算法概念</h2><ul>
<li>什么是数据结构、算法？</li>
</ul>
<p>从广义上讲，<strong>数据结构是指一组数据的存储结构，算法就是操作数据 的一组方法</strong></p>
<p>从狭义上讲，是指某些著名的数据结构和算法，比如队列、栈、堆、二分查找、动态规划等。</p>
<ul>
<li>二者关系</li>
</ul>
<p>数据结构和算法是相辅相成的。<strong>数据结构是为算法服务的，算法要作用在特定的数据结构之上</strong>。 因此，我们无法孤立数据结构来讲算法，也无法孤立算法来讲数据结构。</p>
<blockquote>
<p>比如，因为数组因为具有随机访问的特点，二分查找就需要用数组来存储数据。如果选择链表，则二分查找算法就无法工作了</p>
</blockquote>
<p>数据结构是<strong>静态</strong>的，它只是组织数据的一种方式。如果不在它的基础上操作、构建算法，孤立存在的数据结构就是没用的。</p>
<p>数据结构是为算法服务的，所以具体选择哪种存储方法，与期望支持的操作有关系</p>
<p>算法是一系列程序指令，用于解决特定的运算和逻辑问题；</p>
<p>数据结构是数据的组织、管理和存储形式，使用目的是为了高效地 访问和修改数据。</p>
<p>数据结构是算法的基石。如果把算法比喻为舞者，数据结构则是舞者脚下的舞台。不同的算法会选择不同的数据结构</p>
<p>当我们遇到一个实际问题时，首先需要解决两件事：</p>
<p>（1）如何将数据存储在计算机中；</p>
<p>（2）用什么方法和策略解决问题。</p>
<p><strong>前者是数据结构，后者是算法。</strong>只有数据结构没有算法，相当于只把数据存储到计算机中，而没有有效的方法去处理，就像一幢只有框架的烂尾楼；若只有算法，没有数据结构，就像沙漠里的海市蜃楼，只不过是空中楼阁罢了。</p>
<p><strong>数据</strong>是一切能输入计算机中的信息的总和，结构是指数据之间的关系。数据结构就是将数据及其之间的关系有效地存储在计算机中并进行基本操作。<strong>算法</strong>是对特定问题求解步骤的一种描述，通俗讲就是解决问题的方法和策略。</p>
<p>在遇到一个实际问题时，要充分利用自己所学的数据结构，将数据及其之间的关系有效地存储在计算机中，然后选择合适的算法策略，并用程序高效地实现。这就是Niklaus Wirth教授所说的：“数据结构+算法＝程序”。</p>
<ul>
<li>学习原则</li>
</ul>
<p><strong>要学习它的“来历”“自身的特点”“适合解决的问题”以及“实际的应用场景”</strong></p>
<p><strong>很多时候我们并不是要去死记硬背某个数据结构或者算法，而是要学习它背后的思想和处理技巧，这些东西才是最有价值的</strong>。</p>
<p>学习数据结构最难的不是理解和掌握原理，而是能灵活地将各种场景和问题抽象成对应的数据结构和算法</p>
<p>学习数据结构和算法，并不是为了死记硬背几个知识点。我们的目的是建立时间复杂度、空间复杂 度意识，写出高质􏰁的代码，能够设计基础架构，提升编程技能，训练逻辑思维，积攒人生经验，以此 获得工作回报，实现你的价值，完善你的人生。</p>
<p><strong>掌握了数据结构与算法，你看待问题的深度，解决问题的⻆度就会完全不一样</strong>。因为这样的你，就像是 站在巨人的肩膀上，拿着生存利器行走世界。数据结构与算法，会为你的编程之路，甚至人生之路打开 一扇通往新世界的大⻔。</p>
<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><blockquote>
<p>注意递推公式和递归树求递归复杂度</p>
</blockquote>
<ul>
<li>重要性</li>
</ul>
<p>复杂度分析究竟有多􏰀要呢?可以这么说，它几乎占了数据结构和算法这⻔课的半壁江山，是数据结构和算法学习的<strong>精髓</strong>。</p>
<p>数据结构和算法解决的是如何更省、更快地存储和处理数据的问题，因此，我们就需要一个考􏰁效率和 资源消耗的方法，这就是复杂度分析方法。所以，如果你只掌握了数据结构和算法的特点、用法，但是 没有学会复杂度分析，那就相当于只知道操作口诀，而没掌握心法。<strong>只有把心法了然于胸，才能做到无 招胜有招!</strong></p>
<ul>
<li>O() 复杂度</li>
</ul>
<p>要理解O() 复杂度 的含义，O()并不表示代码真正的执行时间，而是表示<strong>代码执行时间随数据规模增长的变化趋势</strong>，所以大O时间复杂度，也叫渐进时间复杂度，简称时间复杂度。</p>
<blockquote>
<p>更详细的参考：<a target="_blank" rel="noopener" href="http://bigocheatsheet.com/">Know Thy Complexities!</a>：</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqk4qum5uyj31hu0t2npd.jpg" alt="image-20210516115644557"><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqk4v64747j315a0oy4qp.jpg" alt="image-20210516120055333"></p>
</blockquote>
<ul>
<li>时间复杂度量级</li>
</ul>
<p>分为：</p>
<p>1）多项式量级 </p>
<p>2）非多项式量级（NP, non-deterministic polynomial）</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp979osnjzj313o0ibwqu.jpg" alt="IMG_E5863834E01F-1"></p>
<ul>
<li>空间复杂度</li>
</ul>
<p>我们说空间复杂度的时候<u>，是指除了原本的数据存储空间外</u>，算法运行还需要<strong>额外的</strong>存储空间。</p>
<ul>
<li>最好、最坏和平均情况时间复杂度</li>
</ul>
<p>e.g.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// n表示数组array的长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span>[] <span class="built_in">array</span>, <span class="keyword">int</span> n, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> pos = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">array</span>[i] == x) &#123;</span><br><span class="line">       pos = i;</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本例子代码用于在数组中查找变量 x 的位置</p>
<p>对于最好情况，x 刚好在数组的第一个位置，则复杂度为O(1)；</p>
<p>最差情况，不在数组中，则复杂度为O(n)；</p>
<p>当然，这两种情况都比较极端，发生概率不大。考虑**<u>平均时间复杂度</u><strong>，引入</strong>概率分析**。（这里算的是期望）</p>
<blockquote>
<p>我们知道，要查找的变量 x，要么在数组里，要么就不在数组里。这两种情况对应的概率统计起来很麻烦，为了方便你理解，我们假设在数组中与不在数组中的概率都为 1/2。另外，要查找的数据出现在 0～n-1 这 n 个位置的概率也是一样的，为 1/n。所以，根据概率乘法法则，要查找的数据出现在 0～n-1 中任意位置的概率就是 1/(2n)。</p>
<p>因此，前面的推导过程中存在的最大问题就是，没有将各种情况发生的概率考虑进去。如果我们把每种情况发生的概率也考虑进去，那平均时间复杂度的计算过程就变成了这样：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp982ch8m0j313s0ccnap.jpg" alt="image-20210405220945927"></p>
</blockquote>
<p>则最后的平均时间复杂度仍为O(n)</p>
<ul>
<li>均摊时间复杂度</li>
</ul>
<p>对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间<strong>存在前后连贯的时序关系</strong>，这个时候，我们就可以将这一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。而且，在能够应用均摊时间复杂度分析的场合，<strong>一般均摊时间复杂度就等于最好情况时间复杂度</strong>。</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>它可以说是最基础、最简单的数据结构了。数组用一块连续的内存空间，来存储相同类型的一组数据，<strong>最大的特点就是支持随机访问</strong>，但插入、删除操作也因此变得比较低效，平均情况时间复杂度为 O(n)。</p>
<p><strong>数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。</strong></p>
<p>这里需要注意以下几点：</p>
<ul>
<li>第一是<strong>线性表</strong>（Linear List）。顾名思义，线性表就是数据排成像一条线一样的结构。<strong>每个线性表上的数据最多只有前和后两个方向（前驱和后继）</strong>。其实除了数组，链表、队列、栈等也是线性表结构。【注意这里的‘前后’】</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp99afqpnvj30vq0n5acy.jpg" alt="img"></p>
<p>与之对应，<strong>有<u><em>’非线性表‘</em></u>，</strong>数据之间并不是简单的前后关系，如树，图等</p>
<blockquote>
<p>那么有了线性结构，我们为什么还需要非线性结构呢？ </p>
<p>答案是为了高效地兼顾静态操作和动态操作，<strong>我们一般使用树去管理需要大量动态操作的数据</strong>。</p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gv0utfbp1cj61960jajt702.jpg" alt="image-20211002122911606"></p>
<ul>
<li>第二个是连续的内存空间和相同类型的数据—–&gt;<strong>’随机访问‘</strong></li>
</ul>
<p>随机访问的公式如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[i]_address = base_address + i * data_type_size</span><br></pre></td></tr></table></figure>

<p>如下，内存块的首地址为 base_address =1000, data_type_size=4B</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp99htxhu5j30vq0g4jso.jpg" alt="img"></p>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>对于插入，如果数组是有序的， 插入平均复杂度为O(n)【依据概率计算】：（1+2+…+n）/n=O(n)</p>
<p>但是，如果数组存储的数据并没有任何规律，数组只是当做一个存储数据的集合，复杂度可以降为o(1)，如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp99t9lxiyj31100fg77l.jpg" alt="IMG_A2267639DBED-1"></p>
<p>利用这种处理技巧，在特定场景下，在第 k 个位置插入一个元素的时间复杂度就会降为 O(1)。</p>
<p>这个处理思想在<strong>快排中也会用到</strong></p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>和插入类似，如果删除数组末尾的数据，则最好情况时间复杂度为 O(1)；如果删除开头的数据，则最坏情况时间复杂度为 O(n)；平均情况时间复杂度也为 O(n)。</p>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="底层物理结构（与数组对比）"><a href="#底层物理结构（与数组对比）" class="headerlink" title="底层物理结构（与数组对比）"></a>底层物理结构（与数组对比）</h3><p>链表，不需要一块连续的内存空间，通过’指针‘将零散的内存块串联起来使用</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqk42r0cerj31940tghdt.jpg" alt="image-20210516113336149"></p>
<h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqkhexjdpdj31fs0awe24.jpg" alt="image-20210516191501331"></p>
<ul>
<li>代码实现</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;创建链表&#x27;</span></span><br><span class="line"><span class="comment"># 参考：https://jackkuo666.github.io/Data_Structure_with_Python_book/chapter3/section1.html</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;单个结点&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        self.data = item</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleLinkList</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self._head = <span class="literal">None</span>   <span class="comment"># 初始化，创建头指针</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;头部添加元素&#x27;&#x27;&#x27;</span></span><br><span class="line">        node = Node(item)</span><br><span class="line">        node.<span class="built_in">next</span> = self._head</span><br><span class="line">        self._head = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">travel</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;遍历链表&#x27;&#x27;&#x27;</span></span><br><span class="line">        p = self._head</span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            <span class="built_in">print</span>(p.data)</span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">ll = SingleLinkList()</span><br><span class="line">ll.add(<span class="string">&quot;Wed&quot;</span>)</span><br><span class="line">ll.add(<span class="string">&quot;Tue&quot;</span>)</span><br><span class="line">ll.add(<span class="string">&quot;Mon&quot;</span>)</span><br><span class="line"></span><br><span class="line">ll.travel()</span><br><span class="line"></span><br><span class="line">------------------------</span><br><span class="line">Mon</span><br><span class="line">Tue</span><br><span class="line">Wed</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1grok2jc76hj310a05qjso.jpg" alt="image-20210620110934940"></p>
<ul>
<li>插入、删除</li>
</ul>
<p>复杂度均为 O(1)</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqkhhuvnggj31cu0cetpj.jpg" alt="image-20210516191749915"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqkhi1d8r7j31b0098dun.jpg" alt="image-20210516191804109"></p>
<p>访问复杂度：O(n)</p>
<h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p>跟单链表相比，区别是尾结点指针指向链表的头结点</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpah2ovka4j30vq0b33zb.jpg" alt="img"></p>
<p><strong>循环链表</strong>的优点是从链尾到链头比较方便。</p>
<p>当<strong>要处理的数据具有环型结构特点时，就特别适合采用循环链表</strong>。比如著名的约瑟夫问题。</p>
<h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqls41wojpj31cu06snbl.jpg" alt="image-20210517221044722"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqltomwamrj313a07ygyn.jpg" alt="image-20210517230508499"></p>
<h3 id="空间换时间与时间换空间"><a href="#空间换时间与时间换空间" class="headerlink" title="空间换时间与时间换空间"></a>空间换时间与时间换空间</h3><p>对于执行较慢的程序，可以通过消耗更多的内存(空间换时间)来进行优化;</p>
<p>而消耗 过多内存的程序，可以通过消耗更多的时间(时间换空间)来降低内存的消耗。</p>
<h3 id="缓存，Cache"><a href="#缓存，Cache" class="headerlink" title="缓存，Cache"></a>缓存，Cache</h3><p>缓存是一种提高数据读取性能的技术，比如CPU缓存、数据库缓存、浏览器缓存等</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqk3ugftylj30vs06mdrb.jpg" alt="image-20210516112534767"></p>
<p>缓存容量有限，当容量用完时，哪些数据清除和保留就需要一定的策略来决定</p>
<p>缓存淘汰策略一般有三种：</p>
<p>1）先进先出策略 FIFO（First In，First Out）</p>
<p>2）最少使用策略 LFU（Least Frequently Used）</p>
<p>3）最近最少使用策略 <strong>LRU（Least Recently Used）</strong></p>
<ul>
<li>LRU 的几种实现方法</li>
</ul>
<p>1） 单链表法</p>
<p>维护一个有序的单链表，越靠近尾部则是越早之前访问的。</p>
<p>需要根据数据<strong>是否缓存在链表中</strong>，进行不同的删除、插入操作</p>
<p>复杂度O(n)</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqlsj8x0m7j30zc07uk05.jpg" alt="image-20210517222521866"></p>
<p>2）哈希表+双向链表</p>
<p>复杂度则降为O(1)</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqlsazgu0uj30zs0mu7wh.jpg" alt="image-20210517221726786"></p>
<p>3）其它…</p>
<h3 id="数组-VS-链表"><a href="#数组-VS-链表" class="headerlink" title="数组 VS 链表"></a>数组 VS 链表</h3><p>正是因为内存存储的区别，它们插入、删除、随机访问操作的时间复杂度正好相反。</p>
<table>
<thead>
<tr>
<th></th>
<th>数组</th>
<th>链表</th>
</tr>
</thead>
<tbody><tr>
<td>插入、删除</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>随机访问</td>
<td>O(1)</td>
<td>O(n)</td>
</tr>
</tbody></table>
<p>不过，数组和链表的对比，并不能局限于时间复杂度。而且，在实际的软件开发中，不能仅仅利用复杂 度分析就决定使用哪个数据结构来存储数据。</p>
<p>数组简单易用，在实现上使用的是连续的内存空间，可以借助 CPU 的缓存机制，预读数组中的数据，所以访问效率更高。而链表在内存中并不是连续存储，所以对 CPU 缓存不友好，没办法有效预读。</p>
<p>链表本身没有大小 的限制，天然地支持动态扩容。</p>
<p>除此之外，如果你的代码对内存的使用非常苛刻，那数组就更适合你。因为链表中的每个结点都需要消 耗额外的存储空间去存储一份指向下一个结点的指针，所以内存消耗会翻倍。而且，对链表进行频繁的 插入、删除操作，还会导致频繁的内存申请和释放，容易造成内存碎片，如果是 Java 语言，就有可能会 导致频繁的 GC(Garbage Collection，垃圾回收)。</p>
<p>所以，在我们实际的开发中，针对不同类型的项目，要根据具体情况，权衡究竟是选择数组还是链表。</p>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>队列跟栈一样，也是一种操作受限的线性表数据结构。</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gv15cis0thj61cy084t9m02.jpg" alt="image-20211002183322757"></p>
<ul>
<li>数组实现</li>
</ul>
<p>通过 移动head ,tail 控制入队和出队，当tail 移动到数组最右边，需要数据搬移</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gv1687k03lj610m0c8mys02.jpg" alt="image-20211002190353757"></p>
<p>如要避免数据搬移，可采用循环队列：</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gv16dbb5ivj619a0k20va02.jpg" alt="IMG_CA2CC59959D7-1"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, size=<span class="number">100</span></span>):</span></span><br><span class="line">        self.size = size</span><br><span class="line">        self.queue = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size)]</span><br><span class="line">        self.front = <span class="number">0</span>  <span class="comment"># 队首</span></span><br><span class="line">        self.rear = <span class="number">0</span> <span class="comment"># 队尾</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, element</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.is_filled():</span><br><span class="line">            self.rear =(self.rear+<span class="number">1</span>) % self.size</span><br><span class="line">            self.queue[self.rear] = element</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> IndexError(<span class="string">&#x27;queue is filled&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.is_empty():</span><br><span class="line">            self.front = (self.front+<span class="number">1</span>) % self.size</span><br><span class="line">            <span class="keyword">return</span> self.queue[self.front]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> IndexError(<span class="string">&#x27;queue is empty!!&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;判断队空&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.rear==self.front</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_filled</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;判断队满&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> (self.rear+<span class="number">1</span>) % self.size == self.front</span><br><span class="line">---------------------------------------------</span><br><span class="line"></span><br><span class="line">q = Queue(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    q.push(i)</span><br><span class="line"><span class="built_in">print</span>(q.is_filled())</span><br><span class="line"><span class="built_in">print</span>(q.pop())</span><br><span class="line">q.push(<span class="number">4</span>)</span><br></pre></td></tr></table></figure>



<ul>
<li>链表实现</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpblrprhh3j312k0i847d.jpg" alt="IMG_A95FD02F8B3D-1"></p>
<ul>
<li>阻塞队列</li>
</ul>
<p>阻塞 队列其实是在队列的基础上增加了阻塞操作。就是在队列为空的时候，从队头取数据会 被阻塞。因为此时还没有数据可取，直到队列中有了数据才能返回;如果队列已经满了，那么插入数据 的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpcp7bk14nj31720hatu1.jpg" alt="image-20210408221918674"></p>
<p>利用阻塞队列可以轻松实现一个<strong>”生产者-消费者模型“</strong></p>
<p>基于阻塞队列，我们还可以通过协调“生产者”和“消费者”的个数，来提高数据的处理效率</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpcpbogzv3j31dy0g4x4n.jpg" alt="image-20210408222332733"></p>
<ul>
<li>并发队列</li>
</ul>
<p>在多线程情况下，会有多个线程同时操作队列，这个时候就会存在线程安全问题，那如何实现一个线程安全的队列呢?</p>
<p>线程安全的队列我们叫作<strong>并发队列</strong>。最简单直接的实现方式是直接在 enqueue()、dequeue() 方法上加 锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或者取操作。实际上，基于数组的循环队 列，利用 CAS 原子操作，可以实现非常高效的并发队列。这也是循环队列比链式队列应用更加广泛的原 因。</p>
<p>总之，阻塞队列就是入队、出队操作可以阻塞，并发队列就是队列的操作多线程安全</p>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>从栈的操作特性上来看，<strong>栈是一种</strong>“<strong>操作受限</strong>”<strong>的线性表</strong>，只允许在一端插入和删除数据。</p>
<p>事实上，从功能上来说，数组或链表确实可以替代栈，但你要知道，特定的数据结构是对特定场景的抽象，而且，数组或链表暴露了太多的操作接口，操作上的确灵活自由，但使用时就比较不可控，自然也就更容易出错。</p>
<p><strong>当某个数据集合只涉及在一端插入和删除数据，并且满足后进先出、先进后出的特性，这时我们就应该 首选</strong>“<strong>栈</strong>”<strong>这种数据结构</strong>。</p>
<ul>
<li>应用</li>
</ul>
<p>1）函数调用</p>
<p>图中 显示的是，在执行到 add() 函数时，函数调用栈的情况。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpbkmdba7yj31as0n2qv5.jpg" alt="image-20210407225513243"></p>
<p>2）表达式求值</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpbkoah3ybj316r0u0kjl.jpg" alt="image-20210407225706163"></p>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>掌握程度:轻松写出二叉树遍历、八皇后、背包问题、DFS 的递归代码</p>
<ul>
<li>递归的理解</li>
</ul>
<p>递归包括两个过程 ，去的过程叫’递‘，回来的过程叫’归‘，自顶向下。</p>
<p>递归是一种编程技巧</p>
<p> 所谓递归，就是有去有回。</p>
<ul>
<li>特点</li>
</ul>
<p>1）调用自身</p>
<p>2）结束条件</p>
<p>3）子问题拆分</p>
<p><strong>编写递归代码的关键是，只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用 关系，不要试图用人脑去分解递归的每个步骤</strong>。</p>
<p>递归要警惕堆栈溢出和重复计算(👇)</p>
<ul>
<li>递归函数的非递归化</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/bobbypollo/article/details/79891556">理解递归的本质：递归与栈</a></p>
<p>采用数据栈</p>
<blockquote>
<p>我们知道递归函数存在的最大问题是，当递归次数足够大时，会导致函数栈溢出而死机，函数栈的大小一般是一个固定值，对于linux来说一般默认是8M。</p>
<p> 因此，编程老司机会教导我们，不得用递归函数！但递归函数的代码实现实在是简洁啊，不让用？臣妾做不到啊！</p>
<p> 那么问题来了，所有递归函数都能非递归化吗？答案是肯定的。</p>
<p> 本质上讲，对于同一个问题，如果必然要用广义递归的方案来处理，那么狭义递归函数只不过是其中的一种实现方式，如果放弃狭义递归函数的话，我们不得不借助一个额外的数据结构：栈。</p>
<p> 如此看来，无论如何都要用到栈，只不过要么让编译器来维护一个栈（函数栈），要么让程序狗来维护一个栈（数据栈）。</p>
</blockquote>
<p> 这两个栈的区别如下：</p>
<table>
<thead>
<tr>
<th></th>
<th>函数栈</th>
<th>数据栈</th>
</tr>
</thead>
<tbody><tr>
<td>位置</td>
<td>进程的stack区</td>
<td>进程的heap区</td>
</tr>
<tr>
<td>大小限制</td>
<td>小（8M？）</td>
<td>能分配到很大</td>
</tr>
<tr>
<td>每个栈“元素”所需空间</td>
<td>比较大，因为要存储函数上下文</td>
<td>可以设计到很小，比如只存储一个指针</td>
</tr>
<tr>
<td>栈开销</td>
<td>大</td>
<td>可以做的很小</td>
</tr>
<tr>
<td>代码简易程度/可维护性</td>
<td>简洁易读</td>
<td>相对更复杂</td>
</tr>
</tbody></table>
<ul>
<li>应用举例：找最终推荐人</li>
</ul>
<p>一般来说，我们会通过数据库来记录这种推荐关系。在数据库表中，我们可以记录两行数据，其中 actor_id 表示用户 id，referrer_id 表示推荐人 id。</p>
<table>
<thead>
<tr>
<th>actor_id</th>
<th>referrer_id</th>
</tr>
</thead>
<tbody><tr>
<td>B</td>
<td>A</td>
</tr>
<tr>
<td>C</td>
<td>B</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">long findRootReferrerId(long actorId) &#123;</span><br><span class="line">  Long referrerId = select referrer_id from [table] where actor_id = actorId;  # 通过这个缩小规模</span><br><span class="line">  if (referrerId == null) return actorId;   # 终止条件</span><br><span class="line">  return findRootReferrerId(referrerId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用户 C 的“最终推荐人”为用户 A</p>
<ul>
<li>汉诺塔问题</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1guxwwotvuuj60ga05t3yd02.jpg" alt="img"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hanoi</span>(<span class="params">n,a,b,c</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    汉诺塔问题</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    n 个盘子 从a经过b移动到c</span></span><br><span class="line"><span class="string">    步骤：</span></span><br><span class="line"><span class="string">    1 (n-1)个从a--&gt;c--&gt;b</span></span><br><span class="line"><span class="string">    2 n a--&gt;c</span></span><br><span class="line"><span class="string">    3 n-1 从b--&gt;a--&gt;c</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param n:</span></span><br><span class="line"><span class="string">    :param a:</span></span><br><span class="line"><span class="string">    :param b:</span></span><br><span class="line"><span class="string">    :param c:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> n&gt;<span class="number">0</span>:  <span class="comment"># 终止条件</span></span><br><span class="line">        hanoi(n-<span class="number">1</span>, a,c,b)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;moving from <span class="subst">&#123;a&#125;</span>--&gt;<span class="subst">&#123;c&#125;</span>&#x27;</span>)</span><br><span class="line">        hanoi(n-<span class="number">1</span>, b, a,c)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">hanoi(<span class="number">3</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>)</span><br></pre></td></tr></table></figure>



<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>按照复杂度分为：</p>
<table>
<thead>
<tr>
<th>排序算法</th>
<th>时间复杂度</th>
<th>是否基于比较</th>
</tr>
</thead>
<tbody><tr>
<td>冒泡、插入、选择</td>
<td>O(n^2)</td>
<td>✅</td>
</tr>
<tr>
<td>快排，归并</td>
<td>O(nlog(n))</td>
<td>✅</td>
</tr>
<tr>
<td>桶，计数，基数</td>
<td>O(n）</td>
<td>❌</td>
</tr>
</tbody></table>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gv090z6225j61bs0tsgr202.jpg" alt="image-20211001235515892"></p>
<ul>
<li>原地排序</li>
</ul>
<p>指空间复杂度O(1)的排序算法</p>
<ul>
<li>排序稳定性</li>
</ul>
<p>指的是待排序序列中有值相等的元素，经过排序后，<strong>相等元素之间原有的先后顺序不变</strong>，则称<strong>稳定</strong>的排序算法，否则就叫作不稳定的排序算法</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpev7b92qvj31ct0u07wi.jpg" alt="image-20210410191801301"></p>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><blockquote>
<p>思想：通过比较相邻元素，交换位置，每一轮将最值元素通过’冒泡‘浮到边界位置</p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1guyfat4mp4j60w20eot9q02.jpg" alt="image-20210930100111313"></p>
<p>代码实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span>(<span class="params">li</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(li)-<span class="number">1</span>):  <span class="comment"># 趟数，第i趟</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(li)-i-<span class="number">1</span>):  <span class="comment"># 箭头</span></span><br><span class="line">            <span class="keyword">if</span> li[j]&gt;li[j+<span class="number">1</span>]:</span><br><span class="line">                li[j], li[j+<span class="number">1</span>] = li[j+<span class="number">1</span>], li[j]</span><br><span class="line">        <span class="built_in">print</span>(li)</span><br></pre></td></tr></table></figure>

<p>改进：</p>
<p>如果某趟没有发生交换，说明已经排好序了，提前终止</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span>(<span class="params">li</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(li)-<span class="number">1</span>):</span><br><span class="line">        exchange = <span class="literal">False</span>  <span class="comment"># 添加标志位</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(li)-i-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> li[j]&gt;li[j+<span class="number">1</span>]:</span><br><span class="line">                li[j], li[j+<span class="number">1</span>] = li[j+<span class="number">1</span>], li[j]</span><br><span class="line">                exchange=<span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> exchange:</span><br><span class="line">            <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<ul>
<li>复杂度分析：</li>
</ul>
<p>属于原地排序；</p>
<p>由于元素相等时候不进行交换，故为<strong>稳定的；</strong></p>
<p>复杂度O(n^2）</p>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1guyha2cgb1j60di0ast9102.jpg" alt="0cdd46b5a856adfa35000c620539eef4.png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span>(<span class="params">li</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(li)):  <span class="comment"># 摸到的牌下标</span></span><br><span class="line">        j = i-<span class="number">1</span>  <span class="comment"># 手里牌</span></span><br><span class="line">        tmp = li[i]  <span class="comment"># 摸到的牌</span></span><br><span class="line">        <span class="keyword">while</span> li[j]&gt;tmp <span class="keyword">and</span> j&gt;=<span class="number">0</span>:</span><br><span class="line">            li[j+<span class="number">1</span>] = li[j]</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        li[j+<span class="number">1</span>] = tmp  <span class="comment"># 注意这里写到 j+1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>复杂度分析：</li>
</ul>
<p>属于原地排序；</p>
<p>由于元素相等时候不进行移动，故为<strong>稳定的；</strong></p>
<p>2个for循环，复杂度O(n^2）</p>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>希尔排序是插入排序的变形，思路是不断分组——插入排序，直到gap 变为1</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort_gap</span>(<span class="params">li, gap</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;只需要将插入排序的 1--&gt;gap&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(gap,<span class="built_in">len</span>(li)):  <span class="comment"># 摸到的牌下标</span></span><br><span class="line">        j = i-gap  <span class="comment"># 手里牌</span></span><br><span class="line">        tmp = li[i]  <span class="comment"># 摸到的牌</span></span><br><span class="line">        <span class="keyword">while</span> li[j]&gt;tmp <span class="keyword">and</span> j&gt;=<span class="number">0</span>:</span><br><span class="line">            li[j+gap] = li[j]</span><br><span class="line">            j -= gap</span><br><span class="line">        li[j+gap] = tmp</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shell_sort</span>(<span class="params">li</span>):</span></span><br><span class="line">    gap = <span class="built_in">len</span>(li)//<span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> gap&gt;=<span class="number">1</span>:</span><br><span class="line">        insert_sort_gap(li, gap)</span><br><span class="line">        gap //= <span class="number">2</span></span><br></pre></td></tr></table></figure>

<ul>
<li>复杂度</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Shellsort">https://en.wikipedia.org/wiki/Shellsort</a></p>
<p>和选取的 gap 有关</p>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>每轮找到最值元素，然后交换</p>
<p>不稳定</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_sort</span>(<span class="params">li</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(li)-<span class="number">1</span>):  <span class="comment"># 趟数</span></span><br><span class="line">        min_loc = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>,<span class="built_in">len</span>(li)):</span><br><span class="line">            <span class="keyword">if</span> li[j]&lt;li[min_loc]:</span><br><span class="line">                min_loc =j</span><br><span class="line">        li[min_loc], li[i] = li[i], li[min_loc]  <span class="comment"># 交换</span></span><br></pre></td></tr></table></figure>

<ul>
<li>综合比较</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpfsqje6ajj31gw0mqx6q.jpg" alt="image-20210411143808882"></p>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>归并和快排背后 使用的都是分治思想，而分治算法一般都是用递归实现的。</p>
<p><strong>分治是一种解决问题的处理思想， 递归是一种编程技巧</strong>，这二者并不冲突。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpfusgjj5vj311t0u0npe.jpg" alt="image-20210411154915840"></p>
<p>代码：【注意合并过程，代码有打印】</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">递归实现：</span></span><br><span class="line"><span class="string">递推公式： merge_sort(p,r) = merge(merge_sort(p,q),merge_sort(q+1, r))</span></span><br><span class="line"><span class="string">终止条件： p&gt;=r</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">li = [<span class="number">11</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span>(<span class="params">li, p, r</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">if</span> p&gt;=r: <span class="keyword">return</span></span><br><span class="line">    mid = (p+r)//<span class="number">2</span>   <span class="comment"># 中间位置</span></span><br><span class="line">    merge_sort(li, p, mid)</span><br><span class="line">    merge_sort(li, mid+<span class="number">1</span>, r)</span><br><span class="line">    merge(li, p, mid, r)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">li, p, mid, r</span>):</span></span><br><span class="line">    tmp = []  <span class="comment"># 申请临时数组，存放merge 结果</span></span><br><span class="line">    i= p</span><br><span class="line">    j = mid+<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i&lt;=mid <span class="keyword">and</span> j&lt;=r:</span><br><span class="line">        <span class="keyword">if</span> li[i]&lt;=li[j]:  <span class="comment"># ‘=’保证是稳定的</span></span><br><span class="line">            tmp.append(li[i])</span><br><span class="line">            i +=<span class="number">1</span> </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            tmp.append(li[j])</span><br><span class="line">            j +=<span class="number">1</span></span><br><span class="line">    <span class="comment"># while 执行完肯定有一部分没数了</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> i&lt;=mid: <span class="comment"># 说明这部分还没取完</span></span><br><span class="line">        tmp.append(li[i])</span><br><span class="line">        i +=<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> j&lt;=r: <span class="comment"># 说明这部分还没取完</span></span><br><span class="line">        tmp.append(li[j])</span><br><span class="line">        j +=<span class="number">1</span></span><br><span class="line">    li[p:r+<span class="number">1</span>] = tmp</span><br><span class="line">    <span class="built_in">print</span>(tmp)</span><br><span class="line">    </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;原始序列<span class="subst">&#123;li&#125;</span>&#x27;</span>)</span><br><span class="line">merge_sort(li, <span class="number">0</span>, <span class="built_in">len</span>(li)-<span class="number">1</span>)</span><br><span class="line">li</span><br><span class="line">----</span><br><span class="line">原始序列[<span class="number">11</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>]</span><br><span class="line">[<span class="number">8</span>, <span class="number">11</span>]</span><br><span class="line">[<span class="number">3</span>, <span class="number">9</span>]</span><br><span class="line">[<span class="number">3</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">11</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">7</span>]</span><br><span class="line">[<span class="number">2</span>, <span class="number">5</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">7</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">11</span>]   <span class="comment"># 注意合并过程与⤴️图一致</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>复杂度分析：</li>
</ul>
<p>空间复杂度O(n), 不属于原地排序；</p>
<p><strong>稳定的</strong>， 可由<code>if li[i]&lt;=li[j]: tmp.append(li[i])</code> 保证</p>
<p>复杂度O(nlg(n)）</p>
<h3 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h3><p>快排，也是采用分治思想</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 递推公式：</span></span><br><span class="line"><span class="comment"># quick_sort(p…r) = quick_sort(p…q-1) + quick_sort(q+1… r)</span></span><br><span class="line"><span class="comment"># 终止条件：</span></span><br><span class="line"><span class="comment"># p &gt;= r</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span>(<span class="params">li, p, r</span>):</span></span><br><span class="line">    <span class="keyword">if</span> p&lt;r:</span><br><span class="line">        q = partition(li, p, r)   <span class="comment"># 获分区点</span></span><br><span class="line">        quick_sort(li, p, q-<span class="number">1</span>)</span><br><span class="line">        quick_sort(li, q+<span class="number">1</span>, r)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span>(<span class="params">li, p, r</span>):</span></span><br><span class="line">    pivot = li[p]  <span class="comment"># 选队首为比较点</span></span><br><span class="line">    <span class="keyword">while</span> p&lt;r:</span><br><span class="line">        <span class="keyword">while</span> li[r]&gt;=pivot <span class="keyword">and</span> p&lt;r:  <span class="comment"># 从右边找，比 pivot小的</span></span><br><span class="line">            r -= <span class="number">1</span></span><br><span class="line">        li[p] = li[r]  <span class="comment"># 写空位</span></span><br><span class="line">        <span class="keyword">while</span> li[p] &lt;=pivot <span class="keyword">and</span> p&lt;r:</span><br><span class="line">            p += <span class="number">1</span></span><br><span class="line">        li[r] = li[p]</span><br><span class="line">    li[p] = pivot  <span class="comment"># p/r相遇,归位</span></span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">li = [<span class="number">13</span>,<span class="number">11</span>,<span class="number">25</span>,<span class="number">7</span>,<span class="number">19</span>,<span class="number">3</span>]      </span><br><span class="line">quick_sort(li, <span class="number">0</span>, <span class="built_in">len</span>(li)-<span class="number">1</span>)</span><br><span class="line">li</span><br></pre></td></tr></table></figure>

<p>关于<code>def partition(li, p, r)   # 获分区点</code>函数的解释：</p>
<p>黑框内为待替换位置，也是最终的返回位置，随着递推，p、r越来越接近。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpg0782djyj314w0rekef.jpg" alt="image-20210411185628255"></p>
<p>快排时间复杂度：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">T(1) = C；   n=1时，只需要常量级的执行时间，所以表示为C。</span><br><span class="line">T(n) = 2*T(n/2) + n； n&gt;1</span><br></pre></td></tr></table></figure>

<p>T(n) = O(nlogn)</p>
<h3 id="快排与归并-的比较"><a href="#快排与归并-的比较" class="headerlink" title="快排与归并 的比较"></a>快排与归并 的比较</h3><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpg0ev9ov4j31do0ti4qq.jpg" alt="image-20210411190349148"></p>
<p>可以发现，归并排序的处理过程是<strong>由下到上</strong>的，先处理子问题，然后再合并。而快排正好相反，它的处 理过程是<strong>由上到下</strong>的，先分区，然后再处理子问题。归并排序虽然是稳定的、时间复杂度为 O(nlogn) 的 排序算法，但是它是非原地排序算法。我们前面讲过，归并之所以是非原地排序算法，主要原因是合并 函数无法在原地执行。快速排序通过设计巧妙的原地分区函数，可以实现原地排序，解决了归并排序占 用太多内存的问题。</p>
<blockquote>
<p>问题：O(n) 时间复杂度内求无序数组中的第 K 大元素。</p>
<p>利用快排，经过一次快排，得到A[0,1,…,p-1], A[p], A[p+1,…,n-1]</p>
<p>然后根据K与p大小关系，进行递归，每次减半</p>
<p>复杂度：n+n/2+…+1=O(n)</p>
<p>代码：参见力扣：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">https://leetcode-cn.com/problems/kth-largest-element-in-an-array/</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="comment">#  [3,2,1,5,6,4] 和 k = 3</span></span><br><span class="line">        <span class="comment"># &quot;采用快排思想&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">li, p, r</span>):</span></span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">            q = partition(li, p,r)</span><br><span class="line">            <span class="keyword">if</span> q+<span class="number">1</span>==k:</span><br><span class="line">                <span class="keyword">return</span> li[q]</span><br><span class="line">            <span class="keyword">elif</span> q+<span class="number">1</span>&gt;k:</span><br><span class="line">                <span class="keyword">return</span> helper(li, p, q-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> helper(li, q+<span class="number">1</span>, r)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">partition</span>(<span class="params">li, p, r</span>):</span></span><br><span class="line">            pivot = li[p]  <span class="comment"># 选队首为比较点</span></span><br><span class="line">            <span class="keyword">while</span> p&lt;r:</span><br><span class="line">                <span class="keyword">while</span> li[r]&lt;=pivot <span class="keyword">and</span> p&lt;r:</span><br><span class="line">                    r -= <span class="number">1</span></span><br><span class="line">                li[p] = li[r]</span><br><span class="line">                <span class="keyword">while</span> li[p] &gt;=pivot <span class="keyword">and</span> p&lt;r:</span><br><span class="line">                    p += <span class="number">1</span></span><br><span class="line">                li[r] = li[p]</span><br><span class="line">            li[p] = pivot  <span class="comment"># p/r相遇,得到</span></span><br><span class="line">            <span class="keyword">return</span> p</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> helper(nums, <span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

</blockquote>
<h3 id="复杂度O-n-排序"><a href="#复杂度O-n-排序" class="headerlink" title="复杂度O(n)排序"></a>复杂度O(n)排序</h3><p>它们均不涉及元素之间的比较操作</p>
<ul>
<li>计数排序</li>
</ul>
<p>计数排序其实是桶排序的一种特殊情况</p>
<p>时间复杂度：O(n+K)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">counting_sort</span>(<span class="params">li</span>):</span></span><br><span class="line">    max_num = <span class="built_in">max</span>(li)</span><br><span class="line">    count_li = [<span class="number">0</span>] * (max_num + <span class="number">1</span>)  <span class="comment"># 计数列表</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> li:</span><br><span class="line">        count_li[num] += <span class="number">1</span></span><br><span class="line">    li.clear()</span><br><span class="line">    <span class="keyword">for</span> i,v <span class="keyword">in</span> <span class="built_in">enumerate</span>(count_li):</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(v):</span><br><span class="line">            li.append(i)</span><br></pre></td></tr></table></figure>

<p>缺点：</p>
<p>1）当数列最大、最小值差距过大时</p>
<p>意味着，空间的极大浪费</p>
<p>2）小数</p>
<ul>
<li>桶排序</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gv089dd00cj60o209k0tf02.jpg" alt="image-20211001232844068"></p>
<ul>
<li>基数排序</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gv08qbo2ndg60s40fywic02.gif" alt="img"></p>
<ul>
<li>比较</li>
</ul>
<p>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p>
<p><strong>基数排序：</strong>根据键值的每位数字来分配桶；</p>
<p><strong>计数排序：</strong>每个桶只存储单一键值；</p>
<p><strong>桶排序：</strong>每个桶存储一定范围的数值；</p>
<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1guxyd2a1mmj60xg0c4dgf02.jpg" alt="image-20210930001510344"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span>(<span class="params">li, val</span>):</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = <span class="built_in">len</span>(li)-<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:  <span class="comment"># 候选区有值</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">        mid = (left+right)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> li[mid]==val:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">elif</span> li[mid]&gt;val:  <span class="comment"># 待查找的值在 mid 左侧</span></span><br><span class="line">            right = mid-<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>: <span class="comment"># 待查找的值在 mid 右侧</span></span><br><span class="line">            left = mid+<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">----------</span><br><span class="line">li = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>))</span><br><span class="line"><span class="built_in">print</span>(binary_search(li, <span class="number">3</span>))</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(lgn)</p>
<p>递归和非递归代码参见：<a target="_blank" rel="noopener" href="https://github.com/flitdu/consult/blob/main/jupyter/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.ipynb"><strong>二分查找.ipynb</strong> </a></p>
<ul>
<li>适用场景</li>
</ul>
<p>二分查找只能用<strong>在插入、删除操作不频繁，一次排序多次查找的场景中</strong>。针对动态变化的数据集合，二分查找将不再适用。那针对动态数据集合，如何在其中快速查找某个数据呢?别急，等到二叉树 那一节我会详细讲。</p>
<ul>
<li>二分查找变形</li>
</ul>
<ol>
<li>变体一:查找第一个值等于给定值的元素</li>
<li>变体二:查找最后一个值等于给定值的元素</li>
<li>变体三:查找第一个 ≥ 给定值的元素</li>
<li>变体四:查找最后一个 ≤ 给定值的元素</li>
</ol>
<p>参见：<a target="_blank" rel="noopener" href="https://github.com/flitdu/consult/blob/main/jupyter/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.ipynb"><strong>二分查找.ipynb</strong> </a></p>
<h2 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h2><p>应用场景：Redis用跳表实现有序集合</p>
<p>跳表是一种各方面性能都比较优秀的<strong>动态数据结构</strong>，可以支持快速地插入、删除、查找操作，写起来也不复杂，甚至可以替代红黑树(Red-black tree)。</p>
<blockquote>
<p>链表+多级索引 = 跳表：</p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpksnctla0j31dy0oge81.jpg" alt="image-20210415222252327"></p>
<ul>
<li>查询时间复杂度</li>
</ul>
<p>假设索引 h 级，最高索引有2个结点。那么整个跳表高度为：log(n)</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpkstbauktj31eq0n8hdt.jpg" alt="image-20210415222838932"></p>
<p>单层索引最多需要遍历3个结点，所以整体的复杂度为O(log(n))</p>
<p>此外，插入、删除的复杂度也为O(log(n))</p>
<ul>
<li>空间复杂度</li>
</ul>
<p>将所有索引的节点数相加得到：</p>
<p> n/2+n/4+n/8…+8+4+2=n-2。所以，跳表的空间复杂度是 O(n)。</p>
<ul>
<li>索引的动态更新</li>
</ul>
<p>如果不停地往跳表中插入数据，而不更新索引，极端情况下会退化成单链表，如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpkt0roo8tj310o0ggdzt.jpg" alt="image-20210415223548875"></p>
<p>作为一种动态数据结构，我们需要某种手段来维护索引与原始链表大小之间的平衡，也就是说，如果链 表中结点多了，索引结点就相应地增加一些，避免复杂度退化，以及查找、插入、删除操作性能下降。</p>
<p>而跳表是<strong>通过随机函数来维护前面提到的“平衡性”</strong>：</p>
<p>我们通过一个随机函数，来决定将这个结点插入到哪几级索引中，比如随机函数生成了值 K，那我们就 将这个结点添加到第一级到第 K 级这 K 级索引中。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpkt26cslsj319p0u0npd.jpg" alt="image-20210415223709920"></p>
<h2 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h2><p>散列表英文名叫’Hash Table‘，又称’哈希表‘</p>
<p><strong>散列表用的是数组支持下标随机访问数据的特性，所以散列表其实是数组的一种扩展，由数组演化而来</strong>。可以说，没有数组，就没有散列表。</p>
<ul>
<li>原理</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpkusfq4luj315y0pkb29.jpg" alt="image-20210415233700091"></p>
<p>注意，哈希函数哈希的是key ,因此，在dict中查找某个key是否存在操作的时间复杂度为o（1）；查找某个value是否存在操作的时间复杂度为o（n）</p>
<ul>
<li>散列冲突</li>
</ul>
<p>1）开放寻址法</p>
<p>开放寻址法的核心思想是，如果出现了散列冲突，我们就􏰂新探测一个空闲位置，将其插入</p>
<p><a target="_blank" rel="noopener" href="https://python123.io/index/topics/data_structure/hash_table">Python 数据结构入门 - 哈希表（Hash Table）</a></p>
<p>2）链表法</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqh6w5md10j318u0ieu0x.jpg" alt="image-20210420233812543"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        self.data = data</span><br><span class="line">        self.pre = <span class="literal">None</span></span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        value = <span class="string">&#x27;[%d]&#x27;</span> % (self.data)</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HashTable</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    散列表的实现（链接法）</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, size= <span class="number">10</span></span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param size: 散列表大小</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.table = [<span class="literal">None</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size)]</span><br><span class="line">        self.number = <span class="number">0</span>  <span class="comment"># 元素个数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_hash</span>(<span class="params">self, key</span>):</span></span><br><span class="line">        <span class="comment">#定义散列函数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(key) % <span class="built_in">len</span>(self.table)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self, key</span>):</span></span><br><span class="line">        k = self._<span class="built_in">hash</span>(key)</span><br><span class="line">        node = Node(key)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.table[k] <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># 空</span></span><br><span class="line">            self.table[k] = node</span><br><span class="line">            self.number += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 遍历链表</span></span><br><span class="line">            p = self.table[k]</span><br><span class="line">            <span class="comment"># 1）存在的话退出</span></span><br><span class="line">            <span class="keyword">while</span> p:</span><br><span class="line">                <span class="keyword">if</span> p.data == node.data:</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                p = p.<span class="built_in">next</span></span><br><span class="line">            <span class="comment"># 2）不在链表的话插入</span></span><br><span class="line">            node.<span class="built_in">next</span> = self.table[k]</span><br><span class="line">            self.table[k].pre = node</span><br><span class="line">            self.table[k] = node</span><br><span class="line">            self.number += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;插入:<span class="subst">&#123;node&#125;</span>&#x27;</span>)</span><br><span class="line">        self.<span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">self, key</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">        k = self._<span class="built_in">hash</span>(key)</span><br><span class="line">        node = Node(key)</span><br><span class="line">        <span class="keyword">if</span> self.table[k] <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># 空</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;del <span class="subst">&#123;node&#125;</span> 无效&#x27;</span>)</span><br><span class="line">            self.<span class="built_in">print</span>()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 遍历链表</span></span><br><span class="line">            p = self.table[k]</span><br><span class="line">            <span class="comment"># 1）存在的话删除</span></span><br><span class="line">            <span class="keyword">while</span> p:</span><br><span class="line">                <span class="keyword">if</span> p.data == node.data:</span><br><span class="line">                    <span class="keyword">if</span> p.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># 尾节点</span></span><br><span class="line">                        self.table[k]=<span class="literal">None</span></span><br><span class="line">                    <span class="keyword">elif</span> p.pre <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># 头节点</span></span><br><span class="line">                        self.table[k]=p.<span class="built_in">next</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        p.pre.<span class="built_in">next</span> = p.<span class="built_in">next</span></span><br><span class="line">                        p.<span class="built_in">next</span>.pre = p.pre</span><br><span class="line">                    self.number -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                p = p.<span class="built_in">next</span></span><br><span class="line">            <span class="comment"># 2）不在链表的话退出</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print</span>(<span class="params">self</span>):</span> <span class="comment">#可视化散列表</span></span><br><span class="line">        res = [<span class="literal">None</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.table))]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.table)):</span><br><span class="line">            p = self.table[i]</span><br><span class="line">            line = <span class="string">&#x27;&#x27;</span></span><br><span class="line">            <span class="keyword">while</span> p:</span><br><span class="line">                line += <span class="string">&#x27;%s&#x27;</span> %p</span><br><span class="line">                p = p.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">if</span> p:</span><br><span class="line">                    line += <span class="string">&#x27;&lt;=&gt;&#x27;</span></span><br><span class="line">            res[i] = line</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;res&#125;</span>, 元素个数：<span class="subst">&#123;self.number&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ht = HashTable()</span><br><span class="line"><span class="built_in">print</span>(ht.table)</span><br><span class="line"></span><br><span class="line">ht.insert(<span class="number">3</span>)</span><br><span class="line">ht.insert(<span class="number">90</span>)</span><br><span class="line">ht.insert(<span class="number">0</span>)</span><br><span class="line">ht.insert(<span class="number">0</span>)  <span class="comment"># 重复插入0，忽视</span></span><br><span class="line">ht.insert(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">ht.delete(<span class="number">2</span>)</span><br><span class="line">ht.delete(<span class="number">0</span>)</span><br><span class="line">ht.<span class="built_in">print</span>()</span><br><span class="line">ht.delete(<span class="number">3</span>)</span><br><span class="line">ht.<span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">ht.delete(<span class="number">10</span>)</span><br><span class="line">ht.<span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">ht.delete(<span class="number">90</span>)</span><br><span class="line">ht.<span class="built_in">print</span>()</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<blockquote>
<p>课后题</p>
</blockquote>
<blockquote>
<p>\1. 假设我们有 10 万条 URL 访问日志，如何按照访问次数给 URL 排序？</p>
<p>遍历 10 万条数据，以 URL 为 key，访问次数为 value，存入散列表，同时记录下访问次数的最大值 K，时间复杂度 O(N)。</p>
<p>如果 K 不是很大，可以使用桶排序，时间复杂度 O(N)。如果 K 非常大（比如大于 10 万），就使用快速排序，复杂度 O(NlogN)。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="string">&#x27;sdfg&#x27;</span>:<span class="number">1</span>, <span class="string">&#x27;zzjk&#x27;</span>:<span class="number">9</span>, <span class="string">&#x27;ooo&#x27;</span>:<span class="number">4</span>, <span class="string">&#x27;ww.s&#x27;</span>:<span class="number">3</span>&#125;</span><br><span class="line"><span class="built_in">sorted</span>(a.items(), key = <span class="keyword">lambda</span> item:item[<span class="number">1</span>])</span><br><span class="line">-----------------------------------</span><br><span class="line">[(<span class="string">&#x27;sdfg&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;ww.s&#x27;</span>, <span class="number">3</span>), (<span class="string">&#x27;ooo&#x27;</span>, <span class="number">4</span>), (<span class="string">&#x27;zzjk&#x27;</span>, <span class="number">9</span>)]</span><br></pre></td></tr></table></figure>

<p>\2. 有两个字符串数组，每个数组大约有 10 万条字符串，如何快速找出两个数组中相同的字符串？</p>
<p>以第一个字符串数组构建散列表，key 为字符串，value 为出现次数。再遍历第二个字符串数组，以字符串为 key 在散列表中查找，如果 value 大于零，说明存在相同字符串。时间复杂度 O(N)。</p>
</blockquote>
<ul>
<li>如何设计工业级的散列表</li>
</ul>
<p><strong>主要考虑：如何设计散列函数，如何根据装载因子动态扩容，以及如何选择散列冲突解决方法：</strong></p>
<p>关于散列函数的设计，我们要尽可能让散列后的值随机且均匀分布，这样会尽可能地减少散列冲突，即便冲突之后，分配到每个槽内的数据也比较均匀。除此之外，散列函数的设计也不能太复杂，太复杂就 会太耗时间，也会影响散列表的性能。</p>
<p>关于散列冲突解决方法的选择，我对比了开放寻址法和链表法两种方法的优劣和适应的场景。大部分情 况下，链表法更加普适。而且，我们还可以通过将链表法中的链表改造成其他动态查找数据结构，比如 红黑树，来避免散列表时间复杂度退化成 O(n)，抵御散列碰撞攻击。但是，对于小规模数据、装载因子 不高的散列表，比较适合用开放寻址法。</p>
<p>对于动态散列表来说，不管我们如何设计散列函数，选择什么样的散列冲突解决方法。随着数据的不断 增加，散列表总会出现装载因子过高的情况。这个时候，我们就需要启动动态扩容。</p>
<ul>
<li>散列表和链表的组合使用</li>
</ul>
<blockquote>
<p>案例：LRU缓存淘汰算法</p>
</blockquote>
<p>单链表实现的复杂度为O(n)</p>
<p>借助散列表，实现复杂度O(1):</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gprrdtw0puj318c0rinpd.jpg" alt="image-20210421225756369"></p>
<h2 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h2><p>哈希算法的定义和原理非常简单，基本上一句话就可以概括了。将任意⻓度的二进制值串映射为固定⻓ 度的二进制值串，这个映射的规则就是<strong>哈希算法</strong>，而通过原始数据映射之后得到的二进制值串就是<strong>哈希值</strong>。</p>
<p>但是，要想设计一个优秀的哈希算法并不容易，需要满足的几点要求:</p>
<ol>
<li>从哈希值不能反向推导出原始数据(所以哈希算法也叫单向哈希算法);</li>
</ol>
<p>2)对输入数据非常敏感，哪怕原始数据只修改了一个 Bit，最后得到的哈希值也大不相同; </p>
<p>3)散列冲突的概率要很小，对于不同的原始数据，哈希值相同的概率非常小; </p>
<p>4)哈希算法的执行效率要尽􏰃高效，针对较⻓的文本，也能快速地计算出哈希值。</p>
<p><strong>根据’鸽巢原理‘，哈希算法无法做到零冲突。</strong></p>
<blockquote>
<p>我们知道，哈希算法产生的哈希值的⻓度是固定且有限的。比如前面举的 MD5 的例子，哈希值是固定 的 128 位二进制串，能表示的数据是有限的，最多能表示 2^128 个数据，而我们要哈希的数据是无穷的。基于鸽巢原理，如果我们对 2^128+1 个数据求哈希值，就必然会存在哈希值相同的情况</p>
</blockquote>
<ul>
<li>应用之安全加密</li>
</ul>
<ol>
<li><p><strong>MD5</strong>(MD5 Message-Digest Algorithm，MD5 消息摘要算法)</p>
</li>
<li><p><strong>SHA</strong>(Secure Hash Algorithm，安全散列算法)</p>
</li>
</ol>
<p>除了这两个之外，当然还有很多其他加密算法，比如 DES(Data Encryption Standard，数据加密标 准)、AES(Advanced Encryption Standard，高级加密标准)。</p>
<ul>
<li>分布式系统中应用</li>
</ul>
<p>负载均衡、数据分片（Mapreduce设计思想）、分布式存储等</p>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>树其实是一种特殊的<code>图</code>，是一种无环连通图，是一种极大无环图，也是一种极小连通图。</p>
<p>从另一个角度看，树是一种递归的数据结构</p>
<ul>
<li>基本概念</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gprsbh1igpj30ye0hc1ee.jpg" alt="image-20210421233018284"></p>
<blockquote>
<p>如果树有 n 个顶点，那么其就有 n - 1 条边，这说明了树的顶点数和边数是同阶的。</p>
<p>任何一个节点到根节点存在<code>唯一</code>路径，路径的长度为节点所处的深度</p>
</blockquote>
<p>实际使用的树有可能会更复杂，比如使用在游戏中的碰撞检测可能会用到四叉树或者八叉树。以及 k 维的树结构 <code>k-d 树</code>等。</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gro06z8x5bj306y06mdft.jpg" alt="img"></p>
<p>二叉树是节点度数不超过二的树，是树的一种特殊子集，有趣的是二叉树这种被限制的树结构却能够表示和实现所有的树</p>
<ul>
<li>二叉树存储</li>
</ul>
<ol>
<li>链式存储</li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gprsjj29roj312w0qwe67.jpg" alt="image-20210421233803644"></p>
<ol start="2">
<li>基于数组的顺序存储</li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gprsnic8hyj312a0liat9.jpg" alt="image-20210421234153502"></p>
<p>如果<strong>某棵二叉树是一棵完全二叉树，那用数组存储无疑是最节省内存的</strong>一种方式。因为数组的存储方式并不需要像链式存储法那样，要存储额外的左右子节点的指针。这也是为什么完全二叉树会单􏰁拎出来的原因，也是为什么完全二叉树要求最后一层的子节点<strong>都靠左</strong>的原因。</p>
<ul>
<li>遍历</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gprtep5idfj31e40j8hdt.jpg" alt="image-20210422000801073"></p>
<p>时间复杂度O(n)，参考递归时间复杂度分析：f(n)=2*f(n/2)+1,且f(1)=1—-&gt;O(n)</p>
<p>层序遍历？？？【结合队列】</p>
<ul>
<li>二叉查找树</li>
</ul>
<p><strong>二叉查找树要求，在树中的任意一个节点，其左子树中的每个节 点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值。</strong></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqh6wj75snj31a80em4fd.jpg" alt="image-20210422233911033"></p>
<p><strong>中序遍历二叉查找树，可以输出有 序的数据序列，时间复杂度是</strong> O(n)<strong>，非常高效</strong>。因此，二叉查找树也叫作二叉排序树。</p>
<ul>
<li>红黑树</li>
</ul>
<p>为了避免复杂度的退化，引入<strong>平衡</strong>二叉查找树，红黑树就是其中的一种</p>
<p>在 1972 年由鲁道夫·贝尔发明，被称为”对称二叉 B 树”，它现代的名字源于 Leo J. Guibas 和 Robert Sedgewick 于 1978 年写的一篇论文。红黑树的结构复杂，但它的操作有着良好的最坏情况运行时间，并且在实践中高效：它可以在 O(logn) 时间内完成查找，插入和删除，这里的 n 是树中元素的数目</p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>堆其实是一种优先级队列，在很多语言都有对应的内置数据结构</p>
<p><code>需要满足下面两个条件</code>：</p>
<p>1.堆是一个完全二叉树;</p>
<p>2.堆中每一个节点的值都必须大于等于(或小于等于)其子树中每个节点的值。</p>
<p>由于堆是完全二叉树，所以用数组来存储会非常省空间，且单纯通过数组下标就可定位左右子节点和父节点</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1guzv2zvv9nj616o0hm42002.jpg" alt="IMG_9CBB656E4D45-1"></p>
<ul>
<li>堆排序</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sift</span>(<span class="params">li, low, high</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    向下调整实现</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param li: 列表</span></span><br><span class="line"><span class="string">    :param low: 堆的根节点位置</span></span><br><span class="line"><span class="string">    :param high: 堆的最后一个元素位置</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    i = low  <span class="comment"># i 指向根节点</span></span><br><span class="line">    j = <span class="number">2</span>*i+<span class="number">1</span>  <span class="comment"># j 开始是左孩子</span></span><br><span class="line">    tmp = li[low]  <span class="comment"># 把堆顶存起来</span></span><br><span class="line">    <span class="keyword">while</span> j&lt;=high: <span class="comment"># 只要j位置有数</span></span><br><span class="line">        <span class="keyword">if</span> j+<span class="number">1</span>&lt;=high <span class="keyword">and</span> li[j+<span class="number">1</span>]&gt;li[j]:  <span class="comment"># 右孩子有，且右孩子大</span></span><br><span class="line">            j = j+<span class="number">1</span>  <span class="comment"># j 换到右孩子分支</span></span><br><span class="line">        <span class="keyword">if</span> li[j]&gt;tmp:</span><br><span class="line">            li[i] = li[j]  <span class="comment"># 上去</span></span><br><span class="line">            i =j  <span class="comment"># 往下看一层</span></span><br><span class="line">            j = <span class="number">2</span>*i +<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            li[i]=tmp  <span class="comment"># 把 tmp 放到某一级领导的位置,此行代码可不写</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    li[i]= tmp  <span class="comment"># i到了叶子节点，需要将tmp 放过去</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heap_sort</span>(<span class="params">li</span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(li)</span><br><span class="line">    <span class="comment"># 建堆，此处为 大根堆</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>((n-<span class="number">2</span>)//<span class="number">2</span>, -<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">        <span class="comment"># i 表示建堆时候需要调整部分的根的下标</span></span><br><span class="line">        sift(li, i, n-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">        <span class="built_in">print</span>(i,<span class="string">&#x27;!!&#x27;</span>)</span><br><span class="line">        <span class="comment"># i指向待处理堆的最后一个元素</span></span><br><span class="line">        li[i], li[<span class="number">0</span>] = li[<span class="number">0</span>], li[i]</span><br><span class="line">        sift(li, <span class="number">0</span>, i-<span class="number">1</span>)  <span class="comment"># i-1 是新的high</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">li = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line">random.shuffle(li)</span><br><span class="line"><span class="built_in">print</span>(li)</span><br><span class="line">heap_sort(li)</span><br><span class="line"><span class="built_in">print</span>(li)</span><br></pre></td></tr></table></figure>

<p>过程：</p>
<p>1） 建堆</p>
<p>从最后一个非叶子节点开始，’农村包围城市‘</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1guzvcji4emj60u00ug7an02.jpg" alt="image-20211001160159720"></p>
<p>2）堆顶元素取回</p>
<p>3）向下调整</p>
<p>4）重复2）</p>
<blockquote>
<p>堆排序不稳定</p>
</blockquote>
<ul>
<li>堆 的应用</li>
</ul>
<p>1）优先级队列</p>
<p>队列是先进先出，不过优先级队列则是优先级最高的，最先出队</p>
<p>一个堆，就可以看作一个优先级队列</p>
<p>后面的许多数据结构，如赫尔曼编码、图的最短路径、最小生成树算法等都要依赖它</p>
<p>如，合并有序小文件</p>
<blockquote>
<p>假设我们有 100 个小文件，每个文件的大小是 100MB，每个文件中存储的都是有序的字符串。我们希望将这些 100 个小文件合并成一个有序的大文件。这里就会用到优先级队列。</p>
</blockquote>
<p>通过建立堆(大小为文件个数)，通过不停地 ‘堆顶写入–删除—插入’ 来实现复杂度O(log n)，其中n 表示堆中数据个数</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gr20z3neoij61140t27aq02.jpg" alt="image-20210531232612740"></p>
<p>2） 求Top K</p>
<p>需一直维护一个大小为K的小顶堆，复杂度 nlog(K)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sift</span>(<span class="params">li, low, high</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    向下调整实现</span></span><br><span class="line"><span class="string">    小根堆</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param li: 列表</span></span><br><span class="line"><span class="string">    :param low: 堆的根节点位置</span></span><br><span class="line"><span class="string">    :param high: 堆的最后一个元素位置</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    i = low  <span class="comment"># i 指向根节点</span></span><br><span class="line">    j = <span class="number">2</span>*i+<span class="number">1</span>  <span class="comment"># j 开始是左孩子</span></span><br><span class="line">    tmp = li[low]  <span class="comment"># 把堆顶存起来</span></span><br><span class="line">    <span class="keyword">while</span> j&lt;=high: <span class="comment"># 只要j位置有数</span></span><br><span class="line">        <span class="keyword">if</span> j+<span class="number">1</span>&lt;=high <span class="keyword">and</span> li[j+<span class="number">1</span>] &lt; li[j]:  <span class="comment"># 右孩子有，且右孩子小</span></span><br><span class="line">            j = j+<span class="number">1</span>  <span class="comment"># j 换到右孩子分支</span></span><br><span class="line">        <span class="keyword">if</span> li[j]&lt;tmp:</span><br><span class="line">            li[i] = li[j]  <span class="comment"># 上去</span></span><br><span class="line">            i =j  <span class="comment"># 往下看一层</span></span><br><span class="line">            j = <span class="number">2</span>*i +<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            li[i]=tmp  <span class="comment"># 把 tmp 放到某一级领导的位置,此行代码可不写</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    li[i]= tmp  <span class="comment"># i到了叶子节点，需要将tmp 放过去</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">topk</span>(<span class="params">li, k</span>):</span></span><br><span class="line">    heap = li[:k]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>((k-<span class="number">2</span>)//<span class="number">2</span>, -<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">        sift(heap, i, k-<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 比较</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k, <span class="built_in">len</span>(li)):</span><br><span class="line">        <span class="keyword">if</span> li[i]&gt;heap[<span class="number">0</span>]:</span><br><span class="line">            heap[<span class="number">0</span>]= li[i]</span><br><span class="line">            sift(heap,<span class="number">0</span> ,k-<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># k个值堆排序，出数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">        heap[i], heap[<span class="number">0</span>] = heap[<span class="number">0</span>], heap[i]</span><br><span class="line">        sift(heap, <span class="number">0</span>, i-<span class="number">1</span>)  <span class="comment"># i-1 是新的high</span></span><br><span class="line">    <span class="keyword">return</span> heap</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">li = list(range(1000))</span><br><span class="line">random.shuffle(li)</span><br><span class="line">print(li)</span><br><span class="line">topk_li = topk(li,10)</span><br><span class="line">print(topk_li)</span><br><span class="line">[999, 998, 997, 996, 995, 994, 993, 992, 991, 990]</span><br></pre></td></tr></table></figure>



<ol start="3">
<li>有一个10亿搜索关键词的日志文件，如何获取Top10最热门的搜索关键词？</li>
</ol>
<p>方法1： MapReduce</p>
<p>方法2： 单机，可使用内存 1G</p>
<p>初始方案：</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gr34pbvpvwj31580fq0yh.jpg" alt="image-20210601222103242"></p>
<p>但是，字典占据空间太大，内存不够</p>
<p>改进：</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gr35ejvcjpj31je0lawr8.jpg" alt="image-20210601224517136"></p>
<h2 id="Trie-树"><a href="#Trie-树" class="headerlink" title="Trie 树"></a>Trie 树</h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gro179xlf0j30al06q74c.jpg" alt="img"></p>
<p>Trie <strong>树的本质，就是利用字符串之间的公共前缀，将重复的前缀合并在一起</strong>。</p>
<p>Trie 树只是不适合精确匹配查找，这种问题更适合用散列表或者红黑树来解决。Trie 树比较适 合的是查找前缀匹配的字符串，也就是类似开篇问题的那种场景。</p>
<p>关于 Trie 的应用场景，希望你能记住 8 个字：<strong>一次建树，多次查询</strong>。</p>
<ul>
<li>应用</li>
</ul>
<p>搜索引擎关键词提示，底层最基本的原理就是 Trie 树</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1grmtz93bvej31560t8wqs.jpg" alt="image-20210618232114437"></p>
<h2 id="字符串匹配"><a href="#字符串匹配" class="headerlink" title="字符串匹配"></a>字符串匹配</h2><h3 id="BF算法"><a href="#BF算法" class="headerlink" title="BF算法"></a>BF算法</h3><p>Brute Force, 也即暴力匹配算法，复杂度为O（mn），其中m为模式串长度，n 为主串长度，n&gt;m</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gpwd1fyt1sj30vk0eqwzb.jpg" alt="image-20210425222923858"></p>
<h3 id="RK-算法"><a href="#RK-算法" class="headerlink" title="RK 算法"></a>RK 算法</h3><p>RK 算法的全称叫 Rabin-Karp 算法，是由它的两位发明者 Rabin 和 Karp 的名字来命名的。</p>
<p>是BF算法的升级版</p>
<p>RK 算法的思路是这样的：我们通过哈希算法对主串中的 n-m+1 个子串分别求哈希值，然后逐个与模式串的哈希值比较大小。如果某个子串的哈希值与模式串相等，那就说明对应的子串和模式串匹配了(这 里先不考虑哈希冲突的问题，后面我们会讲到)。因为哈希值是一个数字，数字之间比较是否相等是非 常快速的，所以模式串和子串比较的效率就提高了。</p>
<p>整体复杂度：O(n)</p>
<h3 id="BM-算法"><a href="#BM-算法" class="headerlink" title="BM 算法"></a>BM 算法</h3><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><p>前面讲的数据结构都可以看成是图的特例。 前面提到了二叉树完全可以实现其他树结构，其实有向图也完全可以实现无向图和混合图，因此有向图的研究一直是重点考察对象。</p>
<ul>
<li>基本概念</li>
</ul>
<p>顶点：图中的元素</p>
<p>边：顶点与顶点之间建立的关系</p>
<p>度：每个用户有多少个好友， 对应到图中，就叫做顶点的<strong>度</strong>(degree)，就是跟顶点相连接的边的条数。</p>
<p>权重：边表示关系的重要程度</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gr35zdekfmj30mm0awdhq.jpg" alt="image-20210601230517752"></p>
<ul>
<li>存储</li>
</ul>
<p>1）邻接矩阵</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gr360ayorxj31340ms76f.jpg" alt="image-20210428232731364"></p>
<p>2）邻接表：</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqh6wzd1jdj315c0t0b29.jpg" alt="image-20210428232950016"></p>
<h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><blockquote>
<p>关于BFS和DFS，一个用到了队列，一个用到了递归</p>
<p>注意体会之</p>
</blockquote>
<p>广度优先搜索(Breadth-First-Search)</p>
<p>借助 ’队列‘ 实现</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqh718n6w9j316b0u0qv5.jpg" alt="image-20210513225914579"></p>
<h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><p>回溯思想</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gq0zutx00oj30t40fialq.jpg" alt="image-20210429224059475"></p>
<h2 id="四种算法思想"><a href="#四种算法思想" class="headerlink" title="四种算法思想"></a>四种算法思想</h2><p>贪心 算法、分治算法、回溯算法、动态规划，更加确切地说，它们应该是算法思想，并不是具体的算法，常用来指导我们设计具体的算法和编码等。</p>
<h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><p>应用领域：</p>
<ul>
<li><p>深度优先搜索</p>
</li>
<li><p>正则表达式匹配</p>
</li>
<li><p>编译原理中的语法分析</p>
</li>
<li><p>数独</p>
</li>
<li><p>0-1背包</p>
</li>
<li><p>图的着色</p>
</li>
<li><p>旅行商问题</p>
</li>
<li><p>全排列</p>
</li>
<li><p>N皇后问题</p>
</li>
</ul>
<p>参考：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/av374837176/">合格程序员必会，回溯法解八皇后，看了这个动画，你就全明白了，C++实现</a></p>
<p>笼统地讲，回溯算法很多时候都应用在“搜索”这类问题上。不过这里说的搜索，并不是􏰃义的指我们前 面讲过的图的搜索算法，而是在一组可能的解中，搜索满足期望的解。</p>
<p>回溯有点类似枚举，非常适合用递归实现。某次尝试出现错误后回到之前的时刻，重新尝试，类似于《蝴蝶效应》</p>
<h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><p>贪心算法有很多经典的应用，比如霍夫曼编码(Huffman Coding)、Prim 和 Kruskal 最小生成树算法、还有 Dijkstra 单源最短路径算法</p>
<ul>
<li>霍夫曼编码</li>
</ul>
<p>贪心思想：出现频率多的字符，用稍微短一些的字符编码；出现频率少的字符，用长一些的编码。霍夫曼编码要求各个字符的编码之间，不会出现某个编码是 另一个编码前缀的情况。</p>
<p>具体实现：</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqck0ezmfoj316s0u07wj.jpg" alt="image-20210509223800911"></p>
<p>所以，最终的编码为</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqck1wrsyqj30zk0jqx0x.jpg" alt="image-20210509224139300"></p>
<h3 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h3><p>分治算法核心思想：分而治之 ，也就是将原问题划分成 n 个 规模较小，并且结构与原问题相似的子问题，<strong>递归</strong>地解决这些子问题，然后再合并其结果，就得到原问 题的解。</p>
<p><strong>分治算法子问题之间没有相关性，这一点是跟动态规划的明显区别</strong></p>
<ul>
<li>MapReduce</li>
</ul>
<p>MapReduce 本质就是分治思想</p>
<p>一台机器过于低效，那我们就把任务拆分到多台机器上来处理。如果拆分之后的小任务之间互不干扰，独立计算，最后再将结果合并。这不就是分治思想吗?</p>
<p>尽管 MapReduce 的模型非常简单，但是在 Google 内部应用非常广泛。它除了可以用来处理这种数据 与数据之间存在关系的任务，比如 MapReduce 的经典例子，统计文件中单词出现的频率。除此之外， 它还可以用来处理数据与数据之间没有关系的任务，比如对网⻚分析、分词等，每个网⻚可以􏰂立的分 析、分词，而这两个网⻚之间并没有关系。网⻚几十亿、上百亿，如果单机处理，效率低下，我们就可 以利用 MapReduce 提供的高可靠、高性能、高容错的并行计算框架，并行地处理这几十亿、上百亿的 网⻚。</p>
<p>我们也时常感叹 Google 的创新能力如此之强，总是在引领技术的发展。实际上，创新并非离我们很 远，创新的源泉来自对事物本质的认识。无数优秀架构设计的思想来源都是基础的数据结构和算法，这 本身就是算法的一个魅力所在。</p>
<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><ul>
<li>一个模型三个特征</li>
</ul>
<p>首先，我们来看，什么是“<strong>一个模型</strong>”?它指的是动态规划适合解决的问题的模型。我把这个模型定义为 “<strong>多阶段决策最优解模型</strong>”。下面我具体来给你讲讲。</p>
<p>我们一般是用动态规划来解决最优问题。而解决问题的过程，需要经历多个决策阶段。每个决策阶段都 对应着一组状态。然后我们寻找一组决策序列，经过这组决策序列，能够产生最终期望求解的最优值。</p>
<p>什么是“<strong>三个特征</strong>”?它们分别是<strong>最优子结构</strong>、<strong>无后效性</strong>和<strong>重复子问题</strong>。</p>
<ul>
<li>两种方法：</li>
</ul>
<blockquote>
<p>状态转移表法</p>
</blockquote>
<p>问题：假设我们有一个 n 乘以 n 的矩阵 w[n][n]。矩阵存储的都是正整数。棋子起始位置在左上⻆，终止位置 在右下⻆。我们将棋子从左上⻆移动到右下⻆。每次只能向右或者向下移动一位。从左上⻆到右下⻆， 会有很多不同的路径可以走。我们把每条路径经过的数字加起来看作路径的⻓度。那从左上⻆移动到右 下⻆的<strong>最短路径⻓度</strong>是多少呢?</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqg1vbt5nwj312q0o04qq.jpg" alt="image-20210512231448768"></p>
<blockquote>
<p>状态转移方程法</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li>别人的课程索引：<a target="_blank" rel="noopener" href="http://173.249.58.195/">http://173.249.58.195/</a></li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpku2vnsy0j31k20jo1jo.jpg" alt="image-20210415231226060"></p>
<ol start="2">
<li><a target="_blank" rel="noopener" href="https://blog.fundebug.com/2018/08/27/code-interview-data-structure/">代码面试需要知道的8种数据结构(附面试题及答案链接)</a></li>
</ol>
</div></article></div><div class="right-container"><div class="widget"><div id="arAnchorBar"></div></div></div></section></div><div class="right-menu"></div><div class="modal search-modal"><div class="input-field"><input type="text" id="search_input"><label for="search-input">搜索</label></div><div id="search_result" class="search-result"></div></div><div class="blog-overlay"></div><footer class="row"><div class="footer-con"><div class="paginator"><a href="/2021/04/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%EF%BC%88%E9%AB%98%E7%BA%A7%E7%AF%87%EF%BC%89/" title="⭐️数据结构与算法之美（高级篇 &amp; 实战篇）" class="prev">PREV</a><a href="/2021/03/25/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" title="⭐️并发编程【未看完】" class="next">NEXT</a></div><div class="copyright"><p>© 2016 - 2021 <a target="_blank">John Doe</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <br> and <a href="https://github.com/Bulandent/hexo-theme-bubuzou" target="_blank">hexo-theme-bubuzou</a></p><p> <span style="padding-right: 6px;">闽ICP备16007301号-2</span></p></div><div class="totop"><i></i></div></div></footer><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/jquery-1.8.2.min.js"></script><script src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/articleCatalog.js"></script><script src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/main.js"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>