<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="baidu-site-verification" content="1EB8XoOl0C"><meta name="google-site-verification" content="K7thEgdLm0UfRWJ5MGdF7sCcjClSzAlxFLPv2Oz5CGM"><title> ⭐️数据结构与算法 · Hexo</title><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="description" content="⭐️数据结构与算法 - John Doe"><meta name="keywords"><meta name="author" content="John Doe"><link rel="short icon" href="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/favicon.ico"><link rel="stylesheet" href="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/bubuzou.css"><link rel="search" type="application/opensearchdescription+xml" href="http://example.com/atom.xml" title="Hexo"><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='//unpkg.com/valine/dist/Valine.min.js'></script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head><body><header><div class="header row"> <a href="/" class="logo-link"><img src="/images/logo.png"></a><ul id="nav_list" class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" data-hover="博文" class="nav-list-link">博文</a></li><li class="nav-list-item"><a href="/archives/" target="_self" data-hover="归档" class="nav-list-link">归档</a></li><li class="nav-list-item"><a href="/about/" target="_self" data-hover="关于" class="nav-list-link">关于</a></li></ul><div class="search"><a id="search_btn" href="#search"></a></div><div id="nav_btn" class="nav-btn"><span></span><span></span><span></span></div></div></header><div class="row scroll-con"><section class="container"><!-- for archive page--><div id="postAr" class="post"><article class="post-block"><h1 class="post-title">⭐️数据结构与算法</h1><div class="post-info">2021-04-02</div><div class="post-content"><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp84xlwx77j30u01tau05.jpg" alt="img"></p>
<span id="more"></span>



<h2 id="数据结构、算法概念"><a href="#数据结构、算法概念" class="headerlink" title="数据结构、算法概念"></a>数据结构、算法概念</h2><p>什么是数据结构、算法？</p>
<p>当我们遇到一个实际问题时，首先需要解决两件事：</p>
<p>（1）如何将数据存储在计算机中；</p>
<p>（2）用什么方法和策略解决问题。</p>
<p>前者是数据结构，后者是算法。</p>
<p>数据是一切能输入计算机中的信息的总和，结构是指数据之间的关系。数据结构就是将数据及其之间的关系有效地存储在计算机中并进行基本操作。算法是对特定问题求解步骤的一种描述，通俗讲就是解决问题的方法和策略。</p>
<p><strong>数据结构分类</strong></p>
<ul>
<li>逻辑结构</li>
</ul>
<p>依据数据元素之间的关系划分</p>
<img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2pfy5atvjj21700r8gou.jpg" alt="image-20220529181610809" style="zoom:50%;" />

<ul>
<li>物理结构</li>
</ul>
<p>数据的逻辑结构在计算机中的存储形式</p>
<p>包括顺序存储结构、链式存储结构</p>
<p>各种逻辑结构，均是在这两种基础上的组合，以实现最佳的效果</p>
<p><strong>二者关系</strong></p>
<p>数据结构和算法是相辅相成的。数据结构是为算法服务的，算法要作用在特定的数据结构之上。 因此，我们无法孤立数据结构来讲算法，也无法孤立算法来讲数据结构。</p>
<p>比如，因为数组因为具有随机访问的特点，二分查找就需要用数组来存储数据。如果选择链表，则二分查找算法就无法工作了</p>
<p>只有数据结构没有算法，相当于只把数据存储到计算机中，而没有有效的方法去处理，就像一幢只有框架的烂尾楼；若只有算法，没有数据结构，就像沙漠里的海市蜃楼，只不过是空中楼阁罢了。</p>
<p>在遇到一个实际问题时，要充分利用自己所学的数据结构，将数据及其之间的关系有效地存储在计算机中，然后选择合适的算法策略，并用程序高效地实现。这就是Niklaus Wirth教授所说的：“数据结构+算法＝程序”。</p>
<p><strong>学习原则</strong></p>
<p>要学习它的“来历”“自身的特点”“适合解决的问题”以及“实际的应用场景”</p>
<p>很多时候我们并不是要去死记硬背某个数据结构或者算法，而是要学习它背后的思想和处理技巧，这些东西才是最有价值的。</p>
<p>学习数据结构最难的不是理解和掌握原理，而是能灵活地将各种场景和问题抽象成对应的数据结构和算法</p>
<p>学习数据结构和算法，并不是为了死记硬背几个知识点。我们的目的是建立时间复杂度、空间复杂 度意识，写出高质量的代码，能够设计基础架构，提升编程技能，训练逻辑思维，积攒人生经验，以此 获得工作回报，实现你的价值，完善你的人生。</p>
<p>掌握了数据结构与算法，你看待问题的深度，解决问题的⻆度就会完全不一样。因为这样的你，就像是 站在巨人的肩膀上，拿着生存利器行走世界。数据结构与算法，会为你的编程之路，甚至人生之路打开 一扇通往新世界的大⻔。</p>
<p>学习一个算法可分为三步：</p>
<p>​    1)先了解算法本身解决什么问题</p>
<p>​    2)然后学习它的解决策略</p>
<p>​    3)最后了解相似算法之间的联系</p>
<p>参考：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/31082722">用链表的目的是什么？省空间还是省时间？</a>高赞回答：</p>
<blockquote>
<p>所以你说“用链表的目的是什么”？</p>
<p>没目的。</p>
<p>或者说，目的是让你学会因地制宜的、灵活的组织数据——而且随便你搞出多么奇怪的数据结构、多么复杂的数据组织形式，你都能清晰的给出它（对某个特定任务）的时间/空间复杂度。</p>
<p>当你能掌握到这个程度时，你完全可以把完全二叉树、满二叉树、红黑树、B树、B+树的定义统统忘掉；但只要有需要，你随时随地都能把你面对的数据整进一个结合了二叉树和队列优点的、不知道该叫什么的数据结构里——从而以最高效率完成你面对的任务。</p>
<p>换句话说，不要浮在表面、只看到链表二叉树之类东西；而是要深入进去，把它们统统拆散了、揉碎了、忘记了——你要做它们的发明者，不要做它们的使用者。</p>
<p>你要学的，是最高效率把玩海量数据的思路；你不仅要能因地制宜的给出解决方案、还要有能力给出综合最优的方案（并作出证明）——停留在链表这个表面上，那是连门在哪都没摸到，谈何入门。</p>
</blockquote>
<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>要理解O() 复杂度 的含义，O()并不表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以大O时间复杂度，也叫渐进时间复杂度，简称时间复杂度。</p>
<p>更详细的参考：<a target="_blank" rel="noopener" href="http://bigocheatsheet.com/">Know Thy Complexities!</a>：</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqk4qum5uyj31hu0t2npd.jpg" alt="image-20210516115644557"></p>
<p><strong>时间复杂度量级</strong></p>
<p>分为：</p>
<ul>
<li><p>多项式量级 </p>
</li>
<li><p>非多项式量级（NP, non-deterministic polynomial）</p>
</li>
</ul>
<img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp979osnjzj313o0ibwqu.jpg" alt="IMG_E5863834E01F-1" style="zoom:50%;" />

<p><strong>空间复杂度</strong></p>
<p>我们说空间复杂度的时候<u>，是指除了原本的数据存储空间外</u>，算法运行还需要<strong>额外的</strong>存储空间。</p>
<p><strong>最好、最坏和平均情况时间复杂度</strong></p>
<p>e.g. 在数组中查找变量 x 的位置</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// n表示数组array的长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span>[] <span class="built_in">array</span>, <span class="keyword">int</span> n, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> pos = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">array</span>[i] == x) &#123;</span><br><span class="line">       pos = i;</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于最好情况，x 刚好在数组的第一个位置，则复杂度为O(1)；</p>
<p>最差情况，不在数组中，则复杂度为O(n)；</p>
<p>当然，这两种情况都比较极端，发生概率不大。考虑**<u>平均时间复杂度</u><strong>，引入</strong>概率分析**。（这里算的是期望）</p>
<blockquote>
<p>我们知道，要查找的变量 x，要么在数组里，要么就不在数组里。这两种情况对应的概率统计起来很麻烦，为了方便你理解，我们假设在数组中与不在数组中的概率都为 1/2。另外，要查找的数据出现在 0～n-1 这 n 个位置的概率也是一样的，为 1/n。所以，根据概率乘法法则，要查找的数据出现在 0～n-1 中任意位置的概率就是 1/(2n)。</p>
<p>因此，前面的推导过程中存在的最大问题就是，没有将各种情况发生的概率考虑进去。如果我们把每种情况发生的概率也考虑进去，那平均时间复杂度的计算过程就变成了这样：</p>
<img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp982ch8m0j313s0ccnap.jpg" alt="image-20210405220945927" style="zoom:33%;" />
</blockquote>
<p>则最后的平均时间复杂度仍为O(n)</p>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>链表，不需要一块连续的内存空间，通过“指针”将零散的内存块串联起来使用</p>
<p><strong>单链表</strong></p>
<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqkhexjdpdj31fs0awe24.jpg" alt="image-20210516191501331" style="zoom:33%;" />

<p>代码实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 参考：https://jackkuo666.github.io/Data_Structure_with_Python_book/chapter3/section1.html</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        self.data = data</span><br><span class="line">        self.<span class="built_in">next</span>=<span class="literal">None</span></span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleLinkList</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.head = <span class="literal">None</span>   <span class="comment"># 初始化，创建头指针</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;头部插入元素&#x27;&#x27;&#x27;</span></span><br><span class="line">        node = Node(item)</span><br><span class="line">        node.<span class="built_in">next</span> = self.head</span><br><span class="line">        self.head = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;尾部插入&quot;&quot;&quot;</span></span><br><span class="line">        node = Node(item)</span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            self.head = node</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur = self.head</span><br><span class="line">            <span class="keyword">while</span> cur.<span class="built_in">next</span>:  <span class="comment"># 非None</span></span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;判断链表是否为空&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.head <span class="keyword">is</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">travel</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;遍历链表&#x27;&#x27;&#x27;</span></span><br><span class="line">        p = self.head</span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            <span class="built_in">print</span>(p.data)</span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        node = self.head</span><br><span class="line">        nodes = []</span><br><span class="line">        <span class="keyword">while</span> node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            nodes.append(node.data)</span><br><span class="line">            node = node.<span class="built_in">next</span></span><br><span class="line">        nodes.append(<span class="string">&quot;None&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot; -&gt; &quot;</span>.join(nodes)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">llist = SingleLinkList()</span><br><span class="line"><span class="built_in">print</span>(llist)</span><br><span class="line">llist.add(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(llist)</span><br><span class="line">llist.add(<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">llist.add(<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(llist)</span><br><span class="line"></span><br><span class="line">llist = SingleLinkList()</span><br><span class="line"><span class="built_in">print</span>(llist)</span><br><span class="line">llist.append(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(llist)</span><br><span class="line">llist.append(<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">llist.append(<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(llist)</span><br><span class="line"></span><br><span class="line"><span class="literal">None</span></span><br><span class="line">a -&gt; <span class="literal">None</span></span><br><span class="line">c -&gt; b -&gt; a -&gt; <span class="literal">None</span></span><br><span class="line"><span class="literal">None</span></span><br><span class="line">a -&gt; <span class="literal">None</span></span><br><span class="line">a -&gt; b -&gt; c -&gt; <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<p>注意头插和尾插的输出顺序</p>
<p><strong>循环链表</strong></p>
<p>跟单链表相比，区别是尾结点指针指向链表的头结点</p>
<img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2ph5rs5arj21da0bywfn.jpg" alt="image-20220529185802379" style="zoom:33%;" />

<p>循环链表的优点是从链尾到链头比较方便。</p>
<p>当要处理的数据具有环型结构特点时，就特别适合采用循环链表。比如著名的约瑟夫问题。</p>
<p><strong>双向链表</strong></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq490691606/article/details/49948263">Python 实现双向链表（图解）</a></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqls41wojpj31cu06snbl.jpg" alt="image-20210517221044722"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqltomwamrj313a07ygyn.jpg" alt="image-20210517230508499"></p>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>队列跟栈一样，也是一种操作受限的线性表数据结构。</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gv15cis0thj61cy084t9m02.jpg" alt="image-20211002183322757" style="zoom:33%;" />

<p><strong>数组实现</strong></p>
<p>通过 移动head ,tail 控制入队和出队，当tail 移动到数组最右边，需要数据搬移</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gv1687k03lj610m0c8mys02.jpg" alt="image-20211002190353757" style="zoom:50%;" />

<p>如要避免数据搬移，可采用循环队列：</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gv16dbb5ivj619a0k20va02.jpg" alt="IMG_CA2CC59959D7-1"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, size=<span class="number">100</span></span>):</span></span><br><span class="line">        self.size = size</span><br><span class="line">        self.queue = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size)]</span><br><span class="line">        self.front = <span class="number">0</span>  <span class="comment"># 队首</span></span><br><span class="line">        self.rear = <span class="number">0</span> <span class="comment"># 队尾</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, element</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.is_filled():</span><br><span class="line">            self.rear =(self.rear+<span class="number">1</span>) % self.size</span><br><span class="line">            self.queue[self.rear] = element</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> IndexError(<span class="string">&#x27;queue is filled&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.is_empty():</span><br><span class="line">            self.front = (self.front+<span class="number">1</span>) % self.size</span><br><span class="line">            <span class="keyword">return</span> self.queue[self.front]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> IndexError(<span class="string">&#x27;queue is empty!!&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;判断队空&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.rear==self.front</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_filled</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;判断队满&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> (self.rear+<span class="number">1</span>) % self.size == self.front</span><br><span class="line">---------------------------------------------</span><br><span class="line"></span><br><span class="line">q = Queue(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    q.push(i)</span><br><span class="line"><span class="built_in">print</span>(q.is_filled())</span><br><span class="line"><span class="built_in">print</span>(q.pop())</span><br><span class="line">q.push(<span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<p><strong>链表实现</strong></p>
<img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpblrprhh3j312k0i847d.jpg" alt="IMG_A95FD02F8B3D-1" style="zoom:50%;" />



<p><strong>阻塞队列</strong></p>
<p>阻塞 队列其实是在队列的基础上增加了阻塞操作。就是在队列为空的时候，从队头取数据会 被阻塞。因为此时还没有数据可取，直到队列中有了数据才能返回;如果队列已经满了，那么插入数据 的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回。</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2pn9uyqcgj21fo0e8mys.jpg" alt="image-20220529222937315"></p>
<p>利用阻塞队列可以轻松实现一个<strong>”生产者-消费者模型“</strong></p>
<p>基于阻塞队列，我们还可以通过协调“生产者”和“消费者”的个数，来提高数据的处理效率</p>
<img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpcpbogzv3j31dy0g4x4n.jpg" alt="image-20210408222332733" style="zoom:50%;" />

<p><strong>并发队列</strong></p>
<p>在多线程情况下，会有多个线程同时操作队列，这个时候就会存在线程安全问题，那如何实现一个线程安全的队列呢?</p>
<p>线程安全的队列我们叫作并发队列。最简单直接的实现方式是直接在 enqueue()、dequeue() 方法上加 锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或者取操作。实际上，基于数组的循环队 列，利用 CAS 原子操作，可以实现非常高效的并发队列。这也是循环队列比链式队列应用更加广泛的原 因。</p>
<p>总之，阻塞队列就是入队、出队操作可以阻塞，并发队列就是队列的操作多线程安全</p>
<p>？？？？</p>
<p><strong>内置模块</strong></p>
<p>双端队列</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gv17ma4kggj60yw0d8wgi02.jpg" alt="image-20210304235311165" style="zoom:50%;" />

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="comment"># 创建队列</span></span><br><span class="line">d = collections.deque()</span><br><span class="line"></span><br><span class="line">d.append(<span class="number">1</span>) <span class="comment">#从队尾入队</span></span><br><span class="line">d.popleft() <span class="comment">#从队头出队</span></span><br><span class="line"></span><br><span class="line">d.appendleft(<span class="number">2</span>) <span class="comment">#从队头入队</span></span><br><span class="line">d.pop() <span class="comment">#从队尾出队</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用 <code>deque(maxlen=N)</code> 构造函数会新建一个固定大小的队列。当新的元素加入并且这个队列已满的时候， 最前面的元素会自动pop()。</p>
<p>可以实现linux tail命令，打印文件的最后几行：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tail</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        q = deque(f, n)</span><br><span class="line">        <span class="keyword">return</span> q</span><br><span class="line"><span class="built_in">print</span>(tail(<span class="number">5</span>))</span><br></pre></td></tr></table></figure>



<h2 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h2><p>应用场景：Redis用跳表实现有序集合</p>
<p>跳表是一种各方面性能都比较优秀的<strong>动态数据结构</strong>，可以支持快速地插入、删除、查找操作，写起来也不复杂，甚至可以替代红黑树(Red-black tree)。</p>
<blockquote>
<p>链表+多级索引 = 跳表：</p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpksnctla0j31dy0oge81.jpg" alt="image-20210415222252327"></p>
<ul>
<li>查询时间复杂度</li>
</ul>
<p>假设索引 h 级，最高索引有2个结点。那么整个跳表高度为：log(n)</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpkstbauktj31eq0n8hdt.jpg" alt="image-20210415222838932"></p>
<p>单层索引最多需要遍历3个结点，所以整体的复杂度为O(log(n))</p>
<p>此外，插入、删除的复杂度也为O(log(n))</p>
<ul>
<li>空间复杂度</li>
</ul>
<p>将所有索引的节点数相加得到：</p>
<p> n/2+n/4+n/8…+8+4+2=n-2。所以，跳表的空间复杂度是 O(n)。</p>
<ul>
<li>索引的动态更新</li>
</ul>
<p>如果不停地往跳表中插入数据，而不更新索引，极端情况下会退化成单链表，如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpkt0roo8tj310o0ggdzt.jpg" alt="image-20210415223548875"></p>
<p>作为一种动态数据结构，我们需要某种手段来维护索引与原始链表大小之间的平衡，也就是说，如果链 表中结点多了，索引结点就相应地增加一些，避免复杂度退化，以及查找、插入、删除操作性能下降。</p>
<p>而跳表是<strong>通过随机函数来维护前面提到的“平衡性”</strong>：</p>
<p>我们通过一个随机函数，来决定将这个结点插入到哪几级索引中，比如随机函数生成了值 K，那我们就 将这个结点添加到第一级到第 K 级这 K 级索引中。</p>
<img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpkt26cslsj319p0u0npd.jpg" alt="image-20210415223709920" style="zoom:50%;" />

<h2 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h2><p>散列表英文名叫’Hash Table‘，又称’哈希表‘</p>
<p>散列表  = 散列函数 + 数组</p>
<p>散列表用的是数组支持下标随机访问数据的特性，所以散列表其实是数组的一种扩展，由数组演化而来。</p>
<img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpkusfq4luj315y0pkb29.jpg" alt="image-20210415233700091" style="zoom:33%;" />

<p>注意，哈希函数哈希的是key ,因此，在dict中查找某个key是否存在操作的时间复杂度为o（1）；查找某个value是否存在操作的时间复杂度为o（n）</p>
<ul>
<li>散列冲突</li>
</ul>
<p>1）开放寻址法</p>
<p>开放寻址法的核心思想是，如果出现了散列冲突，我们就􏰂向后探测空位置，然后将其插入</p>
<p>2）链表法</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gv2bp3vaxqj61220i276802.jpg" alt="image-20211003185845645"></p>
<p>参考实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkList</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;链表类&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;节点&quot;&quot;&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, item</span>):</span></span><br><span class="line">            self.item = item</span><br><span class="line">            self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">LinkListIterator</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;迭代器类&quot;&quot;&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, node</span>):</span></span><br><span class="line">            self.node=node</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__next__</span>(<span class="params">self</span>):</span></span><br><span class="line">            <span class="keyword">if</span> self.node:</span><br><span class="line">                cur_node = self.node</span><br><span class="line">                self.node = cur_node.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">return</span> cur_node.item</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">raise</span> StopIteration</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">            <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, iterable=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.head = <span class="literal">None</span></span><br><span class="line">        self.tail = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> iterable:</span><br><span class="line">            self.extend(iterable)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span>(<span class="params">self, obj</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;尾插&quot;&quot;&quot;</span></span><br><span class="line">        s= LinkList.Node(obj)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.head:</span><br><span class="line">            self.head = s</span><br><span class="line">            self.tail = s</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.tail.<span class="built_in">next</span> = s</span><br><span class="line">            self.tail = s</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">extend</span>(<span class="params">self, iterable</span>):</span></span><br><span class="line">        <span class="keyword">for</span> obj <span class="keyword">in</span> iterable:</span><br><span class="line">            self.append(obj)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span>(<span class="params">self, obj</span>):</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> self:</span><br><span class="line">            <span class="keyword">if</span> n==obj:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;使链表类支持迭代&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.LinkListIterator(self.head)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        map(str, self)  --&gt; 转化成str</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&lt;&lt;&quot;</span> + <span class="string">&quot;, &quot;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, self)) + <span class="string">&quot;&gt;&gt;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lk = LinkList([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line"><span class="keyword">for</span> ele <span class="keyword">in</span> lk:</span><br><span class="line">    <span class="built_in">print</span>(ele)</span><br><span class="line"><span class="built_in">print</span>(lk)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HashTable</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    类似于集合的结构</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, size=<span class="number">101</span></span>):</span></span><br><span class="line">        self.size = size</span><br><span class="line">        self.T = [LinkList() <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(self.size)]   <span class="comment"># 每个数组里面为链表</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hash</span>(<span class="params">self, k</span>):</span></span><br><span class="line">        <span class="keyword">return</span> k % self.size</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self, k</span>):</span></span><br><span class="line">        hash_value = self.<span class="built_in">hash</span>(k)</span><br><span class="line">        <span class="comment"># 要判断重复,先查找</span></span><br><span class="line">        <span class="keyword">if</span> self.find(k):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;重复插入&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.T[hash_value].append(k)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span>(<span class="params">self, k</span>):</span></span><br><span class="line">        i = self.<span class="built_in">hash</span>(k)</span><br><span class="line">        <span class="keyword">return</span> self.T[i].find(k)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ht =HashTable()</span><br><span class="line">ht.insert(<span class="number">0</span>)</span><br><span class="line">ht.insert(<span class="number">1</span>)</span><br><span class="line">ht.insert(<span class="number">3</span>)</span><br><span class="line">ht.insert(<span class="number">102</span>)</span><br><span class="line">ht.insert(<span class="number">0</span>)</span><br><span class="line">ht.insert(<span class="number">508</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;,&#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, ht.T)))</span><br><span class="line"><span class="built_in">print</span>(ht.find(<span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(ht.find(<span class="number">4</span>))</span><br><span class="line">---------------</span><br><span class="line">重复插入</span><br><span class="line">&lt;&lt;<span class="number">0</span>&gt;&gt;,&lt;&lt;<span class="number">1</span>, <span class="number">102</span>&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;<span class="number">3</span>, <span class="number">508</span>&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>课后题</p>
</blockquote>
<ol>
<li>假设我们有 10 万条 URL 访问日志，如何按照访问次数给 URL 排序？</li>
</ol>
<p>遍历 10 万条数据，以 URL 为 key，访问次数为 value，存入散列表，同时记录下访问次数的最大值 K，时间复杂度 O(N)。</p>
<p>如果 K 不是很大，可以使用桶排序，时间复杂度 O(N)。如果 K 非常大（比如大于 10 万），就使用快速排序，复杂度 O(NlogN)。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="string">&#x27;sdfg&#x27;</span>:<span class="number">1</span>, <span class="string">&#x27;zzjk&#x27;</span>:<span class="number">9</span>, <span class="string">&#x27;ooo&#x27;</span>:<span class="number">4</span>, <span class="string">&#x27;ww.s&#x27;</span>:<span class="number">3</span>&#125;</span><br><span class="line"><span class="built_in">sorted</span>(a.items(), key = <span class="keyword">lambda</span> item:item[<span class="number">1</span>])</span><br><span class="line">-----------------------------------</span><br><span class="line">[(<span class="string">&#x27;sdfg&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;ww.s&#x27;</span>, <span class="number">3</span>), (<span class="string">&#x27;ooo&#x27;</span>, <span class="number">4</span>), (<span class="string">&#x27;zzjk&#x27;</span>, <span class="number">9</span>)]</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>有两个字符串数组，每个数组大约有 10 万条字符串，如何快速找出两个数组中相同的字符串？</li>
</ol>
<p>以第一个字符串数组构建散列表，key 为字符串，value 为出现次数。再遍历第二个字符串数组，以字符串为 key 在散列表中查找，如果 value 大于零，说明存在相同字符串。时间复杂度 O(N)。</p>
<ul>
<li>如何设计工业级的散列表</li>
</ul>
<p><strong>主要考虑：如何设计散列函数，如何根据装载因子动态扩容，以及如何选择散列冲突解决方法：</strong></p>
<p>关于散列函数的设计，我们要尽可能让散列后的值随机且均匀分布，这样会尽可能地减少散列冲突，即便冲突之后，分配到每个槽内的数据也比较均匀。除此之外，散列函数的设计也不能太复杂，太复杂就 会太耗时间，也会影响散列表的性能。</p>
<p>关于散列冲突解决方法的选择，我对比了开放寻址法和链表法两种方法的优劣和适应的场景。大部分情 况下，链表法更加普适。而且，我们还可以通过将链表法中的链表改造成其他动态查找数据结构，比如 红黑树，来避免散列表时间复杂度退化成 O(n)，抵御散列碰撞攻击。但是，对于小规模数据、装载因子 不高的散列表，比较适合用开放寻址法。</p>
<p>对于动态散列表来说，不管我们如何设计散列函数，选择什么样的散列冲突解决方法。随着数据的不断 增加，散列表总会出现装载因子过高的情况。这个时候，我们就需要启动动态扩容。</p>
<ul>
<li>散列表和链表的组合使用</li>
</ul>
<blockquote>
<p>案例：LRU缓存淘汰算法</p>
</blockquote>
<p>单链表实现的复杂度为O(n)</p>
<p>借助散列表，实现复杂度O(1):</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gprrdtw0puj318c0rinpd.jpg" alt="image-20210421225756369"></p>
<ul>
<li>哈希算法</li>
</ul>
<p>哈希算法的定义和原理非常简单，基本上一句话就可以概括了。将任意⻓度的二进制值串映射为固定⻓ 度的二进制值串，这个映射的规则就是<strong>哈希算法</strong>，而通过原始数据映射之后得到的二进制值串就是<strong>哈希值</strong>。</p>
<p>但是，要想设计一个优秀的哈希算法并不容易，需要满足的几点要求:</p>
<p>1）从哈希值不能反向推导出原始数据(所以哈希算法也叫单向哈希算法);</p>
<p>2)对输入数据非常敏感，哪怕原始数据只修改了一个 Bit，最后得到的哈希值也大不相同; </p>
<p>3)散列冲突的概率要很小，对于不同的原始数据，哈希值相同的概率非常小; </p>
<p>4)哈希算法的执行效率要尽􏰃高效，针对较⻓的文本，也能快速地计算出哈希值。</p>
<p><strong>根据’鸽巢原理‘，哈希算法无法做到零冲突。</strong></p>
<blockquote>
<p>我们知道，哈希算法产生的哈希值的⻓度是固定且有限的。比如前面举的 MD5 的例子，哈希值是固定 的 128 位二进制串，能表示的数据是有限的，最多能表示 2^128 个数据，而我们要哈希的数据是无穷的。基于鸽巢原理，如果我们对 2^128+1 个数据求哈希值，就必然会存在哈希值相同的情况</p>
</blockquote>
<p>一些应用：</p>
<p>1）<strong>安全加密</strong></p>
<p><strong>MD5</strong>(MD5 Message-Digest Algorithm，MD5 消息摘要算法)；</p>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/SHA-1#cite_note-56"><strong>SHA</strong>(Secure Hash Algorithm，安全散列算法)</a></p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Pseudocode">Pseudocode</a> for the SHA-1 algorithm follows:</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">Note <span class="number">1</span>: All variables are <span class="keyword">unsigned</span> <span class="number">32</span>-bit quantities <span class="keyword">and</span> wrap modulo <span class="number">232</span> when calculating, except <span class="keyword">for</span></span><br><span class="line">        ml, the message length, which is a <span class="number">64</span>-bit quantity, <span class="keyword">and</span></span><br><span class="line">        hh, the message digest, which is a <span class="number">160</span>-bit quantity.</span><br><span class="line">Note <span class="number">2</span>: All constants in <span class="keyword">this</span> pseudo code are in big endian.</span><br><span class="line">        Within each word, the most significant byte is stored in the leftmost byte position</span><br><span class="line"></span><br><span class="line">Initialize variables:</span><br><span class="line"></span><br><span class="line">h0 = <span class="number">0x67452301</span></span><br><span class="line">h1 = <span class="number">0xEFCDAB89</span></span><br><span class="line">h2 = <span class="number">0x98BADCFE</span></span><br><span class="line">h3 = <span class="number">0x10325476</span></span><br><span class="line">h4 = <span class="number">0xC3D2E1F0</span></span><br><span class="line"></span><br><span class="line">ml = message length in bits (always a multiple of the number of bits in a character).</span><br><span class="line"></span><br><span class="line">Pre-processing:</span><br><span class="line">append the bit <span class="string">&#x27;1&#x27;</span> to the message e.g. by adding <span class="number">0x80</span> <span class="keyword">if</span> message length is a multiple of <span class="number">8</span> bits.</span><br><span class="line">append <span class="number">0</span> ≤ k &lt; <span class="number">512</span> bits <span class="string">&#x27;0&#x27;</span>, such that the resulting message length in bits</span><br><span class="line">   is congruent to −<span class="number">64</span> ≡ <span class="number">448</span> (mod <span class="number">512</span>)</span><br><span class="line">append ml, the original message length in bits, as a <span class="number">64</span>-bit big-endian integer. </span><br><span class="line">   Thus, the total length is a multiple of <span class="number">512</span> bits.</span><br><span class="line"></span><br><span class="line">Process the message in successive <span class="number">512</span>-bit chunks:</span><br><span class="line"><span class="keyword">break</span> message into <span class="number">512</span>-bit chunks</span><br><span class="line"><span class="keyword">for</span> each chunk</span><br><span class="line">    <span class="keyword">break</span> chunk into sixteen <span class="number">32</span>-bit big-endian words w[i], <span class="number">0</span> ≤ i ≤ <span class="number">15</span></span><br><span class="line"></span><br><span class="line">    Message schedule: extend the sixteen <span class="number">32</span>-bit words into eighty <span class="number">32</span>-bit words:</span><br><span class="line">    <span class="keyword">for</span> i from <span class="number">16</span> to <span class="number">79</span></span><br><span class="line">        Note <span class="number">3</span>: SHA<span class="number">-0</span> differs by <span class="keyword">not</span> having <span class="keyword">this</span> leftrotate.</span><br><span class="line">        w[i] = (w[i<span class="number">-3</span>] <span class="keyword">xor</span> w[i<span class="number">-8</span>] <span class="keyword">xor</span> w[i<span class="number">-14</span>] <span class="keyword">xor</span> w[i<span class="number">-16</span>]) leftrotate <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    Initialize hash value <span class="keyword">for</span> <span class="keyword">this</span> chunk:</span><br><span class="line">    a = h0</span><br><span class="line">    b = h1</span><br><span class="line">    c = h2</span><br><span class="line">    d = h3</span><br><span class="line">    e = h4</span><br><span class="line"></span><br><span class="line">    Main loop:[<span class="number">10</span>][<span class="number">56</span>]</span><br><span class="line">    <span class="keyword">for</span> i from <span class="number">0</span> to <span class="number">79</span></span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span> ≤ i ≤ <span class="number">19</span> then</span><br><span class="line">            f = (b <span class="keyword">and</span> c) <span class="keyword">or</span> ((<span class="keyword">not</span> b) <span class="keyword">and</span> d)</span><br><span class="line">            k = <span class="number">0x5A827999</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> <span class="number">20</span> ≤ i ≤ <span class="number">39</span></span><br><span class="line">            f = b <span class="keyword">xor</span> c <span class="keyword">xor</span> d</span><br><span class="line">            k = <span class="number">0x6ED9EBA1</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> <span class="number">40</span> ≤ i ≤ <span class="number">59</span></span><br><span class="line">            f = (b <span class="keyword">and</span> c) <span class="keyword">or</span> (b <span class="keyword">and</span> d) <span class="keyword">or</span> (c <span class="keyword">and</span> d) </span><br><span class="line">            k = <span class="number">0x8F1BBCDC</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> <span class="number">60</span> ≤ i ≤ <span class="number">79</span></span><br><span class="line">            f = b <span class="keyword">xor</span> c <span class="keyword">xor</span> d</span><br><span class="line">            k = <span class="number">0xCA62C1D6</span></span><br><span class="line"></span><br><span class="line">        temp = (a leftrotate <span class="number">5</span>) + f + e + k + w[i]</span><br><span class="line">        e = d</span><br><span class="line">        d = c</span><br><span class="line">        c = b leftrotate <span class="number">30</span></span><br><span class="line">        b = a</span><br><span class="line">        a = temp</span><br><span class="line"></span><br><span class="line">    Add <span class="keyword">this</span> chunk<span class="number">&#x27;</span>s hash to result so far:</span><br><span class="line">    h0 = h0 + a</span><br><span class="line">    h1 = h1 + b </span><br><span class="line">    h2 = h2 + c</span><br><span class="line">    h3 = h3 + d</span><br><span class="line">    h4 = h4 + e</span><br><span class="line"></span><br><span class="line">Produce the <span class="keyword">final</span> hash value (big-endian) as a <span class="number">160</span>-bit number:</span><br><span class="line">hh = (h0 leftshift <span class="number">128</span>) <span class="keyword">or</span> (h1 leftshift <span class="number">96</span>) <span class="keyword">or</span> (h2 leftshift <span class="number">64</span>) <span class="keyword">or</span> (h3 leftshift <span class="number">32</span>) <span class="keyword">or</span> h4</span><br></pre></td></tr></table></figure>



<p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2fwosbgezj21lj0u0107.jpg" alt="image-20220521121942054"></p>
<p>除了这两个之外，当然还有很多其他加密算法，比如 DES(Data Encryption Standard，数据加密标准)、AES(Advanced Encryption Standard，高级加密标准)。</p>
<p>2）<strong>分布式系统中应用</strong></p>
<p>负载均衡、数据分片（Mapreduce设计思想）、分布式存储等</p>
<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p>树其实是一种特殊的<code>图</code>，是一种无环连通图，是一种极大无环图，也是一种极小连通图。</p>
<p>从另一个角度看，树是一种递归的数据结构</p>
<p><strong>基本概念</strong></p>
<p>包括树的构建、遍历、删除等</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gprsbh1igpj30ye0hc1ee.jpg" alt="image-20210421233018284" style="zoom:50%;" />



<blockquote>
<p>如果树有 n 个顶点，那么其就有 n - 1 条边，这说明了树的顶点数和边数是同阶的。</p>
<p>任何一个节点到根节点存在<code>唯一</code>路径，路径的长度为节点所处的深度</p>
</blockquote>
<p>实际使用的树有可能会更复杂，比如使用在游戏中的碰撞检测可能会用到四叉树或者八叉树。以及 k 维的树结构 <code>k-d 树</code>等。</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gro06z8x5bj306y06mdft.jpg" alt="img"></p>
<p>二叉树是节点度数不超过二的树，是树的一种特殊子集，有趣的是二叉树这种被限制的树结构却能够表示和实现所有的树</p>
<p><strong>二叉树构建</strong></p>
<p>1）链式存储</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gprsjj29roj312w0qwe67.jpg" alt="image-20210421233803644" style="zoom:33%;" />

<p>2）基于数组的顺序存储</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gprsnic8hyj312a0liat9.jpg" alt="image-20210421234153502" style="zoom:43%;" />

<p>如果某棵二叉树是一棵完全二叉树，那用数组存储无疑是最节省内存的一种方式。因为数组的存储方式并不需要像链式存储法那样，要存储额外的左右子节点的指针。这也是为什么完全二叉树会单􏰁拎出来的原因，也是为什么完全二叉树要求最后一层的子节点都靠左的原因。</p>
<p><strong>遍历</strong></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gprtep5idfj31e40j8hdt.jpg" alt="image-20210422000801073"></p>
<p>时间复杂度O(n)，参考递归时间复杂度分析：f(n)=2*f(n/2)+1,且f(1)=1—-&gt;O(n)</p>
<ul>
<li><p>层序遍历</p>
<p>层序遍历是广度优先，BFS,需用到队列</p>
</li>
</ul>
<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gv2l8wn7w2j60k80d60t202.jpg" alt="image-20211004002912647" style="zoom:50%;" />

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BiTreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        self.data = data</span><br><span class="line">        self.left = <span class="literal">None</span>  <span class="comment"># 左孩子</span></span><br><span class="line">        self.right = <span class="literal">None</span>  <span class="comment"># 右孩子</span></span><br><span class="line"></span><br><span class="line">a =BiTreeNode(<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">b =BiTreeNode(<span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">c =BiTreeNode(<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">d =BiTreeNode(<span class="string">&#x27;D&#x27;</span>)</span><br><span class="line">e =BiTreeNode(<span class="string">&#x27;E&#x27;</span>)</span><br><span class="line">f =BiTreeNode(<span class="string">&#x27;F&#x27;</span>)</span><br><span class="line">g =BiTreeNode(<span class="string">&#x27;G&#x27;</span>)</span><br><span class="line"></span><br><span class="line">e.right= g</span><br><span class="line">e.left = a</span><br><span class="line">a.right = c</span><br><span class="line">c.left=b</span><br><span class="line">c.right=d</span><br><span class="line">g.right=f</span><br><span class="line"></span><br><span class="line">root =e</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(root.left.right.data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 二叉树前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pre_order</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="keyword">if</span> root: <span class="comment"># 非空</span></span><br><span class="line">        pre_order(root.left)</span><br><span class="line">        pre_order(root.right)</span><br><span class="line">        <span class="built_in">print</span>(root.data, end= <span class="string">&quot; &quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">level_order</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;层次遍历&quot;&quot;&quot;</span></span><br><span class="line">    queue = deque()</span><br><span class="line">    queue.append(root)</span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(queue)&gt;<span class="number">0</span>:  <span class="comment">#只要队不空</span></span><br><span class="line">        node = queue.popleft()</span><br><span class="line">        <span class="built_in">print</span>(node.data, end= <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> node.left:</span><br><span class="line">            queue.append(node.left)</span><br><span class="line">        <span class="keyword">if</span> node.right:</span><br><span class="line">            queue.append(node.right)</span><br><span class="line">level_order(root)</span><br></pre></td></tr></table></figure>

<ul>
<li>二叉树删除</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BiTreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,data</span>):</span></span><br><span class="line">        self.data = data</span><br><span class="line">        self.lchild= <span class="literal">None</span></span><br><span class="line">        self.rchild =<span class="literal">None</span></span><br><span class="line">        self.parent = <span class="literal">None</span>  <span class="comment"># 删除操作需要用到</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BST</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;二叉搜索树类&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, li=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.root =<span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> li:</span><br><span class="line">            <span class="keyword">for</span> val <span class="keyword">in</span> li:</span><br><span class="line">                self.insert_no_rec(val)</span><br><span class="line">                <span class="comment"># self.root = self.insert(self.root, val)</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self, node, val</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;注意递归形式时候要注意返回&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:  <span class="comment"># 空</span></span><br><span class="line">            node = BiTreeNode(val)</span><br><span class="line">        <span class="keyword">elif</span> val&lt;node.data:</span><br><span class="line">            node.lchild = self.insert(node.lchild, val)</span><br><span class="line">            node.lchild.parent = node</span><br><span class="line">        <span class="keyword">elif</span> val&gt;node.data:</span><br><span class="line">            node.rchild = self.insert(node.rchild, val)</span><br><span class="line">            node.rchild.parent= node</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert_no_rec</span>(<span class="params">self, val</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;非递归插入&quot;&quot;&quot;</span></span><br><span class="line">        p =self.root</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p:  <span class="comment"># 空树</span></span><br><span class="line">            self.root = BiTreeNode(val)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> val &lt;p.data: <span class="comment"># 插左子树</span></span><br><span class="line">                <span class="keyword">if</span> p.lchild:</span><br><span class="line">                    p = p.lchild</span><br><span class="line">                <span class="keyword">else</span>:  <span class="comment"># 左子树不存在</span></span><br><span class="line">                    p.lchild = BiTreeNode(val)</span><br><span class="line">                    p.lchild.parent = p</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">elif</span> val&gt;p.data:</span><br><span class="line">                <span class="keyword">if</span> p.rchild:</span><br><span class="line">                    p = p.rchild</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    p.rchild = BiTreeNode(val)</span><br><span class="line">                    p.rchild.parent=p</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">query</span>(<span class="params">self, node, val</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;递归查找&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> val&lt;node.data:</span><br><span class="line">            self.query(node.lchild)</span><br><span class="line">        <span class="keyword">elif</span> val&gt;node.data:</span><br><span class="line">            self.query(node.rchild)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">query_no_rec</span>(<span class="params">self, val</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;非递归查找&quot;&quot;&quot;</span></span><br><span class="line">        p = self.root</span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            <span class="keyword">if</span> val&gt;p.data:</span><br><span class="line">                p = p.rchild</span><br><span class="line">            <span class="keyword">elif</span> val&lt;p.data:</span><br><span class="line">                p = p.lchild</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> p</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__remove_node_1</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;情况1：node 是叶子节点</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node.parent:  <span class="comment"># 是根</span></span><br><span class="line">            self.root = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">elif</span> node.parent.lchild ==node:  <span class="comment"># node 是它父亲的左孩子</span></span><br><span class="line">            node.parent.lchild=<span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            node.parent.rchild = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__remove_node21</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;情况2：node只有一个左孩子&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node.parent:  <span class="comment"># 是根节点</span></span><br><span class="line">            self.root = node.lchild</span><br><span class="line">            node.lchild.parent =<span class="literal">None</span></span><br><span class="line">        <span class="keyword">elif</span> node == node.parent.lchild: <span class="comment"># 左孩子</span></span><br><span class="line">            node.parent.lchild = node.lchild</span><br><span class="line">            node.lchild.parent = node.parent</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            node.parent.rchild = node.lchid</span><br><span class="line">            node.lchild.parent = node.parent</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__remove_node22</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;情况2：node只有一个右孩子&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node.parent:  <span class="comment"># 判断根节点</span></span><br><span class="line">            self.root = node.rchild</span><br><span class="line">            node.rchild.parent =<span class="literal">None</span></span><br><span class="line">        <span class="keyword">elif</span> node == node.parent.lchild: <span class="comment"># node 是左孩子</span></span><br><span class="line">            node.parent.lchild = node.rchild</span><br><span class="line">            node.rchild.parent = node.parent</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            node.parent.rchild = node.rchild</span><br><span class="line">            node.rchild.parent = node.parent</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">self, val</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.root: <span class="comment"># 不是空树</span></span><br><span class="line">            node = self.query_no_rec(val)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:  <span class="comment"># node 不存在</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node.lchild <span class="keyword">and</span> <span class="keyword">not</span> node.rchild: <span class="comment"># 1.叶子节点</span></span><br><span class="line">                self.__remove_node_1(node)</span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> node.rchild:  <span class="comment"># 2.1 只有一个左孩子</span></span><br><span class="line">                self.__remove_node21(node)</span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> node.lchild:  <span class="comment"># 2.2 只有一个右孩子</span></span><br><span class="line">                self.__remove_node22(node)</span><br><span class="line">            <span class="keyword">else</span>:  <span class="comment"># 3. 两个孩子都有</span></span><br><span class="line">                min_node = node.rchild</span><br><span class="line">                <span class="keyword">while</span> min_node.lchild:  <span class="comment"># 查找右孩子的最小值</span></span><br><span class="line">                    min_node = min_node.lchild</span><br><span class="line">                node.data = min_node.data</span><br><span class="line">                <span class="comment"># 删除 min_node，只存在两种情况：</span></span><br><span class="line">                <span class="comment"># 1) 是叶子节点</span></span><br><span class="line">                <span class="comment"># 2）只有右孩子</span></span><br><span class="line">                <span class="keyword">if</span> min_node.rchild:</span><br><span class="line">                    self.__remove_node22(min_node)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    self.__remove_node_1(min_node)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 二叉树后序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post_order</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> root:  <span class="comment"># 非空</span></span><br><span class="line">            self.post_order(root.lchild)</span><br><span class="line">            self.post_order(root.rchild)</span><br><span class="line">            <span class="built_in">print</span>(root.data, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pre_order</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> root:  <span class="comment"># 非空</span></span><br><span class="line">            <span class="built_in">print</span>(root.data, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">            self.pre_order(root.lchild)</span><br><span class="line">            self.pre_order(root.rchild)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">in_order</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;中序遍历&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            self.in_order(root.lchild)</span><br><span class="line">            <span class="built_in">print</span>(root.data, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">            self.in_order(root.rchild)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">li = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1000</span>))</span><br><span class="line">random.shuffle(li)</span><br><span class="line"></span><br><span class="line">tree= BST([<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">7</span>])</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;中序遍历：&#x27;</span>)</span><br><span class="line">tree.in_order(tree.root)</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line">tree.delete(<span class="number">4</span>)</span><br><span class="line">tree.in_order(tree.root)</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line">tree.delete(<span class="number">8</span>)</span><br><span class="line">tree.in_order(tree.root)</span><br></pre></td></tr></table></figure>

<p>中序遍历：<br>1 2 3 4 5 6 7 8 9<br>1 2 3 5 6 7 8 9<br>1 2 3 5 6 7 9 </p>
<p><strong>二叉查找树</strong></p>
<p>二叉查找树要求，在树中的任意一个节点，其左子树中的每个节 点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值。</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqh6wj75snj31a80em4fd.jpg" alt="image-20210422233911033"></p>
<p>中序遍历二叉查找树，可以输出有 序的数据序列，时间复杂度是 O(n)<strong>，非常高效</strong>。因此，二叉查找树也叫作二叉排序树。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BiTreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,data</span>):</span></span><br><span class="line">        self.data = data</span><br><span class="line">        self.lchild= <span class="literal">None</span></span><br><span class="line">        self.rchild =<span class="literal">None</span></span><br><span class="line">        self.parent = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BST</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;二叉搜索树类&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, li=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.root =<span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> li:</span><br><span class="line">            <span class="keyword">for</span> val <span class="keyword">in</span> li:</span><br><span class="line">                self.insert_no_rec(val)</span><br><span class="line">                <span class="comment"># self.root = self.insert(self.root, val)</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self, node, val</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;注意递归形式时候要注意返回&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:  <span class="comment"># 空</span></span><br><span class="line">            node = BiTreeNode(val)</span><br><span class="line">        <span class="keyword">elif</span> val&lt;node.data:</span><br><span class="line">            node.lchild = self.insert(node.lchild, val)</span><br><span class="line">            node.lchild.parent = node</span><br><span class="line">        <span class="keyword">elif</span> val&gt;node.data:</span><br><span class="line">            node.rchild = self.insert(node.rchild, val)</span><br><span class="line">            node.rchild.parent= node</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert_no_rec</span>(<span class="params">self, val</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;非递归插入&quot;&quot;&quot;</span></span><br><span class="line">        p =self.root</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p:  <span class="comment"># 空树</span></span><br><span class="line">            self.root = BiTreeNode(val)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> val &lt;p.data: <span class="comment"># 插左子树</span></span><br><span class="line">                <span class="keyword">if</span> p.lchild:</span><br><span class="line">                    p = p.lchild</span><br><span class="line">                <span class="keyword">else</span>:  <span class="comment"># 左子树不存在</span></span><br><span class="line">                    p.lchild = BiTreeNode(val)</span><br><span class="line">                    p.lchild.parent = p</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">elif</span> val&gt;p.data:</span><br><span class="line">                <span class="keyword">if</span> p.rchild:</span><br><span class="line">                    p = p.rchild</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    p.rchild = BiTreeNode(val)</span><br><span class="line">                    p.rchild.parent=p</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 二叉树后序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post_order</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> root:  <span class="comment"># 非空</span></span><br><span class="line">            self.post_order(root.lchild)</span><br><span class="line">            self.post_order(root.rchild)</span><br><span class="line">            <span class="built_in">print</span>(root.data, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pre_order</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> root:  <span class="comment"># 非空</span></span><br><span class="line">            <span class="built_in">print</span>(root.data, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">            self.pre_order(root.lchild)</span><br><span class="line">            self.pre_order(root.rchild)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">in_order</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;中序遍历&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            self.in_order(root.lchild)</span><br><span class="line">            <span class="built_in">print</span>(root.data, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">            self.in_order(root.rchild)</span><br><span class="line"></span><br><span class="line">li = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1000</span>))</span><br><span class="line">random.shuffle(li)</span><br><span class="line"></span><br><span class="line">tree= BST([<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>])</span><br><span class="line"><span class="comment"># tree= BST(li)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;前序遍历：&#x27;</span>)</span><br><span class="line">tree.pre_order(tree.root)</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;中序遍历：&#x27;</span>)</span><br><span class="line">tree.in_order(tree.root)</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;后续遍历：&#x27;</span>)</span><br><span class="line">tree.post_order(tree.root)</span><br></pre></td></tr></table></figure>

<p>前序遍历：<br>4 2 1 3 6 5 7 9 8<br>中序遍历：<br>1 2 3 4 5 6 7 8 9<br>后续遍历：<br>1 3 2 5 8 9 7 6 4 </p>
<p><strong>红黑树</strong></p>
<p>为了避免复杂度的退化，引入<strong>平衡</strong>二叉查找树，红黑树就是其中的一种</p>
<p>在 1972 年由鲁道夫·贝尔发明，被称为”对称二叉 B 树”，它现代的名字源于 Leo J. Guibas 和 Robert Sedgewick 于 1978 年写的一篇论文。红黑树的结构复杂，但它的操作有着良好的最坏情况运行时间，并且在实践中高效：它可以在 O(logn) 时间内完成查找，插入和删除，这里的 n 是树中元素的数目</p>
<p><strong>B 树</strong></p>
<p>数据库使用</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gv3ccp46mcj61500icwgk02.jpg" alt="image-20211004160702092"></p>
<p><strong>堆</strong></p>
<p>堆其实是一种优先级队列，在很多语言都有对应的内置数据结构</p>
<p><code>需要满足下面两个条件</code>：</p>
<p>1.堆是一个完全二叉树;</p>
<p>2.堆中每一个节点的值都必须大于等于(或小于等于)其子树中每个节点的值。</p>
<p>由于堆是完全二叉树，所以用数组来存储会非常省空间，且单纯通过数组下标就可定位左右子节点和父节点</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1guzv2zvv9nj616o0hm42002.jpg" alt="IMG_9CBB656E4D45-1"></p>
<ul>
<li>堆排序</li>
</ul>
<p><code>sift</code> 函数处理的问题:</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvf86vmhhyj60xw0h4myl02.jpg" alt="image-20211014224948980"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sift</span>(<span class="params">li, low, high</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    向下调整实现</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param li: 列表</span></span><br><span class="line"><span class="string">    :param low: 堆的根节点位置</span></span><br><span class="line"><span class="string">    :param high: 堆的最后一个元素位置</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    i = low  <span class="comment"># i 指向根节点</span></span><br><span class="line">    j = <span class="number">2</span>*i+<span class="number">1</span>  <span class="comment"># j 开始是左孩子</span></span><br><span class="line">    tmp = li[low]  <span class="comment"># 把堆顶存起来</span></span><br><span class="line">    <span class="keyword">while</span> j&lt;=high: <span class="comment"># 只要j位置有数</span></span><br><span class="line">        <span class="keyword">if</span> j+<span class="number">1</span>&lt;=high <span class="keyword">and</span> li[j+<span class="number">1</span>]&gt;li[j]:  <span class="comment"># 右孩子有，且右孩子大</span></span><br><span class="line">            j = j+<span class="number">1</span>  <span class="comment"># j 换到右孩子分支</span></span><br><span class="line">        <span class="keyword">if</span> li[j]&gt;tmp:</span><br><span class="line">            li[i] = li[j]  <span class="comment"># 上去</span></span><br><span class="line">            i =j  <span class="comment"># 往下看一层</span></span><br><span class="line">            j = <span class="number">2</span>*i +<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            li[i]=tmp  <span class="comment"># 把 tmp 放到某一级领导的位置,此行代码可不写</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    li[i]= tmp  <span class="comment"># i到了叶子节点，需要将tmp 放过去</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heap_sort</span>(<span class="params">li</span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(li)</span><br><span class="line">    <span class="comment"># 建堆，此处为 大根堆</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>((n-<span class="number">2</span>)//<span class="number">2</span>, -<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">        <span class="comment"># i 表示建堆时候需要调整部分的根的下标</span></span><br><span class="line">        sift(li, i, n-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">        <span class="built_in">print</span>(i,<span class="string">&#x27;!!&#x27;</span>)</span><br><span class="line">        <span class="comment"># i指向待处理堆的最后一个元素</span></span><br><span class="line">        li[i], li[<span class="number">0</span>] = li[<span class="number">0</span>], li[i]</span><br><span class="line">        sift(li, <span class="number">0</span>, i-<span class="number">1</span>)  <span class="comment"># i-1 是新的high</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">li = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line">random.shuffle(li)</span><br><span class="line"><span class="built_in">print</span>(li)</span><br><span class="line">heap_sort(li)</span><br><span class="line"><span class="built_in">print</span>(li)</span><br></pre></td></tr></table></figure>

<p>过程：</p>
<p>1） 建堆</p>
<p>从最后一个非叶子节点开始，’农村包围城市‘</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1guzvcji4emj60u00ug7an02.jpg" alt="image-20211001160159720"></p>
<p>2）堆顶元素取回</p>
<p>3）向下调整</p>
<p>4）重复2）</p>
<blockquote>
<p>堆排序不稳定，建堆的时间复杂度为 O(n)</p>
</blockquote>
<ul>
<li>堆 的应用</li>
</ul>
<p>1）优先级队列</p>
<p>队列是先进先出，不过优先级队列则是优先级最高的，最先出队</p>
<p>一个堆，就可以看作一个优先级队列</p>
<p>后面的许多数据结构，如赫尔曼编码、图的最短路径、最小生成树算法等都要依赖它</p>
<p>如，合并有序小文件</p>
<blockquote>
<p>假设我们有 100 个小文件，每个文件的大小是 100MB，每个文件中存储的都是有序的字符串。我们希望将这些 100 个小文件合并成一个有序的大文件。这里就会用到优先级队列。</p>
</blockquote>
<p>通过建立堆(大小为文件个数)，通过不停地 ‘堆顶写入–删除—插入’ 来实现复杂度O(log n)，其中n 表示堆中数据个数</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gr20z3neoij61140t27aq02.jpg" alt="image-20210531232612740"></p>
<p>2） 求Top K</p>
<p>需一直维护一个大小为K的小顶堆，复杂度 nlog(K)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sift</span>(<span class="params">li, low, high</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    向下调整实现</span></span><br><span class="line"><span class="string">    小根堆</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param li: 列表</span></span><br><span class="line"><span class="string">    :param low: 堆的根节点位置</span></span><br><span class="line"><span class="string">    :param high: 堆的最后一个元素位置</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    i = low  <span class="comment"># i 指向根节点</span></span><br><span class="line">    j = <span class="number">2</span>*i+<span class="number">1</span>  <span class="comment"># j 开始是左孩子</span></span><br><span class="line">    tmp = li[low]  <span class="comment"># 把堆顶存起来</span></span><br><span class="line">    <span class="keyword">while</span> j&lt;=high: <span class="comment"># 只要j位置有数</span></span><br><span class="line">        <span class="keyword">if</span> j+<span class="number">1</span>&lt;=high <span class="keyword">and</span> li[j+<span class="number">1</span>] &lt; li[j]:  <span class="comment"># 右孩子有，且右孩子小</span></span><br><span class="line">            j = j+<span class="number">1</span>  <span class="comment"># j 换到右孩子分支</span></span><br><span class="line">        <span class="keyword">if</span> li[j]&lt;tmp:</span><br><span class="line">            li[i] = li[j]  <span class="comment"># 上去</span></span><br><span class="line">            i =j  <span class="comment"># 往下看一层</span></span><br><span class="line">            j = <span class="number">2</span>*i +<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            li[i]=tmp  <span class="comment"># 把 tmp 放到某一级领导的位置,此行代码可不写</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    li[i]= tmp  <span class="comment"># i到了叶子节点，需要将tmp 放过去</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">topk</span>(<span class="params">li, k</span>):</span></span><br><span class="line">    heap = li[:k]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>((k-<span class="number">2</span>)//<span class="number">2</span>, -<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">        sift(heap, i, k-<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 比较</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k, <span class="built_in">len</span>(li)):</span><br><span class="line">        <span class="keyword">if</span> li[i]&gt;heap[<span class="number">0</span>]:</span><br><span class="line">            heap[<span class="number">0</span>]= li[i]</span><br><span class="line">            sift(heap,<span class="number">0</span> ,k-<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># k个值堆排序，出数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">        heap[i], heap[<span class="number">0</span>] = heap[<span class="number">0</span>], heap[i]</span><br><span class="line">        sift(heap, <span class="number">0</span>, i-<span class="number">1</span>)  <span class="comment"># i-1 是新的high</span></span><br><span class="line">    <span class="keyword">return</span> heap</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">li = list(range(1000))</span><br><span class="line">random.shuffle(li)</span><br><span class="line">print(li)</span><br><span class="line">topk_li = topk(li,10)</span><br><span class="line">print(topk_li)</span><br><span class="line">[999, 998, 997, 996, 995, 994, 993, 992, 991, 990]</span><br></pre></td></tr></table></figure>



<ol start="3">
<li>有一个10亿搜索关键词的日志文件，如何获取Top10最热门的搜索关键词？</li>
</ol>
<p>方法1： MapReduce</p>
<p>方法2： 单机，可使用内存 1G</p>
<p>初始方案：</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gr34pbvpvwj31580fq0yh.jpg" alt="image-20210601222103242"></p>
<p>但是，字典占据空间太大，内存不够</p>
<p>改进：</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gr35ejvcjpj31je0lawr8.jpg" alt="image-20210601224517136"></p>
<p><strong>Trie 树</strong></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gro179xlf0j30al06q74c.jpg" alt="img"></p>
<p>Trie <strong>树的本质，就是利用字符串之间的公共前缀，将重复的前缀合并在一起</strong>。</p>
<p>Trie 树只是不适合精确匹配查找，这种问题更适合用散列表或者红黑树来解决。Trie 树比较适 合的是查找前缀匹配的字符串，也就是类似开篇问题的那种场景。</p>
<p>关于 Trie 的应用场景，希望你能记住 8 个字：<strong>一次建树，多次查询</strong>。</p>
<ul>
<li>应用</li>
</ul>
<p>搜索引擎关键词提示，底层最基本的原理就是 Trie 树</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNgy1grmtz93bvej31560t8wqs.jpg" alt="image-20210618232114437" style="zoom:33%;" />

<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><p>图与树类似，区别在于图没有子结点或父结点，因此也没有根结点。图由结点和边构成，且任何结点可以有多个入边或出边。<br>图是最灵活的数据结构，几乎可以表示所有类型的数据。例如，图非常适合描述社交网络，其中结点代表人，边代表人与人之间的友谊。</p>
<p><strong>基本概念</strong></p>
<p>顶点：图中的元素</p>
<p>边：顶点与顶点之间建立的关系</p>
<p>度：每个用户有多少个好友， 对应到图中，就叫做顶点的<strong>度</strong>(degree)，就是跟顶点相连接的边的条数。</p>
<p>权重：边表示关系的重要程度</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gr35zdekfmj30mm0awdhq.jpg" alt="image-20210601230517752" style="zoom:53%;" />

<p>无向图等价于双向有向图（环）：</p>
<img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2g6is3b67j216u09ut9q.jpg" alt="image-20220521175958026" style="zoom:33%;" />

<p><strong>存储</strong></p>
<p>1）邻接矩阵</p>
<img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2g6ooshu8j212c0muwh7.jpg" alt="image-20220521180538662" style="zoom:50%;" />

<p>2）邻接表：</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqh6wzd1jdj315c0t0b29.jpg" alt="image-20210428232950016" style="zoom:50%;" />



<p><strong>搜索</strong></p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2jssliptxj20qg0cgt9y.jpg" alt="image-20220202174431733"></p>
<ul>
<li>DFS: 栈，更省内存</li>
</ul>
<p>伪代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//从第v个顶点出发递归地深度优先遍历图G</span><br><span class="line">void DFS(Graph G, int v)</span><br><span class="line">&#123;</span><br><span class="line">    VisitFunction(v); //访问v点，并将其标记为访问过的节点;</span><br><span class="line">    for_each(vi: v的所有邻接点)//遍历v的所有邻接点</span><br><span class="line">    &#123;</span><br><span class="line">        if(vi没有被访问过)</span><br><span class="line">            DFS(G, vi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>BFS：队列，更快可能</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void BFS(Graph G, int v)</span><br><span class="line">&#123;</span><br><span class="line">    for_each(vi: v的所有邻接点)//遍历v的所有邻接点</span><br><span class="line">    &#123;</span><br><span class="line">        if(vi没有被访问过)</span><br><span class="line">        &#123;</span><br><span class="line">            VisitFunction(vi); //访问v点;</span><br><span class="line">            EnQueue(Q, vi); //vi入队列</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    while(!QueueEmpty(Q))</span><br><span class="line">    &#123;</span><br><span class="line">        DeQueue(Q, u);  //队头元素出队并置为u</span><br><span class="line">        BFS(G, u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>BFS查找朋友中是否有芒果商</li>
</ul>
<img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2g7pjvf6jj21bu0u042d.jpg" alt="image-20220521184103731" style="zoom:33%;" />

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">person_is_seller</span>(<span class="params">name</span>):</span></span><br><span class="line">      <span class="keyword">return</span> name[-<span class="number">1</span>] == <span class="string">&#x27;m&#x27;</span></span><br><span class="line"></span><br><span class="line">graph = &#123;&#125;</span><br><span class="line">graph[<span class="string">&quot;you&quot;</span>] = [<span class="string">&quot;alice&quot;</span>, <span class="string">&quot;bob&quot;</span>, <span class="string">&quot;claire&quot;</span>]</span><br><span class="line">graph[<span class="string">&quot;bob&quot;</span>] = [<span class="string">&quot;anuj&quot;</span>, <span class="string">&quot;peggy&quot;</span>]</span><br><span class="line">graph[<span class="string">&quot;alice&quot;</span>] = [<span class="string">&quot;peggy&quot;</span>]</span><br><span class="line">graph[<span class="string">&quot;claire&quot;</span>] = [<span class="string">&quot;thom&quot;</span>, <span class="string">&quot;jonny&quot;</span>]</span><br><span class="line">graph[<span class="string">&quot;anuj&quot;</span>] = []</span><br><span class="line">graph[<span class="string">&quot;peggy&quot;</span>] = []</span><br><span class="line">graph[<span class="string">&quot;thom&quot;</span>] = []</span><br><span class="line">graph[<span class="string">&quot;jonny&quot;</span>] = []</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">name</span>):</span></span><br><span class="line">    search_queue = deque()</span><br><span class="line">    search_queue += graph[name]</span><br><span class="line">    <span class="comment"># This is how you keep track of which people you&#x27;ve searched before.</span></span><br><span class="line">    searched = <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">while</span> search_queue:</span><br><span class="line">        person = search_queue.popleft()</span><br><span class="line">        <span class="keyword">if</span> person <span class="keyword">not</span> <span class="keyword">in</span> searched:</span><br><span class="line">            <span class="keyword">if</span> person_is_seller(person):</span><br><span class="line">                <span class="built_in">print</span>(person + <span class="string">&quot; is a mango seller!&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                search_queue += graph[person]  <span class="comment"># 入队</span></span><br><span class="line">                searched.add(person)  <span class="comment"># 标记为已检查</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">search(<span class="string">&quot;you&quot;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>戴克斯特拉算法</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/zh-sg/%E6%88%B4%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95">维基百科定义</a>：</p>
<blockquote>
<p><strong>戴克斯特拉算法</strong>（英语：Dijkstra’s algorithm），又译<strong>迪杰斯特拉算法</strong>，亦可不音译而称为<strong>Dijkstra算法</strong>[<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/zh-sg/%E6%88%B4%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95#cite_note-6">6]</a>，是由荷兰电脑科学家<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/%E8%89%BE%E5%85%B9%E8%B5%AB%E5%B0%94%C2%B7%E6%88%B4%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89">艾兹赫尔·戴克斯特拉</a>在1956年发现的算法，并于3年后在<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/%E5%AD%A6%E6%9C%AF%E6%9C%9F%E5%88%8A">期刊</a>上发表[<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/zh-sg/%E6%88%B4%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95#cite_note-7">7]</a>[<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/zh-sg/%E6%88%B4%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95#cite_note-Dijkstra_Interview-8">8]</a>[<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/zh-sg/%E6%88%B4%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95#cite_note-Dijkstra1959-9">9]</a>。戴克斯特拉算法使用类似<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2">广度优先搜索</a>的方法解决赋权图[<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/zh-sg/%E6%88%B4%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95#cite_note-Dijkstra1959-9">9]</a>的单源<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98">最短路径问题</a>[<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/zh-sg/%E6%88%B4%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95#cite_note-felner-10">10]</a>[<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/zh-sg/%E6%88%B4%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95#cite_note-IntroToAlgo-1">1]</a>[<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/zh-sg/%E6%88%B4%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95#cite_note-Discrete-2">2]</a>。</p>
</blockquote>
<p>针对加权图（且权重要为正）中最短路径，且只适用于<u>有向无环图</u></p>
<p>算法如下：</p>
<ol>
<li>设来源节点的距离值为 0，其余节点的距离值为最大值；</li>
<li>选择并固定距离值最小的非固定节点；（贪心）</li>
<li>依次松弛起点为当前节点的所有边，跳过终点已被固定的边，更新路径长度；</li>
<li>重复（2）～（4）至所有节点都被固定。</li>
</ol>
<blockquote>
<p>👇🏻图为<strong>戴克斯特拉算法</strong>应用示意图。<br>起点以左下角的红点，目标是右上角的绿点，中间灰色的倒L型为障碍物。蓝色空圈表示”暂定”，用以搜索下一步；已经填充颜色的表示探访过，图中颜色以红到绿，越绿表示离起点越远。所有节点都被均匀的探索。</p>
</blockquote>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/2/23/Dijkstras_progress_animation.gif" alt="img"></p>
<p>e.g. 以乐谱换购钢琴为例，求最小代价：</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2ge2dv01qj218a0gg0vw.jpg" alt="image-20220521222057059"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># the graph</span></span><br><span class="line">graph = &#123;&#125;</span><br><span class="line">graph[<span class="string">&quot;乐谱&quot;</span>] = &#123;&#125;</span><br><span class="line">graph[<span class="string">&quot;乐谱&quot;</span>][<span class="string">&quot;唱片&quot;</span>] = <span class="number">5</span></span><br><span class="line">graph[<span class="string">&quot;乐谱&quot;</span>][<span class="string">&quot;海报&quot;</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">graph[<span class="string">&quot;唱片&quot;</span>] = &#123;&#125;</span><br><span class="line">graph[<span class="string">&quot;唱片&quot;</span>][<span class="string">&quot;吉他&quot;</span>] = <span class="number">15</span></span><br><span class="line">graph[<span class="string">&quot;唱片&quot;</span>][<span class="string">&quot;鼓&quot;</span>] = <span class="number">20</span></span><br><span class="line"></span><br><span class="line">graph[<span class="string">&quot;海报&quot;</span>] = &#123;&#125;</span><br><span class="line">graph[<span class="string">&quot;海报&quot;</span>][<span class="string">&quot;吉他&quot;</span>] = <span class="number">30</span></span><br><span class="line">graph[<span class="string">&quot;海报&quot;</span>][<span class="string">&quot;鼓&quot;</span>] = <span class="number">35</span></span><br><span class="line"></span><br><span class="line">graph[<span class="string">&quot;吉他&quot;</span>] = &#123;&#125;</span><br><span class="line">graph[<span class="string">&quot;吉他&quot;</span>][<span class="string">&quot;钢琴&quot;</span>] = <span class="number">20</span></span><br><span class="line"></span><br><span class="line">graph[<span class="string">&quot;鼓&quot;</span>] = &#123;&#125;</span><br><span class="line">graph[<span class="string">&quot;鼓&quot;</span>][<span class="string">&quot;钢琴&quot;</span>] = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">graph[<span class="string">&quot;钢琴&quot;</span>] = &#123;&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;graph :<span class="subst">&#123;graph&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="comment"># the costs table</span></span><br><span class="line">infinity = <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)</span><br><span class="line">costs = &#123;&#125;</span><br><span class="line">costs[<span class="string">&quot;唱片&quot;</span>] = <span class="number">5</span></span><br><span class="line">costs[<span class="string">&quot;海报&quot;</span>] = <span class="number">0</span></span><br><span class="line">costs[<span class="string">&quot;吉他&quot;</span>] = infinity</span><br><span class="line">costs[<span class="string">&quot;鼓&quot;</span>] = infinity</span><br><span class="line">costs[<span class="string">&quot;钢琴&quot;</span>] = infinity</span><br><span class="line"></span><br><span class="line"><span class="comment"># the parents table</span></span><br><span class="line">parents = &#123;&#125;</span><br><span class="line">parents[<span class="string">&quot;唱片&quot;</span>] = <span class="string">&quot;乐谱&quot;</span></span><br><span class="line">parents[<span class="string">&quot;海报&quot;</span>] = <span class="string">&quot;乐谱&quot;</span></span><br><span class="line">parents[<span class="string">&quot;吉他&quot;</span>] = <span class="literal">None</span></span><br><span class="line">parents[<span class="string">&quot;鼓&quot;</span>] = <span class="literal">None</span></span><br><span class="line">parents[<span class="string">&quot;钢琴&quot;</span>] = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">processed = []  <span class="comment"># 记录处理过的节点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_lowest_cost_node</span>(<span class="params">costs</span>):</span></span><br><span class="line">    lowest_cost = <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)</span><br><span class="line">    lowest_cost_node = <span class="literal">None</span></span><br><span class="line">    <span class="comment"># Go through each node.</span></span><br><span class="line">    <span class="keyword">for</span> node <span class="keyword">in</span> costs:</span><br><span class="line">        cost = costs[node]</span><br><span class="line">        <span class="comment"># If it&#x27;s the lowest cost so far and hasn&#x27;t been processed yet...</span></span><br><span class="line">        <span class="keyword">if</span> cost &lt; lowest_cost <span class="keyword">and</span> node <span class="keyword">not</span> <span class="keyword">in</span> processed:  <span class="comment"># 松弛 且跳过，参见算法步骤3</span></span><br><span class="line">            <span class="comment"># ... set it as the new lowest-cost node.</span></span><br><span class="line">            lowest_cost = cost</span><br><span class="line">            lowest_cost_node = node</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;最低花费的node: &#x27;</span>, lowest_cost_node,<span class="string">&#x27;---&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;processed: <span class="subst">&#123;processed&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> lowest_cost_node</span><br><span class="line"></span><br><span class="line"><span class="comment"># Find the lowest-cost node that you haven&#x27;t processed yet.</span></span><br><span class="line">node = find_lowest_cost_node(costs)</span><br><span class="line"><span class="comment"># If you&#x27;ve processed all the nodes, this while loop is done.</span></span><br><span class="line"><span class="keyword">while</span> node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">    cost = costs[node]</span><br><span class="line">    <span class="comment"># Go through all the neighbors of this node.</span></span><br><span class="line">    neighbors = graph[node]</span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> neighbors.keys():</span><br><span class="line">        new_cost = cost + neighbors[n]</span><br><span class="line">        <span class="comment"># If it&#x27;s cheaper to get to this neighbor by going through this node...</span></span><br><span class="line">        <span class="keyword">if</span> costs[n] &gt; new_cost:</span><br><span class="line">            <span class="comment"># ... update the cost for this node.</span></span><br><span class="line">            costs[n] = new_cost</span><br><span class="line">            <span class="comment"># This node becomes the new parent for this neighbor.</span></span><br><span class="line">            parents[n] = node</span><br><span class="line">    <span class="comment"># Mark the node as processed.</span></span><br><span class="line">    processed.append(node)  <span class="comment"># 固定节点</span></span><br><span class="line">    <span class="comment"># Find the next node to process, and loop.</span></span><br><span class="line">    node = find_lowest_cost_node(costs)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Cost from the start to each node:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(costs)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">graph :&#123;&#x27;乐谱&#x27;: &#123;&#x27;唱片&#x27;: 5, &#x27;海报&#x27;: 0&#125;, &#x27;唱片&#x27;: &#123;&#x27;吉他&#x27;: 15, &#x27;鼓&#x27;: 20&#125;, &#x27;海报&#x27;: &#123;&#x27;吉他&#x27;: 30, &#x27;鼓&#x27;: 35&#125;, &#x27;吉他&#x27;: &#123;&#x27;钢琴&#x27;: 20&#125;, &#x27;鼓&#x27;: &#123;&#x27;钢琴&#x27;: 10&#125;, &#x27;钢琴&#x27;: &#123;&#125;&#125;</span><br><span class="line">最低花费的node:  海报 ---</span><br><span class="line">processed: []</span><br><span class="line">最低花费的node:  唱片 ---</span><br><span class="line">processed: [&#x27;海报&#x27;]</span><br><span class="line">最低花费的node:  吉他 ---</span><br><span class="line">processed: [&#x27;海报&#x27;, &#x27;唱片&#x27;]</span><br><span class="line">最低花费的node:  鼓 ---</span><br><span class="line">processed: [&#x27;海报&#x27;, &#x27;唱片&#x27;, &#x27;吉他&#x27;]</span><br><span class="line">最低花费的node:  钢琴 ---</span><br><span class="line">processed: [&#x27;海报&#x27;, &#x27;唱片&#x27;, &#x27;吉他&#x27;, &#x27;鼓&#x27;]</span><br><span class="line">最低花费的node:  None ---</span><br><span class="line">processed: [&#x27;海报&#x27;, &#x27;唱片&#x27;, &#x27;吉他&#x27;, &#x27;鼓&#x27;, &#x27;钢琴&#x27;]</span><br><span class="line">Cost from the start to each node:</span><br><span class="line">&#123;&#x27;唱片&#x27;: 5, &#x27;海报&#x27;: 0, &#x27;吉他&#x27;: 20, &#x27;鼓&#x27;: 25, &#x27;钢琴&#x27;: 35&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li> 迷宫问题</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gv1fzbloegj614q0fgjtb02.jpg" alt="image-20211003004126297"></p>
<p>code 两种思路: DFS、BFS</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">maze= [</span><br><span class="line">    [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>],  <span class="comment"># 5</span></span><br><span class="line">    [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">]</span><br><span class="line">maze1 = copy.deepcopy(maze)</span><br><span class="line">maze2 = copy.deepcopy(maze)</span><br><span class="line"></span><br><span class="line">dirs = [</span><br><span class="line">    <span class="keyword">lambda</span> x,y:(x,y+<span class="number">1</span>),</span><br><span class="line">    <span class="keyword">lambda</span> x,y:(x+<span class="number">1</span>,y),</span><br><span class="line">    <span class="keyword">lambda</span> x,y:(x,y-<span class="number">1</span>),</span><br><span class="line">    <span class="keyword">lambda</span> x,y:(x-<span class="number">1</span>,y),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_path</span>(<span class="params">path</span>):</span></span><br><span class="line">    cur_node = path[-<span class="number">1</span>]</span><br><span class="line">    real_path = []</span><br><span class="line">    <span class="keyword">while</span> cur_node[<span class="number">2</span>] != -<span class="number">1</span>:</span><br><span class="line">        real_path.append(cur_node[<span class="number">0</span>:<span class="number">2</span>])</span><br><span class="line">        cur_node = path[cur_node[<span class="number">2</span>]]</span><br><span class="line">    real_path.append(cur_node[<span class="number">0</span>:<span class="number">2</span>])  <span class="comment"># 把起点放进去</span></span><br><span class="line">    real_path.reverse()  <span class="comment"># 翻转</span></span><br><span class="line">    <span class="keyword">for</span> node <span class="keyword">in</span> real_path:</span><br><span class="line">        <span class="built_in">print</span>(node,end=<span class="string">&#x27;&gt;&gt;&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maze_path_queue</span>(<span class="params">x1,y1,x2,y2</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    队列实现，广度优先</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param x1:</span></span><br><span class="line"><span class="string">    :param y1:</span></span><br><span class="line"><span class="string">    :param x2:</span></span><br><span class="line"><span class="string">    :param y2:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># a = maze1</span></span><br><span class="line">    queue = deque()</span><br><span class="line">    queue.append((x1,y1,-<span class="number">1</span>))</span><br><span class="line">    path_record_pop = []  <span class="comment"># 记录出队的点,便于输出最终路径</span></span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        cur_node = queue.popleft()</span><br><span class="line">        path_record_pop.append(cur_node)</span><br><span class="line">        <span class="keyword">if</span> cur_node[<span class="number">0</span>]==x2 <span class="keyword">and</span> cur_node[<span class="number">1</span>]==y2:</span><br><span class="line">            print_path(path_record_pop)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">dir</span> <span class="keyword">in</span> dirs:  <span class="comment"># 探视当前点周围情况</span></span><br><span class="line">            next_node = <span class="built_in">dir</span>(cur_node[<span class="number">0</span>], cur_node[<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">if</span> maze1[next_node[<span class="number">0</span>]][next_node[<span class="number">1</span>]]==<span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 记录next节点来自哪里</span></span><br><span class="line">                queue.append((next_node[<span class="number">0</span>], next_node[<span class="number">1</span>], <span class="built_in">len</span>(path_record_pop)-<span class="number">1</span>))</span><br><span class="line">                maze1[next_node[<span class="number">0</span>]][next_node[<span class="number">1</span>]] =<span class="string">&#x27;♨&#x27;</span> <span class="comment"># 标记为走过</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;没有路&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maze_path</span>(<span class="params">x1,y1,x2,y2</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    迷宫路径</span></span><br><span class="line"><span class="string">    采用栈，深度优先搜索 DSF，回溯法</span></span><br><span class="line"><span class="string">    一条路走到黑</span></span><br><span class="line"><span class="string">    缺点：不能保证是最短路径</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    0 0 0 0</span></span><br><span class="line"><span class="string">    1 1 1 [1]-&gt;(1,3)</span></span><br><span class="line"><span class="string">    0 1 0 1</span></span><br><span class="line"><span class="string">    :param x1: 起点位置，行</span></span><br><span class="line"><span class="string">    :param y1:</span></span><br><span class="line"><span class="string">    :param x2: 终点位置</span></span><br><span class="line"><span class="string">    :param y2:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    stack = []</span><br><span class="line">    stack.append((x1,y1))</span><br><span class="line">    maze2[x1][y1] = <span class="string">&#x27;♨&#x27;</span>  <span class="comment"># 标记为已走过</span></span><br><span class="line">    <span class="keyword">while</span> stack:  <span class="comment"># 非空</span></span><br><span class="line">        a =maze2</span><br><span class="line">        current_node = stack[-<span class="number">1</span>]  <span class="comment"># 当前节点</span></span><br><span class="line">        <span class="keyword">if</span> current_node==(x2,y2): <span class="comment"># 走到终点</span></span><br><span class="line">            <span class="keyword">for</span> p <span class="keyword">in</span> stack:</span><br><span class="line">                <span class="built_in">print</span>(p, end=<span class="string">&#x27;-&gt;&#x27;</span>)</span><br><span class="line">            <span class="built_in">print</span>()</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">dir</span> <span class="keyword">in</span> dirs:</span><br><span class="line">            next_node = <span class="built_in">dir</span>(current_node[<span class="number">0</span>], current_node[<span class="number">1</span>])</span><br><span class="line">            <span class="comment"># 如果下一个节点能走</span></span><br><span class="line">            <span class="keyword">if</span> maze2[next_node[<span class="number">0</span>]][next_node[<span class="number">1</span>]]==<span class="number">0</span>:</span><br><span class="line">                stack.append(next_node)</span><br><span class="line">                maze2[next_node[<span class="number">0</span>]][next_node[<span class="number">1</span>]] = <span class="string">&#x27;♨&#x27;</span>  <span class="comment"># 标记为已走过</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>: <span class="comment"># 回退，注意这里必须写成for-else 语句, break执行则此步不执行</span></span><br><span class="line">            stack.pop()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;没有路&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">start_end = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>)  <span class="comment"># 起点-终点坐标</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;深度优先：&#x27;</span>)</span><br><span class="line">maze_path(start_end[<span class="number">0</span>],start_end[<span class="number">1</span>],start_end[<span class="number">2</span>],start_end[<span class="number">3</span>])</span><br><span class="line">maze2[start_end[<span class="number">0</span>]][start_end[<span class="number">1</span>]]=<span class="string">&#x27;■&#x27;</span></span><br><span class="line">maze2[start_end[<span class="number">2</span>]][start_end[<span class="number">3</span>]]=<span class="string">&#x27;☆&#x27;</span></span><br><span class="line">df1 = pd.DataFrame(maze2)</span><br><span class="line">df2 =pd.DataFrame(maze)</span><br><span class="line">df_ = pd.DataFrame([[<span class="string">&#x27;|&#x27;</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(maze))])</span><br><span class="line"><span class="built_in">print</span>(pd.concat([df1,df_, df2],axis=<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;----&#x27;</span>*<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;广度优先：&#x27;</span>)</span><br><span class="line">maze_path_queue(start_end[<span class="number">0</span>],start_end[<span class="number">1</span>],start_end[<span class="number">2</span>],start_end[<span class="number">3</span>])</span><br><span class="line">maze1[start_end[<span class="number">0</span>]][start_end[<span class="number">1</span>]]=<span class="string">&#x27;■&#x27;</span></span><br><span class="line">maze1[start_end[<span class="number">2</span>]][start_end[<span class="number">3</span>]]=<span class="string">&#x27;☆&#x27;</span></span><br><span class="line">df1 = pd.DataFrame(maze1,index=<span class="literal">None</span>)</span><br><span class="line">df2 =pd.DataFrame(maze)</span><br><span class="line">df_ = pd.DataFrame([[<span class="string">&#x27;|&#x27;</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(maze))])</span><br><span class="line"><span class="built_in">print</span>(pd.concat([df1,df_, df2],axis=<span class="number">1</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>具体执行结果差异如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gv20xsmyf6j61tm0tu43t02.jpg" alt="image-20211003124633168"></p>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><blockquote>
<p>掌握程度:轻松写出二叉树遍历、八皇后、背包问题、DFS 的递归代码</p>
</blockquote>
<p>递归表示函数在定义中调用自身</p>
<p>递归包括两个过程 ，去的过程叫’递‘，回来的过程叫’归‘，自顶向下。</p>
<p> 所谓递归，就是有去有回。</p>
<ul>
<li>特点</li>
</ul>
<p>1） 基线条件： 函数不再调用自己</p>
<p>2） 递归条件：函数调用自己</p>
<img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2cys1eccbj20s808igma.jpg" alt="image-20220518231520416" style="zoom:50%;" />

<p>递归要警惕堆栈溢出和重复计算(👇)</p>
<p><strong>递归与迭代</strong></p>
<p>注意递归的缺点</p>
<blockquote>
<p>如果使用循环，程序的性能可能更高；如果使用递归，程序可能更容易理解。如何选择要看什么对你来说更重要。”<br> 参见<a target="_blank" rel="noopener" href="http://stackoverflow.com/a/72694/139117">http://stackoverflow.com/a/72694/139117</a></p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/bobbypollo/article/details/79891556">理解递归的本质：递归与栈</a></p>
<p>采用数据栈</p>
<blockquote>
<p>我们知道递归函数存在的最大问题是，当递归次数足够大时，会导致函数栈溢出而死机，函数栈的大小一般是一个固定值，对于linux来说一般默认是8M。</p>
<p> 因此，编程老司机会教导我们，不得用递归函数！但递归函数的代码实现实在是简洁啊，不让用？臣妾做不到啊！</p>
<p> 那么问题来了，所有递归函数都能非递归化吗？答案是肯定的。</p>
<p> 本质上讲，对于同一个问题，如果必然要用广义递归的方案来处理，那么狭义递归函数只不过是其中的一种实现方式，如果放弃狭义递归函数的话，我们不得不借助一个额外的数据结构：栈。</p>
<p> 如此看来，无论如何都要用到栈，只不过要么让编译器来维护一个栈（函数栈），要么让程序狗来维护一个栈（数据栈）。</p>
</blockquote>
<p> 这两个栈的区别如下：</p>
<table>
<thead>
<tr>
<th></th>
<th align="left">函数栈</th>
<th align="left">数据栈</th>
</tr>
</thead>
<tbody><tr>
<td>位置</td>
<td align="left">进程的stack区</td>
<td align="left">进程的heap区</td>
</tr>
<tr>
<td>大小限制</td>
<td align="left">小（8M？）</td>
<td align="left">能分配到很大</td>
</tr>
<tr>
<td>每个栈“元素”所需空间</td>
<td align="left">比较大，因为要存储函数上下文</td>
<td align="left">可以设计到很小，比如只存储一个指针</td>
</tr>
<tr>
<td>栈开销</td>
<td align="left">大</td>
<td align="left">可以做的很小</td>
</tr>
<tr>
<td>代码简易程度/可维护性</td>
<td align="left">简洁易读</td>
<td align="left">相对更复杂</td>
</tr>
</tbody></table>
<p><strong>应用举例</strong></p>
<ul>
<li>汉诺塔问题</li>
</ul>
<img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2e2iq39s2j20y00e2jsj.jpg" alt="image-20220519221020085" style="zoom:33%;" />

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hanoi</span>(<span class="params">n, a,b,c</span>):</span></span><br><span class="line">    <span class="keyword">if</span> n&lt;=<span class="number">1</span>: </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;a&#125;</span>-&gt;<span class="subst">&#123;c&#125;</span>&#x27;</span>)  <span class="comment"># 基线条件，只有一个盘子</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        hanoi(n-<span class="number">1</span>,a,c,b)  <span class="comment"># a--&gt;b, 假设 n-1个盘子从a移动到b</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;a&#125;</span>-&gt;<span class="subst">&#123;c&#125;</span>&#x27;</span>)</span><br><span class="line">        hanoi(n-<span class="number">1</span>,b,a,c)  <span class="comment"># b--&gt;c</span></span><br><span class="line">        </span><br><span class="line">hanoi(<span class="number">5</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>最大公约数</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fraction</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,a,b,</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;a:分子， b:分母&quot;&quot;&quot;</span></span><br><span class="line">        self.a = a</span><br><span class="line">        self.b = b</span><br><span class="line">        x = self.gcd1(self.a, self.b)</span><br><span class="line">        self.a = self.a/x</span><br><span class="line">        self.b = self.b/x</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gcd1</span>(<span class="params">self, a, b</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        最大公约数，辗转相除法</span></span><br><span class="line"><span class="string">        :param a:</span></span><br><span class="line"><span class="string">        :param b:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> b == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> a</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.gcd1(b, a % b)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gcd</span>(<span class="params">self, a, b</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;最大公约数&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">while</span> b &gt; <span class="number">0</span>:</span><br><span class="line">            r = a % b</span><br><span class="line">            a = b</span><br><span class="line">            b = r</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">zgs</span>(<span class="params">self,a,b</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;最小公倍数&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> a*b/self.gcd1(a,b)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&#x27;<span class="subst">&#123;self.a:<span class="number">.0</span>f&#125;</span>/<span class="subst">&#123;self.b:<span class="number">.0</span>f&#125;</span>&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__add__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">        <span class="comment"># a/b+c/d</span></span><br><span class="line">        a= self.a</span><br><span class="line">        b= self.b</span><br><span class="line">        c= other.a</span><br><span class="line">        d = other.b</span><br><span class="line">        denominator =self.zgs(b,d)  <span class="comment"># 通分后分母</span></span><br><span class="line">        numerator = a*(denominator/b)+c*(denominator/d)  <span class="comment"># 分子</span></span><br><span class="line">        <span class="keyword">return</span> Fraction(numerator, denominator)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># f = Fraction(30,15)</span></span><br><span class="line"><span class="comment"># print(f)</span></span><br><span class="line">a =Fraction(<span class="number">1</span>,<span class="number">3</span>)</span><br><span class="line">b =Fraction(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(a+b)</span><br><span class="line"><span class="number">5</span>/<span class="number">6</span></span><br></pre></td></tr></table></figure>



<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2pg2x0wtej215a0oy44w.jpg" alt="image-20210516120055333"></p>
<p>按照复杂度分为：</p>
<table>
<thead>
<tr>
<th>排序算法</th>
<th>时间复杂度</th>
<th>是否基于比较</th>
</tr>
</thead>
<tbody><tr>
<td>冒泡、插入、选择</td>
<td>O(n^2)</td>
<td>✅</td>
</tr>
<tr>
<td>快排，归并</td>
<td>O(nlog(n))</td>
<td>✅</td>
</tr>
<tr>
<td>桶，计数，基数</td>
<td>O(n）</td>
<td>❌</td>
</tr>
</tbody></table>
<ul>
<li>原地排序</li>
</ul>
<p>指空间复杂度O(1)的排序算法</p>
<ul>
<li>排序稳定性</li>
</ul>
<p>指的是待排序序列中有值相等的元素，经过排序后，<strong>相等元素之间原有的先后顺序不变</strong>，则称<strong>稳定</strong>的排序算法，否则就叫作不稳定的排序算法</p>
<img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpev7b92qvj31ct0u07wi.jpg" alt="image-20210410191801301" style="zoom: 33%;" />

<p><strong>冒泡排序</strong></p>
<p>思想：通过比较相邻元素，交换位置，每一轮将最值元素通过’冒泡‘浮到边界位置</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1guyfat4mp4j60w20eot9q02.jpg" alt="image-20210930100111313"></p>
<p>代码实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span>(<span class="params">li</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(li)-<span class="number">1</span>):  <span class="comment"># 趟数，第i趟</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(li)-i-<span class="number">1</span>):  <span class="comment"># 箭头</span></span><br><span class="line">            <span class="keyword">if</span> li[j]&gt;li[j+<span class="number">1</span>]:</span><br><span class="line">                li[j], li[j+<span class="number">1</span>] = li[j+<span class="number">1</span>], li[j]</span><br><span class="line">        <span class="built_in">print</span>(li)</span><br></pre></td></tr></table></figure>

<p>改进：</p>
<p>如果某趟没有发生交换，说明已经排好序了，提前终止</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span>(<span class="params">li</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(li)-<span class="number">1</span>):</span><br><span class="line">        exchange = <span class="literal">False</span>  <span class="comment"># 添加标志位</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(li)-i-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> li[j]&gt;li[j+<span class="number">1</span>]:</span><br><span class="line">                li[j], li[j+<span class="number">1</span>] = li[j+<span class="number">1</span>], li[j]</span><br><span class="line">                exchange=<span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> exchange:</span><br><span class="line">            <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<ul>
<li>复杂度分析：</li>
</ul>
<p>属于原地排序；</p>
<p>由于元素相等时候不进行交换，故为<strong>稳定的；</strong></p>
<p>复杂度O(n^2）</p>
<p><strong>插入排序</strong></p>
<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gynntfko8kj31960jytan.jpg" alt="image-20220123155600173" style="zoom:33%;" />

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span>(<span class="params">li</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(li)):  <span class="comment"># 摸到的牌下标</span></span><br><span class="line">        j = i-<span class="number">1</span>  <span class="comment"># 手里牌</span></span><br><span class="line">        tmp = li[i]  <span class="comment"># 摸到的牌</span></span><br><span class="line">        <span class="keyword">while</span> li[j]&gt;tmp <span class="keyword">and</span> j&gt;=<span class="number">0</span>:</span><br><span class="line">            li[j+<span class="number">1</span>] = li[j]</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        li[j+<span class="number">1</span>] = tmp  <span class="comment"># 注意这里写到 j+1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>复杂度分析：</li>
</ul>
<p>属于原地排序；</p>
<p>由于元素相等时候不进行移动，故为<strong>稳定的；</strong></p>
<p>2个for循环，复杂度O(n^2）</p>
<p><strong>希尔排序</strong></p>
<p>希尔排序是插入排序的变形，思路是不断分组——插入排序，直到gap 变为1</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort_gap</span>(<span class="params">li, gap</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;只需要将插入排序的 1--&gt;gap&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(gap,<span class="built_in">len</span>(li)):  <span class="comment"># 摸到的牌下标</span></span><br><span class="line">        j = i-gap  <span class="comment"># 手里牌</span></span><br><span class="line">        tmp = li[i]  <span class="comment"># 摸到的牌</span></span><br><span class="line">        <span class="keyword">while</span> li[j]&gt;tmp <span class="keyword">and</span> j&gt;=<span class="number">0</span>:</span><br><span class="line">            li[j+gap] = li[j]</span><br><span class="line">            j -= gap</span><br><span class="line">        li[j+gap] = tmp</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shell_sort</span>(<span class="params">li</span>):</span></span><br><span class="line">    gap = <span class="built_in">len</span>(li)//<span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> gap&gt;=<span class="number">1</span>:</span><br><span class="line">        insert_sort_gap(li, gap)</span><br><span class="line">        gap //= <span class="number">2</span></span><br></pre></td></tr></table></figure>

<ul>
<li>复杂度</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Shellsort">https://en.wikipedia.org/wiki/Shellsort</a></p>
<p>和选取的 gap 有关</p>
<p><strong>选择排序</strong></p>
<p>每轮找到最值元素，然后交换</p>
<p>不稳定</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_sort</span>(<span class="params">li</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(li)-<span class="number">1</span>):  <span class="comment"># 趟数</span></span><br><span class="line">        min_loc = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>,<span class="built_in">len</span>(li)):</span><br><span class="line">            <span class="keyword">if</span> li[j]&lt;li[min_loc]:</span><br><span class="line">                min_loc =j</span><br><span class="line">        li[min_loc], li[i] = li[i], li[min_loc]  <span class="comment"># 交换</span></span><br></pre></td></tr></table></figure>



<p><strong>归并排序</strong></p>
<p>发明人是冯诺依曼，时间 1945年</p>
<p>归并和快排背后 使用的都是分治思想，而分治算法一般都是用递归实现的。</p>
<p>分治是一种解决问题的处理思想， 递归是一种编程技巧，这二者并不冲突。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpfusgjj5vj311t0u0npe.jpg" alt="image-20210411154915840"></p>
<p>代码：【注意合并过程，代码有打印】</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">递归实现：</span></span><br><span class="line"><span class="string">递推公式： merge_sort(p,r) = merge(merge_sort(p,q),merge_sort(q+1, r))</span></span><br><span class="line"><span class="string">终止条件： p&gt;=r</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">li = [<span class="number">11</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span>(<span class="params">li, p, r</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">if</span> p&gt;=r: <span class="keyword">return</span></span><br><span class="line">    mid = (p+r)//<span class="number">2</span>   <span class="comment"># 中间位置</span></span><br><span class="line">    merge_sort(li, p, mid)</span><br><span class="line">    merge_sort(li, mid+<span class="number">1</span>, r)</span><br><span class="line">    merge(li, p, mid, r)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">li, p, mid, r</span>):</span></span><br><span class="line">    tmp = []  <span class="comment"># 申请临时数组，存放merge 结果</span></span><br><span class="line">    i= p</span><br><span class="line">    j = mid+<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i&lt;=mid <span class="keyword">and</span> j&lt;=r:</span><br><span class="line">        <span class="keyword">if</span> li[i]&lt;=li[j]:  <span class="comment"># ‘=’保证是稳定的</span></span><br><span class="line">            tmp.append(li[i])</span><br><span class="line">            i +=<span class="number">1</span> </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            tmp.append(li[j])</span><br><span class="line">            j +=<span class="number">1</span></span><br><span class="line">    <span class="comment"># while 执行完肯定有一部分没数了</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> i&lt;=mid: <span class="comment"># 说明这部分还没取完</span></span><br><span class="line">        tmp.append(li[i])</span><br><span class="line">        i +=<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> j&lt;=r: <span class="comment"># 说明这部分还没取完</span></span><br><span class="line">        tmp.append(li[j])</span><br><span class="line">        j +=<span class="number">1</span></span><br><span class="line">    li[p:r+<span class="number">1</span>] = tmp</span><br><span class="line">    <span class="built_in">print</span>(tmp)</span><br><span class="line">    </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;原始序列<span class="subst">&#123;li&#125;</span>&#x27;</span>)</span><br><span class="line">merge_sort(li, <span class="number">0</span>, <span class="built_in">len</span>(li)-<span class="number">1</span>)</span><br><span class="line">li</span><br><span class="line">----</span><br><span class="line">原始序列[<span class="number">11</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>]</span><br><span class="line">[<span class="number">8</span>, <span class="number">11</span>]</span><br><span class="line">[<span class="number">3</span>, <span class="number">9</span>]</span><br><span class="line">[<span class="number">3</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">11</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">7</span>]</span><br><span class="line">[<span class="number">2</span>, <span class="number">5</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">7</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">11</span>]   <span class="comment"># 注意合并过程与⤴️图一致</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>复杂度分析</li>
</ul>
<p>空间复杂度O(n), 不属于原地排序；</p>
<p>稳定的， 可由<code>if li[i]&lt;=li[j]: tmp.append(li[i])</code> 保证</p>
<p>复杂度O(nlg(n)）</p>
<p><strong>快排</strong></p>
<p>快排，也是采用分治思想</p>
<p>具体使用时候，随机选取基准值，来实现 O(n lgn）复杂度</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span>(<span class="params">li</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    快速排序，清晰简单版本</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(li)&lt;<span class="number">2</span>: <span class="keyword">return</span> li    <span class="comment"># &lt;------基线条件, 有序</span></span><br><span class="line">    pivot = li[<span class="number">0</span>]  <span class="comment"># 基准值   &lt;------递归条件</span></span><br><span class="line">    less = [i <span class="keyword">for</span> i <span class="keyword">in</span> li[<span class="number">1</span>:] <span class="keyword">if</span> i&lt;=pivot]</span><br><span class="line">    greater = [i <span class="keyword">for</span> i <span class="keyword">in</span> li[<span class="number">1</span>:] <span class="keyword">if</span> i&gt;pivot]</span><br><span class="line">    <span class="keyword">return</span> quick_sort(less)+[pivot]+quick_sort(greater)  <span class="comment"># quick_sort(greater) 将保证得到有序的</span></span><br><span class="line">li = [<span class="number">10</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">quick_sort(li)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>代码版本2：</li>
</ul>
<p>原地排序</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 递推公式：</span></span><br><span class="line"><span class="comment"># quick_sort(p…r) = quick_sort(p…q-1) + quick_sort(q+1… r)</span></span><br><span class="line"><span class="comment"># 终止条件：</span></span><br><span class="line"><span class="comment"># p &gt;= r</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span>(<span class="params">li, p, r</span>):</span></span><br><span class="line">    <span class="keyword">if</span> p&lt;r:</span><br><span class="line">        q = partition(li, p, r)   <span class="comment"># 获分区点</span></span><br><span class="line">        quick_sort(li, p, q-<span class="number">1</span>)</span><br><span class="line">        quick_sort(li, q+<span class="number">1</span>, r)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span>(<span class="params">li, p, r</span>):</span></span><br><span class="line">    pivot = li[p]  <span class="comment"># 选队首为比较点</span></span><br><span class="line">    <span class="keyword">while</span> p&lt;r:</span><br><span class="line">        <span class="keyword">while</span> li[r]&gt;=pivot <span class="keyword">and</span> p&lt;r:  <span class="comment"># 从右边找，比 pivot小的</span></span><br><span class="line">            r -= <span class="number">1</span></span><br><span class="line">        li[p] = li[r]  <span class="comment"># 写空位</span></span><br><span class="line">        <span class="keyword">while</span> li[p] &lt;=pivot <span class="keyword">and</span> p&lt;r:</span><br><span class="line">            p += <span class="number">1</span></span><br><span class="line">        li[r] = li[p]</span><br><span class="line">    li[p] = pivot  <span class="comment"># p/r相遇,归位</span></span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">li = [<span class="number">13</span>,<span class="number">11</span>,<span class="number">25</span>,<span class="number">7</span>,<span class="number">19</span>,<span class="number">3</span>]      </span><br><span class="line">quick_sort(li, <span class="number">0</span>, <span class="built_in">len</span>(li)-<span class="number">1</span>)</span><br><span class="line">li</span><br></pre></td></tr></table></figure>

<p>关于<code>def partition(li, p, r)   # 获分区点</code>函数的解释：</p>
<p>黑框内为待替换位置，也是最终的返回位置，随着递推，p、r越来越接近。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpg0782djyj314w0rekef.jpg" alt="image-20210411185628255"></p>
<p>快排时间复杂度：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">T(1) = C；   n=1时，只需要常量级的执行时间，所以表示为C。</span><br><span class="line">T(n) = 2*T(n/2) + n； n&gt;1</span><br></pre></td></tr></table></figure>

<p>T(n) = O(nlogn)</p>
<ul>
<li>快排与归并 的比较</li>
</ul>
<p>尽管都是 O(nlgn)，但是快排比归并快，体现在常数时间上，而常量在 大O表现不出来</p>
<p><del>可以发现，归并排序的处理过程是<strong>由下到上</strong>的，先处理子问题，然后再合并。而快排正好相反，它的处 理过程是<strong>由上到下</strong>的，先分区，然后再处理子问题。归并排序虽然是稳定的、时间复杂度为 O(nlogn) 的 排序算法，但是它是非原地排序算法。我们前面讲过，归并之所以是非原地排序算法，主要原因是合并 函数无法在原地执行。快速排序通过设计巧妙的原地分区函数，可以实现原地排序，解决了归并排序占 用太多内存的问题。</del></p>
<blockquote>
<p>问题：O(n) 时间复杂度内求无序数组中的第 K 大元素。</p>
<p>利用快排，经过一次快排，得到A[0,1,…,p-1], A[p], A[p+1,…,n-1]</p>
<p> 然后根据K与p大小关系，进行递归，每次减半</p>
<p>复杂度：n+n/2+…+1=O(n)</p>
<p>代码：参见力扣：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">https://leetcode-cn.com/problems/kth-largest-element-in-an-array/</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="comment">#  [3,2,1,5,6,4] 和 k = 3</span></span><br><span class="line">        <span class="comment"># &quot;采用快排思想&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">li, p, r</span>):</span></span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">            q = partition(li, p,r)</span><br><span class="line">            <span class="keyword">if</span> q+<span class="number">1</span>==k:</span><br><span class="line">                <span class="keyword">return</span> li[q]</span><br><span class="line">            <span class="keyword">elif</span> q+<span class="number">1</span>&gt;k:</span><br><span class="line">                <span class="keyword">return</span> helper(li, p, q-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> helper(li, q+<span class="number">1</span>, r)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">partition</span>(<span class="params">li, p, r</span>):</span></span><br><span class="line">            pivot = li[p]  <span class="comment"># 选队首为比较点</span></span><br><span class="line">            <span class="keyword">while</span> p&lt;r:</span><br><span class="line">                <span class="keyword">while</span> li[r]&lt;=pivot <span class="keyword">and</span> p&lt;r:</span><br><span class="line">                    r -= <span class="number">1</span></span><br><span class="line">                li[p] = li[r]</span><br><span class="line">                <span class="keyword">while</span> li[p] &gt;=pivot <span class="keyword">and</span> p&lt;r:</span><br><span class="line">                    p += <span class="number">1</span></span><br><span class="line">                li[r] = li[p]</span><br><span class="line">            li[p] = pivot  <span class="comment"># p/r相遇,得到</span></span><br><span class="line">            <span class="keyword">return</span> p</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> helper(nums, <span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

</blockquote>
<p><strong>复杂度O(n)排序</strong></p>
<p>它们均不涉及元素之间的比较操作</p>
<ul>
<li>计数排序</li>
</ul>
<p>计数排序其实是桶排序的一种特殊情况</p>
<p>时间复杂度：O(n+K)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">counting_sort</span>(<span class="params">li</span>):</span></span><br><span class="line">    max_num = <span class="built_in">max</span>(li)</span><br><span class="line">    count_li = [<span class="number">0</span>] * (max_num + <span class="number">1</span>)  <span class="comment"># 计数列表</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> li:</span><br><span class="line">        count_li[num] += <span class="number">1</span></span><br><span class="line">    li.clear()</span><br><span class="line">    <span class="keyword">for</span> i,v <span class="keyword">in</span> <span class="built_in">enumerate</span>(count_li):</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(v):</span><br><span class="line">            li.append(i)</span><br></pre></td></tr></table></figure>

<p>缺点：</p>
<p>1）当数列最大、最小值差距过大时</p>
<p>意味着，空间的极大浪费</p>
<p>2）小数</p>
<ul>
<li>桶排序</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gv089dd00cj60o209k0tf02.jpg" alt="image-20211001232844068"></p>
<ul>
<li>基数排序</li>
</ul>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1gv08qbo2ndg60s40fywic02.gif" alt="img" style="zoom: 67%;" />

<ul>
<li>比较</li>
</ul>
<p>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p>
<p><strong>基数排序：</strong>根据键值的每位数字来分配桶；</p>
<p><strong>计数排序：</strong>每个桶只存储单一键值；</p>
<p><strong>桶排序：</strong>每个桶存储一定范围的数值；</p>
<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><img src="https://tva1.sinaimg.cn/large/008i3skNgy1guxyd2a1mmj60xg0c4dgf02.jpg" alt="image-20210930001510344" style="zoom:33%;" />

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span>(<span class="params">li, val</span>):</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = <span class="built_in">len</span>(li)-<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:  <span class="comment"># 候选区有值</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">        mid = (left+right)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> li[mid]==val:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">elif</span> li[mid]&gt;val:  <span class="comment"># 待查找的值在 mid 左侧</span></span><br><span class="line">            right = mid-<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>: <span class="comment"># 待查找的值在 mid 右侧</span></span><br><span class="line">            left = mid+<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">----------</span><br><span class="line">li = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>))</span><br><span class="line"><span class="built_in">print</span>(binary_search(li, <span class="number">3</span>))</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(lgn)</p>
<p>递归和非递归代码参见：<a target="_blank" rel="noopener" href="https://github.com/flitdu/consult/blob/main/jupyter/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.ipynb"><strong>二分查找.ipynb</strong> </a></p>
<ul>
<li>适用场景</li>
</ul>
<p>二分查找只能用<strong>在插入、删除操作不频繁，一次排序多次查找的场景中</strong>。针对动态变化的数据集合，二分查找将不再适用。那针对动态数据集合，如何在其中快速查找某个数据呢?别急，等到二叉树 那一节我会详细讲。</p>
<ul>
<li>二分查找变形</li>
</ul>
<ol>
<li>变体一:查找第一个值等于给定值的元素</li>
<li>变体二:查找最后一个值等于给定值的元素</li>
<li>变体三:查找第一个 ≥ 给定值的元素</li>
<li>变体四:查找最后一个 ≤ 给定值的元素</li>
</ol>
<p>参见：<a target="_blank" rel="noopener" href="https://github.com/flitdu/consult/blob/main/jupyter/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.ipynb"><strong>二分查找.ipynb</strong> </a></p>
<h2 id="字符串匹配"><a href="#字符串匹配" class="headerlink" title="字符串匹配"></a>字符串匹配</h2><p><strong>BF算法</strong></p>
<p>Brute Force, 也即暴力匹配算法，复杂度为O（mn），其中m为模式串长度，n 为主串长度，n&gt;m</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gpwd1fyt1sj30vk0eqwzb.jpg" alt="image-20210425222923858" style="zoom:50%;" />

<p><strong>RK 算法</strong></p>
<p>RK 算法的全称叫 <a target="_blank" rel="noopener" href="https://brilliant.org/wiki/rabin-karp-algorithm/">Rabin-Karp 算法</a>，是由它的两位发明者 Rabin 和 Karp 的名字来命名的。</p>
<p>是BF算法的升级版</p>
<p>RK 算法的思路是这样的：我们通过哈希算法对主串中的 n-m+1 个子串分别求哈希值，然后逐个与模式串的哈希值比较大小。如果某个子串的哈希值与模式串相等，那就说明对应的子串和模式串匹配了(这 里先不考虑哈希冲突的问题，后面我们会讲到)。因为哈希值是一个数字，数字之间比较是否相等是非 常快速的，所以模式串和子串比较的效率就提高了。</p>
<p>整体复杂度：O(n)</p>
<h2 id="四种算法思想"><a href="#四种算法思想" class="headerlink" title="四种算法思想"></a>四种算法思想</h2><p>贪心 算法、分治算法、回溯算法、动态规划，更加确切地说，它们应该是算法思想，并不是具体的算法，常用来指导我们设计具体的算法和编码等。</p>
<p><strong>回溯</strong></p>
<p>应用领域：</p>
<ul>
<li><p>深度优先搜索</p>
</li>
<li><p>正则表达式匹配</p>
</li>
<li><p>编译原理中的语法分析</p>
</li>
<li><p>数独</p>
</li>
<li><p>0-1背包</p>
</li>
<li><p>图的着色</p>
</li>
<li><p>旅行商问题</p>
</li>
<li><p>全排列</p>
</li>
<li><p>N皇后问题</p>
</li>
</ul>
<p>参考：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/av374837176/">合格程序员必会，回溯法解八皇后，看了这个动画，你就全明白了，C++实现</a></p>
<p>笼统地讲，回溯算法很多时候都应用在“搜索”这类问题上。不过这里说的搜索，并不是􏰃义的指我们前 面讲过的图的搜索算法，而是在一组可能的解中，搜索满足期望的解。</p>
<p>回溯有点类似枚举，非常适合用递归实现。某次尝试出现错误后回到之前的时刻，重新尝试，类似于《蝴蝶效应》</p>
<p><strong>贪心算法</strong></p>
<p>贪心算法有很多经典的应用，比如霍夫曼编码(Huffman Coding)、Prim 和 Kruskal 最小生成树算法、还有 Dijkstra 单源最短路径算法</p>
<ul>
<li>找零问题</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">t = [<span class="number">100</span>, <span class="number">50</span>, <span class="number">20</span>, <span class="number">5</span>, ]  <span class="comment"># 可以找的零钱面值</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change</span>(<span class="params">t, n</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;贪心思路&quot;&quot;&quot;</span></span><br><span class="line">    m = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(t))]  <span class="comment"># 保存对应钱数的张数</span></span><br><span class="line">    <span class="keyword">for</span> i,money <span class="keyword">in</span> <span class="built_in">enumerate</span>(t):</span><br><span class="line">        m[i] = n//money</span><br><span class="line">        n %= money</span><br><span class="line">    <span class="keyword">return</span> m,n</span><br><span class="line"><span class="built_in">print</span>(change(t, <span class="number">136</span>))</span><br><span class="line">([<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>], <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>活动安排</li>
</ul>
<p>使得举办的活动数最多，i 为活动序号，s活动开始时间，f结束时间【注意这里结束时间 f 要有序】</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gv3ey3lsi6j617e05st9602.jpg" alt="image-20211004173646149"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">activities = [(<span class="number">1</span>,<span class="number">4</span>), (<span class="number">3</span>,<span class="number">5</span>), (<span class="number">0</span>,<span class="number">6</span>),</span><br><span class="line">              (<span class="number">5</span>,<span class="number">7</span>), (<span class="number">3</span>,<span class="number">9</span>), (<span class="number">5</span>,<span class="number">9</span>),</span><br><span class="line">              (<span class="number">6</span>,<span class="number">10</span>), (<span class="number">8</span>,<span class="number">11</span>), (<span class="number">8</span>,<span class="number">12</span>),</span><br><span class="line">              (<span class="number">2</span>,<span class="number">14</span>), (<span class="number">12</span>,<span class="number">16</span>)]  <span class="comment"># 活动（开始时间，结束时间）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">activity_selection</span>(<span class="params">a</span>):</span></span><br><span class="line">  <span class="string">&quot;&quot;&quot;贪心思路：选择活动最先结束的&quot;&quot;&quot;</span></span><br><span class="line">    res = [a[<span class="number">0</span>]]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(a)):</span><br><span class="line">        <span class="keyword">if</span> a[i][<span class="number">0</span>]&gt;=res[-<span class="number">1</span>][<span class="number">1</span>]:<span class="comment"># 当前活动的开始时间 &gt; 最后一个入选活动的结束时间</span></span><br><span class="line">            <span class="comment"># 不冲突</span></span><br><span class="line">            res.append(a[i])</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"><span class="built_in">print</span>(activity_selection(activities))</span><br></pre></td></tr></table></figure>

<p>[(1, 4), (5, 7), (8, 11), (12, 16)]</p>
<ul>
<li>霍夫曼编码</li>
</ul>
<p>贪心思想：出现频率多的字符，用稍微短一些的字符编码；出现频率少的字符，用长一些的编码。霍夫曼编码要求各个字符的编码之间，不会出现某个编码是 另一个编码前缀的情况。</p>
<p>具体实现：</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqck0ezmfoj316s0u07wj.jpg" alt="image-20210509223800911"></p>
<p>所以，最终的编码为</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqck1wrsyqj30zk0jqx0x.jpg" alt="image-20210509224139300"></p>
<p><strong>分治，divide and conquer</strong></p>
<p><del>分治算法核心思想：分而治之 ，也就是将原问题划分成 n 个 规模较小，并且结构与原问题相似的子问题，<strong>递归</strong>地解决这些子问题，然后再合并其结果，就得到原问 题的解。</del></p>
<p>使用 D&amp;C 解决问题的过程包括两个步骤（递归）：</p>
<p>1） 找到基线条件 ，尽可能简单</p>
<p>2）不断将问题分解（缩小规模），直到符合基线条件</p>
<blockquote>
<p><strong>分治算法子问题之间没有相关性，这一点是跟动态规划的明显区别</strong></p>
</blockquote>
<ul>
<li>股票最佳交易</li>
</ul>
<p>e.g. </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[7,1,5,3,6,4]</span><br><span class="line">输出：5   </span><br><span class="line">在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        采用分治法求解</span></span><br><span class="line"><span class="string">        分为3种情况：</span></span><br><span class="line"><span class="string">        1） 前半段买入与卖出</span></span><br><span class="line"><span class="string">        2） 后半段买入与卖出</span></span><br><span class="line"><span class="string">        3） 前半段买入，后半段卖出</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">best</span>(<span class="params">prices</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(prices)==<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            mid = <span class="built_in">len</span>(prices)//<span class="number">2</span></span><br><span class="line">            former = prices[:mid]  <span class="comment"># 前半段股票</span></span><br><span class="line">            latter = prices[mid:]  <span class="comment"># 后半段股票</span></span><br><span class="line">            case3 = <span class="built_in">max</span>(latter) - <span class="built_in">min</span>(former)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(best(former), best(latter), case3)</span><br><span class="line">        <span class="keyword">return</span> best(prices)</span><br></pre></td></tr></table></figure>





<p><strong>动态规划</strong></p>
<p>动态规划从小问题着手，逐步解决大问题，同时小问题将帮助解决大问题</p>
<p>解决多阶段决策问题常用的最优化理论，1957年提出</p>
<ul>
<li><del>一个模型三个特征</del></li>
</ul>
<p><del>“<strong>一个模型</strong>”， 它指的是动态规划适合解决的问题的模型，即 “<strong>多阶段决策最优解模型</strong>”。</del></p>
<p><del>我们一般是用动态规划来解决最优问题。而解决问题的过程，需要经历多个决策阶段。每个决策阶段都 对应着一组状态。然后我们寻找一组决策序列，经过这组决策序列，能够产生最终期望求解的最优值。</del></p>
<p><del>什么是“<strong>三个特征</strong>”?它们分别是<strong>最优子结构</strong>、<strong>无后效性</strong>和<strong>重复子问题</strong>。</del></p>
<ul>
<li>e.g. 最长公共子序列</li>
</ul>
<p>比如，‘ABCBDAB’ 与 ‘BDCABA’ 的最长公共子序列：‘BCBA’</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gv46j4vhdtj61180e6gnf02.jpg" alt="image-20211005093111583"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lcs_length</span>(<span class="params">x,y</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;最长公共子序列&quot;&quot;&quot;</span></span><br><span class="line">    m = <span class="built_in">len</span>(x)</span><br><span class="line">    n = <span class="built_in">len</span>(y)</span><br><span class="line">    c = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m+<span class="number">1</span>)]  <span class="comment"># (m+1)行，（n+1）列</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,m+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> x[i-<span class="number">1</span>]==y[j-<span class="number">1</span>]:  <span class="comment"># 最后数值匹配，同时删除一个</span></span><br><span class="line">                c[i][j] = c[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                c[i][j] = <span class="built_in">max</span>(c[i-<span class="number">1</span>][j], c[i][j-<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> c:   <span class="comment"># 打印矩阵</span></span><br><span class="line">        <span class="built_in">print</span>(k)</span><br><span class="line">    <span class="keyword">return</span> c[m][n]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(lcs_length(<span class="string">&#x27;ABCBDAB&#x27;</span>, <span class="string">&#x27;BDCABA&#x27;</span>))</span><br><span class="line"></span><br><span class="line">[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>]</span><br><span class="line"><span class="number">4</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>方案输出：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lcs</span>(<span class="params">x,y</span>):</span></span><br><span class="line">    m = <span class="built_in">len</span>(x)</span><br><span class="line">    n =<span class="built_in">len</span>(y)</span><br><span class="line">    c = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>)]  <span class="comment"># (m+1)行，（n+1）列</span></span><br><span class="line">    arrow = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>)]  <span class="comment"># 记录箭头，1：左上方，2：上方，3：左方</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,m+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> x[i-<span class="number">1</span>]==y[j-<span class="number">1</span>]:  <span class="comment"># 最后数值匹配，同时删除一个</span></span><br><span class="line">                c[i][j] = c[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span></span><br><span class="line">                arrow[i][j] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># c[i][j] = max(c[i-1][j], c[i][j-1])</span></span><br><span class="line">                <span class="keyword">if</span> c[i-<span class="number">1</span>][j]&gt;c[i][j-<span class="number">1</span>]:  <span class="comment"># 来自上</span></span><br><span class="line">                    c[i][j] = c[i-<span class="number">1</span>][j]</span><br><span class="line">                    arrow[i][j] = <span class="number">2</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    c[i][j] = c[i][j-<span class="number">1</span>]</span><br><span class="line">                    arrow[i][j] = <span class="number">3</span></span><br><span class="line">    <span class="keyword">return</span> c[m][n], arrow</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lcs_trace_back</span>(<span class="params">x,y</span>):</span></span><br><span class="line">    c,arrow = lcs(x,y)</span><br><span class="line">    i = <span class="built_in">len</span>(x)</span><br><span class="line">    j =<span class="built_in">len</span>(y)</span><br><span class="line">    res =[]</span><br><span class="line">    <span class="keyword">while</span> i&gt;<span class="number">0</span> <span class="keyword">and</span> j&gt;<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> arrow[i][j]==<span class="number">1</span>:</span><br><span class="line">            res.append(x[i-<span class="number">1</span>])</span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> arrow[i][j]==<span class="number">2</span>:  <span class="comment"># 来自上方</span></span><br><span class="line">            i -=<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            j -=<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">reversed</span>(res)), c</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(lcs_trace_back(<span class="string">&#x27;ABCBDAB&#x27;</span>, <span class="string">&#x27;BDCABA&#x27;</span>))</span><br><span class="line">(<span class="string">&#x27;BDAB&#x27;</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>e.g. 钢条切割</li>
</ul>
<p>钢条长度与价格关系：</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gv3myqgi5dj60w404c0t202.jpg" alt="image-20211004221412330"></p>
<p>下面代码从递归一步步进化到DP，注意体会：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">p = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">17</span>,<span class="number">17</span>,<span class="number">20</span>,<span class="number">24</span>,<span class="number">30</span>,<span class="number">32</span>,<span class="number">34</span>,<span class="number">35</span>,<span class="number">37</span>,<span class="number">40</span>,<span class="number">42</span>,<span class="number">45</span>,<span class="number">50</span>,<span class="number">51</span>,<span class="number">53</span>,<span class="number">54</span>,<span class="number">55</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;p长度：<span class="subst">&#123;<span class="built_in">len</span>(p)&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cut_rod_recursion</span>(<span class="params">p, n</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    递推公式： r_n = max(p_n, r1+r_&#123;n-1&#125;, r2+r_&#123;n-2&#125;, ..., r_&#123;n-1&#125;+r1)</span></span><br><span class="line"><span class="string">            r_n： 表示 长度n 的钢材的最优价格</span></span><br><span class="line"><span class="string">    :param p: 完整长度n 钢材对应的价格（不切割）</span></span><br><span class="line"><span class="string">    :param n:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> n==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        res = p[n]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">            res = <span class="built_in">max</span>(res, cut_rod_recursion(p, n-i)+cut_rod_recursion(p,i))</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="meta">@cal_time</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_cut_rod_recursion1</span>(<span class="params">p,n</span>):</span></span><br><span class="line">    <span class="keyword">return</span> cut_rod_recursion1(p,n)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cut_rod_recursion1</span>(<span class="params">p,n</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;递归改进递推公式</span></span><br><span class="line"><span class="string">    只切一侧，仍能够得到全部情况</span></span><br><span class="line"><span class="string">    递推公式：</span></span><br><span class="line"><span class="string">            r_n = max(p_n, r1+r_&#123;n-1&#125;, r2+r_&#123;n-2&#125;, ..., r_&#123;n-1&#125;+r1)</span></span><br><span class="line"><span class="string">    替换为：---&gt;</span></span><br><span class="line"><span class="string">            r_n = max(p_i+r_&#123;n-i&#125;), for i in [1,n]</span></span><br><span class="line"><span class="string">    复杂度：O(2^N)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> n==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        res= <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">            res = <span class="built_in">max</span>(res, p[i]+cut_rod_recursion1(p, n-i))</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@cal_time</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cut_rod_dp</span>(<span class="params">p,n</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;动态规划，自底向上</span></span><br><span class="line"><span class="string">    r_n = max(p_i+r_&#123;n-i&#125;), for i in [1,n]</span></span><br><span class="line"><span class="string">    复杂度：O(N*N)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    r = [<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">        res= <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, i+<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># i 对应 递推公式的 n</span></span><br><span class="line">            res = <span class="built_in">max</span>(res, p[j]+r[i-j])</span><br><span class="line">        r.append(res)</span><br><span class="line">    <span class="keyword">return</span> r[n]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(test_cut_rod_recursion1(p,<span class="number">20</span>))</span><br><span class="line"><span class="built_in">print</span>(cut_rod_dp(p,<span class="number">20</span>))</span><br><span class="line">------------------------------------</span><br><span class="line">p长度：<span class="number">23</span></span><br><span class="line">test_cut_rod_recursion1 running time：<span class="number">0.46545886993408203</span>secs</span><br><span class="line"><span class="number">60</span></span><br><span class="line">cut_rod_dp running time：<span class="number">5.078315734863281</span>e-05secs</span><br><span class="line"><span class="number">60</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>切割方案输出</p>
</blockquote>
<p>递推公式:<br>$$<br>r_n = max_{}(p_i+r_{n-i}),  1\leq i \leq n<br>$$<br>需要单独开一个s列表，记录最优解对应的不切割长度</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gv3pgvgz4qj311u08amyn.jpg" alt="image-20211004234050160"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">p = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">17</span>,<span class="number">17</span>,<span class="number">20</span>,<span class="number">21</span>,<span class="number">23</span>,<span class="number">24</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">27</span>,<span class="number">28</span>,<span class="number">30</span>,<span class="number">33</span>,<span class="number">36</span>,<span class="number">39</span>,<span class="number">40</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cut_rod_extend</span>(<span class="params">p,n</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;同时输出切分方案&quot;&quot;&quot;</span></span><br><span class="line">    r =[<span class="number">0</span>]</span><br><span class="line">    s = [<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">        res_r = <span class="number">0</span>  <span class="comment"># 价格最大值</span></span><br><span class="line">        res_s = <span class="number">0</span>  <span class="comment"># 价格最大值对应的方案的左边不切割 部分长度</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, i + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> p[j] + r[i - j]&gt;res_r:</span><br><span class="line">                res_r = p[j] + r[i - j]</span><br><span class="line">                res_s = j</span><br><span class="line">        r.append(res_r)</span><br><span class="line">        s.append(res_s)</span><br><span class="line">    <span class="keyword">return</span> r[n],s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cut_rod_solution</span>(<span class="params">p,n</span>):</span></span><br><span class="line">    <span class="comment"># 返回切割方案，以及最优价格 </span></span><br><span class="line">    r,s = cut_rod_extend(p,n)</span><br><span class="line">    ans = []  <span class="comment"># 切割方案存放</span></span><br><span class="line">    <span class="keyword">while</span> n&gt;<span class="number">0</span>:</span><br><span class="line">        ans.append(s[n])</span><br><span class="line">        n -= s[n]</span><br><span class="line">    <span class="keyword">return</span> ans, r, s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(cut_rod_solution(p, <span class="number">20</span>))</span><br><span class="line">([<span class="number">2</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>], <span class="number">56</span>, [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br></pre></td></tr></table></figure>



<p>​    </p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><p><a target="_blank" rel="noopener" href="https://blog.fundebug.com/2018/08/27/code-interview-data-structure/">代码面试需要知道的8种数据结构(附面试题及答案链接)</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1uA411N7c5?p=1">清华大学博士讲解Python数据结构与算法（完整版）全套100节</a><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gv18apj01qj61hy0u0dm402.jpg" alt="image-20200815171822878"></p>
</li>
<li><p>《图解算法》<img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2h127v9mdj217m0u045r.jpg" alt="image-20220522113636934"></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.geekxh.com/0.01.%E6%8C%87%E5%AF%BC%E5%AD%A6%E4%B9%A0/023.html">小浩算法指导学习（三）</a></p>
</li>
</ol>
<blockquote>
<p>但你需要知道为什么创造/引入它，它有什么特殊的，它满足哪些场景，又不满足哪些场景，不满足的场景又如何替代。这才是对数据结构的良好理解。</p>
<p>其实，除了算法，在我看来很多别的知识也是这样。<strong>只是说算法，更容易在面试的时候去展示而已。本身而言，并没有什么特殊的。</strong></p>
<p>比如学习操作系统。那我们为什么学习操作系统？难道是让我们造出来一个操作系统吗？显而易见并不是。学习操作系统是让我们了解为什么会提出OS，如果没有OS又会是什么样子。它怎么样做任务调度，怎么样做进程管理，怎么样对可用的硬件做成抽象，死锁是如何产生的，内存是怎么管理的，文件系统是如何实现的，通信是指谁与谁的通信。不是说应付了考试就算学了，而是带着脑子掌握这个东西的脉络，这才是核心。</p>
</blockquote>
</div></article></div><div class="right-container"><div class="widget"><div id="arAnchorBar"></div></div></div></section></div><div class="right-menu"></div><div class="modal search-modal"><div class="input-field"><input type="text" id="search_input"><label for="search-input">搜索</label></div><div id="search_result" class="search-result"></div></div><div class="blog-overlay"></div><footer class="row"><div class="footer-con"><div class="paginator"><a href="/2021/04/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%EF%BC%88%E5%8A%A0%E9%A4%90%EF%BC%89/" title="⭐️数据结构与算法之美（加餐）" class="prev">PREV</a><a href="/2021/04/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%EF%BC%88%E9%AB%98%E7%BA%A7%E7%AF%87%EF%BC%89/" title="⭐️数据结构与算法之美（高级篇 &amp; 实战篇）" class="next">NEXT</a></div><div class="copyright"><p>© 2016 - 2022 <a target="_blank">John Doe</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <br> and <a href="https://github.com/Bulandent/hexo-theme-bubuzou" target="_blank">hexo-theme-bubuzou</a></p><p> <span style="padding-right: 6px;">闽ICP备16007301号-2</span></p></div><div class="totop"><i></i></div></div></footer><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/jquery-1.8.2.min.js"></script><script src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/articleCatalog.js"></script><script src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/main.js"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>